15hDKywdfm0FtOjqbVhpvTHzavRg2WSrb .dev3
Blueprint Maestro v3.3: DFS-Invest-Suite

**Descripción Conceptual Detallada de Artefactos y Flujos**
**PARTE I: VISIÓN ARQUITECTÓNICA, ESTRATEGIA SAAS Y GOBERNANZA TÉCNICA (Conceptual)**
(Se mantiene la descripción de alto nivel ya proporcionada, enfocada en los "porqués" y las decisiones estratégicas.)
Introducción a dfs-invest-suite (Objetivos SaaS)
Modelo de Negocio SaaS y Arquitectura Multi-Tenant (Aislamiento de DB, Config por Tenant)
Plataforma WhatsApp Business (PWB) (Cloud API, API Admin, Activos, Precios, Políticas)
Gobernanza Técnica del Proyecto (Stack, Principios Arquitectónicos, Calidad, CI/CD)

**PARTE II: DISEÑO CONCEPTUAL DETALLADO DEL DOMINIO (LIBS/CORE/)**
II.A. Dominio: shared (libs/shared)
Propósito Conceptual: Albergar definiciones transversales y puras, agnósticas a cualquier lógica de negocio o infraestructura específica, para asegurar consistencia y reutilización en toda la suite.
Artefactos Conceptuales:
Tipos Globales: Interfaces genéricas como Maybe<T>, PaginatedResult<T>, y el estándar IApiResponse<T> para las respuestas de api-main.
Enums Globales: Definiciones de enumeraciones que representan estados o categorías comunes a varios dominios (ej. EWhatsAppQualityRating, EMessageCategory, EInternalTenantStatus).
Utilidades Puras: Funciones helpers sin estado para tareas comunes (manipulación de fechas, strings, objetos) que no dependen de ningún contexto de aplicación o dominio.
Errores Personalizados Base: Clases BaseError, DomainError, ApplicationError, InfrastructureError, NotFoundError para una jerarquía de errores estandarizada.
Comportamiento/Flujo: No tienen comportamiento activo; son consumidos por otras librerías y aplicaciones para asegurar tipado y lógica común.
II.B. Dominio: tenancy (libs/core/src/tenancy/)
Propósito Conceptual: Modelar el concepto de "Tenant" (empresa cliente) y los contratos (puertos) para acceder a su información de configuración y persistencia. Es el pilar del multi-tenancy.
Artefactos Conceptuales:
Entidad Tenant: Representa a una empresa cliente. Contiene su ID único de plataforma, nombre, plan de suscripción, estado (ACTIVE, PENDING_ONBOARDING, etc.), y los identificadores clave para sus servicios externos (ej. wabaId). Importante: NO almacena directamente secretos como tokens de API o connection strings de DB; para eso están los puertos de configuración. Su comportamiento incluye la gestión de su propio ciclo de vida (activar, suspender, cambiar plan).
Puerto ITenantRepositoryPort: Define el contrato para persistir y recuperar entidades Tenant. Las operaciones se realizan sobre una base de datos central de la plataforma.
Puerto ITenantConfigRepositoryPort: Define el contrato para acceder de forma segura a la configuración sensible de un tenant, como las credenciales de la API de WhatsApp (token, WABA ID) y la cadena de conexión a su base de datos dedicada. Su implementación se encargará de la encriptación/desencriptación.
II.C. Dominio: whatsapp (libs/core/src/whatsapp/)
Propósito Conceptual: Definir las estructuras de datos (tipos) que modelan los mensajes y eventos de la API de WhatsApp Business, y los puertos que abstraen la interacción con las APIs de Meta.
Artefactos Conceptuales:
Tipos de Payloads de Envío (TWhatsAppApiMessageRequest y sus sub-tipos): Define la estructura exacta de los objetos JSON que se envían al endpoint /messages de la Cloud API para cada tipo de mensaje (texto, media, plantilla, interactivo). Estos tipos deben ser una representación fiel de la especificación oficial de Meta.
Tipos de Payloads de Webhook (TWhatsAppWebhook...Value): Define la estructura del objeto value para cada field de webhook que dfs-invest-suite procesará (ej. messages, account_update, message_template_status_update). Estos tipos deben mapear la información recibida de Meta.
Tipos de Activos WhatsApp (Respuesta API Admin): Define cómo se representan en nuestro sistema los datos de una plantilla (WhatsAppTemplateFromApi) o un número de teléfono (WabaPhoneNumberDetailsFromApi) cuando se obtienen de la API de Administración.
Puerto IWhatsAppMessagePort: Contrato para enviar mensajes a través de la Cloud API. Su único método sendMessage recibe el payload del mensaje y el identificador del número emisor del tenant.
Puerto IWhatsAppAdminPort: Contrato para interactuar con la API de Administración de WhatsApp para gestionar plantillas (CRUD), números (listar, obtener detalles, verificar, registrar), perfiles de empresa, y media (para ejemplos).
Eventos de Dominio/Aplicación (con tenantId): Define los eventos internos que se emiten tras procesar un webhook o una acción de API (ej. IncomingWhatsAppMessageReceivedEvent, WhatsAppTemplateStatusChangedEvent). Estos eventos llevan el tenantId para asegurar el contexto.
II.D. Dominio: anti-ban (libs/core/src/anti-ban/)
Propósito Conceptual: Contiene la lógica de negocio pura para proteger las cuentas WhatsApp de un tenant específico, gestionando la salud y límites de sus números y tomando decisiones de envío.
Artefactos Conceptuales:
Entidad WhatsAppAccount: Representa un número de teléfono específico de la WABA de un tenant. Almacena su estado de salud interno (healthScore), el qualityRating y messagingLimitTier reportados por Meta, su operationalStatus (definido por dfs-invest-suite), y otras métricas relevantes para el Anti-Ban. Su comportamiento incluye actualizar su salud basada en eventos y calcular si es apto para enviar.
Puerto IWhatsAppAccountRepositoryPort: Contrato para persistir y recuperar entidades WhatsAppAccount de la base de datos del tenant actual. Incluye un método crucial findNextAvailableForSending que implementa la heurística de selección del mejor número.
Puerto IRateLimiterPort: Contrato para el control de frecuencia de envío por número de tenant. Define métodos para consumir/verificar tokens y para configurar dinámicamente los límites.
Servicio de Dominio AntiBanDecisionService: El cerebro del Anti-Ban. Recibe una solicitud de envío (con tenantId y detalles del mensaje) y, basándose en el estado de los números del tenant (del IWhatsAppAccountRepositoryPort) y los límites de tasa (del IRateLimiterPort), decide si el mensaje debe ser ENVIADO (y por cuál número), ENCOLADO, o RECHAZADO. Aplica lógica de warm-up, cool-down y costo de token.
II.E. Dominio: leads-flow (libs/core/src/leads-flow/)
Propósito Conceptual: Modelar el ciclo de vida de un Lead, sus interacciones y el proceso de calificación.
Artefactos Conceptuales:
Entidad Lead: Representa un cliente potencial, con sus datos de contacto, estado en el pipeline, score de calificación, historial de opt-in para WhatsApp, y asociación a un consultor del tenant.
Entidad LeadInteraction (o integrada en MessageLog): Registra cada punto de contacto con el lead.
Puerto ILeadRepositoryPort: Contrato para la persistencia de Leads.
Servicios de Dominio (Ejemplos): LeadQualificationRulesService (para reglas de negocio de calificación), LeadNurturingLogicService.
II.F. Dominio: users-roles (libs/core/src/users-roles/)
Propósito Conceptual: Gestionar los usuarios (consultores, supervisores) que operan dentro de un tenant y sus roles/permisos.
Artefactos Conceptuales:
Entidad User: Representa un usuario de dfs-invest-suite perteneciente a un tenant.
Enum ETenantUserRole: Define los roles dentro de un tenant.
Puerto IUserRepositoryPort: Para persistencia de usuarios del tenant.
Servicios de Dominio: UserAuthenticationDomainService (validación de credenciales), UserAuthorizationDomainService (verificación de permisos).
II.G. Dominio: aiper-assistance (libs/core/src/aiper-assistance/)
Propósito Conceptual: Abstraer la interacción con diferentes motores de Inteligencia Artificial para tareas como análisis de sentimiento/intención, sugerencia de respuestas, etc.
Artefactos Conceptuales:
Puerto IConversationAnalyzerPort: Contrato para analizar texto de conversación y devolver resultados estructurados (intent, sentiment, entities).
Puerto IPromptManagerPort: Contrato para gestionar y construir prompts para los modelos de IA.
II.H. Dominio: message-template-record (libs/core/src/message-template-record/)
Propósito Conceptual: Mantener un registro local (en la DB del tenant) de las plantillas de mensajes de WhatsApp de ese tenant, sincronizado con Meta.
Artefactos Conceptuales:
Entidad MessageTemplateRecord: Almacena HSM_ID de Meta, nombre, idioma, categoría, estado de Meta, calidad de Meta, estado interno de dfs-invest-suite, y el JSON de sus components y example.
Puerto IMessageTemplateRecordRepositoryPort: Para persistencia.
II.I. Dominio: billing (libs/core/src/billing/)
Propósito Conceptual: Modelar los conceptos de tarifas y uso facturable para el seguimiento de costos de WhatsApp por tenant.
Artefactos Conceptuales:
Entidad WhatsAppPricingRate: Almacena las tarifas de Meta por país, categoría, modelo. (Podría ser una tabla global en la DB de plataforma).
Entidad BilledUsage: Registra cada conversación o mensaje facturable para un tenant.
Puertos: IWhatsAppPricingRatesRepositoryPort, IBilledUsageRepositoryPort.
(Continuará con la Parte III: DISEÑO CONCEPTUAL DETALLADO DE LA CAPA DE APLICACIÓN (LIBS/APPLICATION/) en el próximo prompt).

---

**PARTE III: DISEÑO CONCEPTUAL DETALLADO DE LA CAPA DE APLICACIÓN (LIBS/APPLICATION/)**
La Capa de Aplicación es el orquestador. No contiene lógica de negocio pura (eso es del Dominio) ni interactúa directamente con la infraestructura externa (eso es de la Infraestructura). Su función es coordinar las acciones, implementar los casos de uso específicos de la aplicación y manejar flujos de trabajo que involucran múltiples dominios o interacciones con puertos de infraestructura. Todos los Casos de Uso y Listeners en esta capa son Tenant-Aware.
III.A. Gestión del Contexto del Tenant (Conceptual)
Flujo: Cada Caso de Uso o Listener de Eventos que opera sobre datos de un tenant específico debe:
Recibir el tenantId como parte de su input (ej. desde un controlador de API que lo extrajo del JWT, o desde el payload de un evento emitido por el WhatsappWebhookProcessor).
Utilizar este tenantId para:
Indicar a los Puertos de Repositorio (ej. ILeadRepositoryPort, IWhatsAppAccountRepositoryPort) sobre qué base de datos de tenant deben operar sus implementaciones (Prisma).
Pasarlo a los Puertos de API Externa (ej. IWhatsAppMessagePort, IWhatsAppAdminPort) para que sus implementaciones (adaptadores) puedan obtener las credenciales específicas del tenant (apiToken, wabaId) desde el ITenantConfigRepositoryPort.
III.B. Submódulo: tenancy (libs/application/src/tenancy/)
Propósito Conceptual: Casos de uso para la gestión de la plataforma a nivel de tenant (onboarding, configuración).
Artefactos Conceptuales (Casos de Uso):
CreateTenantUseCase:
Input: Datos del nuevo tenant (nombre, plan inicial, email del primer admin).
Lógica: Orquesta ITenantRepositoryPort.save() (para crear la entidad Tenant en DB de plataforma), IDatabaseProvisioningServicePort.provisionTenantDatabase() (puerto de infraestructura para crear la DB dedicada al tenant y aplicar migraciones), y ICreateTenantUserUseCase (del dominio users-roles de aplicación, para crear el primer admin en la DB del nuevo tenant). Emite TenantCreatedEvent.
SetTenantWhatsAppConfigUseCase:
Input: tenantId, wabaId, apiToken (provisto por el tenant), lista de phoneNumbersToRegisterInSuite.
Lógica: Llama a ITenantConfigRepositoryPort.setWhatsAppApiCredentials() (guarda token encriptado en DB de plataforma). Para cada phoneNumberId del tenant, llama a IAccountHealthManagerServicePort.onboardNewPhoneNumber() para crear/actualizar el WhatsAppAccount en la DB del tenant. Llama a IWhatsAppAdminPort.subscribeAppToWabaEvents() para que nuestro webhook global reciba eventos de la WABA del tenant. Actualiza Tenant.isWhatsAppConfigured y Tenant.status.
(Otros Casos de Uso): GetTenantDetailsUseCase, UpdateTenantSubscriptionPlanUseCase.
III.C. Submódulo: whatsapp (libs/application/src/whatsapp/)
Propósito Conceptual: Casos de uso y listeners para orquestar la funcionalidad de mensajería y gestión de activos de WhatsApp para un tenant.
Artefactos Conceptuales:
Caso de Uso SendWhatsAppMessageUseCase:
Input: ISendWhatsAppMessageUseCaseInput (que incluye tenantId, messageData: TWhatsAppApiMessageRequest, recipientPhoneNumber, etc.).
Lógica:
Establece el contexto del tenantId.
Si messageData.type === 'template', llama a IManageWhatsAppTemplateUseCase.validateTemplateForSending(tenantId, messageData.template.name, ...) o directamente a IWhatsAppAdminPort.getMessageTemplateById(...) (pasando credenciales del tenant) para verificar que la plantilla del tenant esté APPROVED y con buena calidad. Si no, retorna error.
Crea/actualiza MessageLog (vía IMessageLogRepositoryPort) en estado PENDING_ANTI_BAN.
Llama a IAntiBanDecisionService.determineSendAction(tenantId, messageCategory, ...) para obtener decision.
Actualiza MessageLog con la decisión.
Si decision.action === 'SEND', llama a IWhatsAppMessagePort.sendMessage(messageData, decision.accountId, tenantApiToken) (el adaptador usa el token del tenant).
Maneja el resultado y actualiza MessageLog.
Listeners de Eventos (para eventos emitidos por WhatsappWebhookProcessor):
IncomingMessageApplicationListener:
Recibe IncomingWhatsAppMessageReceivedEvent({ tenantId, ... }). Establece contexto.
Llama a ILeadRepositoryPort para buscar/crear el Lead en la DB del tenant.
Llama a IMessageLogRepositoryPort para registrar la interacción en la DB del tenant.
Llama a IConversationAnalyzerPort.analyze(...) (pasando tenantId si la config de IA es por tenant).
Emite LeadIncomingMessageProcessedEvent({ tenantId, ... }).
(Opcional) Llama a IWhatsAppMessagePort.markMessageAsRead(...) (usando credenciales del tenant).
MessageStatusApplicationListener:
Recibe WhatsAppMessageStatusUpdatedEvent({ tenantId, ... }). Establece contexto.
Llama a IMessageLogRepositoryPort para actualizar el MessageLog en la DB del tenant.
Llama a ICostCalculationServicePort.recordUsage({ tenantId, statusDetails }).
Si el estado es failed, llama a IAccountHealthManagerServicePort.processMessageFailure({ tenantId, ... }).
AssetUpdateApplicationListener:
Recibe eventos como WhatsAppTemplateStatusChangedEvent({ tenantId, ... }), WhatsAppPhoneNumberQualityUpdatedEvent({ tenantId, ... }), etc. Establece contexto.
Llama a los métodos correspondientes de IAccountHealthManagerServicePort (pasando tenantId) para actualizar el estado de los activos WA del tenant.
Llama a IMessageTemplateRecordRepositoryPort para actualizar la caché de plantillas del tenant.
Caso de Uso ManageWhatsAppTemplateUseCase:
createTemplate(input: { tenantId, wabaIdToUse, creationData }): Valida, llama a IWhatsAppAdminPort.createMessageTemplate (pasando token del tenant). Si éxito, guarda en IMessageTemplateRecordRepositoryPort (en DB del tenant).
syncAllForTenant(input: { tenantId, wabaIdToUse }): Llama a IWhatsAppAdminPort.listMessageTemplates. Actualiza IMessageTemplateRecordRepositoryPort.
Caso de Uso SyncWhatsAppAssetsUseCase:
Orquesta la sincronización de números y plantillas para un tenantId específico, llamando a los métodos de IWhatsAppAdminPort y luego a los servicios de aplicación/dominio para actualizar el estado interno (AccountHealthManagerService, ManageWhatsAppTemplateUseCase).
III.D. Submódulo: anti-ban (libs/application/src/anti-ban/)
Propósito Conceptual: Orquestar la gestión de la salud de las cuentas WhatsApp de los tenants.
Artefactos Conceptuales:
Servicio de Aplicación (o Puerto) AccountHealthManagerService (implementando IAccountHealthManagerServicePort):
Lógica: Contiene los métodos que son llamados por los AssetUpdateApplicationListener o el SyncWhatsAppAssetsUseCase.
Ej: updatePhoneNumberStateFromWebhook(tenantId, phoneNumberId, qualityUpdatePayload):
Establece TenantContext.
Obtiene WhatsAppAccount del IWhatsAppAccountRepositoryPort.
Llama a los métodos de la entidad WhatsAppAccount para actualizar qualityRating, status, healthScore, operationalStatus.
Guarda la entidad actualizada.
Si messagingLimitTier cambió (basado en qualityUpdatePayload o una consulta fresca a IWhatsAppAdminPort), llama a IRateLimiterPort.configureLimits(tenantId, phoneNumberId, newPoints, newDuration).
Emite eventos de aplicación si hay cambios significativos (ej. WhatsAppAccountOperationalStatusChangedEvent({ tenantId, ... })).
Otros métodos: processAccountViolation, processAccountRestriction, processMessageFailure, syncPhoneNumberStateFromApi, triggerWarmUp, triggerCoolDown, setManualOperationalStatus. Todos operan en el contexto del tenantId.
III.E. Submódulo: leads-flow (libs/application/src/leads-flow/)
Propósito Conceptual: Casos de uso para la gestión del ciclo de vida de los leads de un tenant.
Artefactos Conceptuales (Casos de Uso):
ImportLeadsUseCase: Recibe tenantId. Parsea archivo. Crea Leads en la DB del tenant.
QualifyLeadUseCase: Recibe tenantId, leadId. Usa IConversationAnalyzerPort (con contexto de tenant si la config de IA es por tenant). Actualiza Lead.score y Lead.statusLead en la DB del tenant.
AssignLeadUseCase: Recibe tenantId, leadId. Asigna a un User (consultor) del tenant.
GetLeadDetailsUseCase, ListLeadsUseCase: Consultan la DB del tenant.
III.F. Submódulo: billing (libs/application/src/billing/)
Propósito Conceptual: Casos de uso y servicios para la facturación de WhatsApp y el seguimiento de costos por tenant.
Artefactos Conceptuales:
Servicio de Aplicación CostCalculationService (implementando ICostCalculationServicePort):
Método recordUsage(input: { tenantId: string, statusDetails: TMessageStatusObject }).
Usa IWhatsAppPricingRatesRepositoryPort (para tarifas globales) y IBilledUsageRepositoryPort (para guardar en DB del tenant).
Caso de Uso GetTenantCostReportUseCase:
Recibe tenantId. Consulta IBilledUsageRepositoryPort (de la DB del tenant).
III.G. Submódulo: aiper-assistance (libs/application/src/aiper-assistance/)
Propósito Conceptual: Casos de uso para interactuar con la IA.
Artefactos Conceptuales:
AnalyzeConversationTextUseCase:
Recibe tenantId, textToAnalyze.
Obtiene config de IA del tenant (si aplica) desde ITenantConfigRepositoryPort.
Llama a IConversationAnalyzerPort.analyze(...).
(Continuará con la Parte IV: DISEÑO DETALLADO DE LA CAPA DE INFRAESTRUCTURA - REFINADA FINAL, enfocándonos en cómo los adaptadores de infraestructura implementan los puertos siendo tenant-aware, en el próximo prompt).

---

---

**PARTE IV: DISEÑO DETALLADO DE LA CAPA DE INFRAESTRUCTURA (LIBS/INFRASTRUCTURE/)**
Esta capa es la implementación concreta de los puertos definidos en el Dominio (Core) y la Aplicación. Aquí es donde interactuamos con las tecnologías específicas (PostgreSQL, Redis, APIs de Meta, APIs de IA) y donde la lógica de "tenant-awareness" se materializa a nivel de conexión y configuración.
IV.A. Submódulo: tenancy-persistence (libs/infrastructure/src/tenancy-persistence/)
Propósito: Persistencia de la entidad Tenant y su configuración sensible. Opera sobre la base de datos de plataforma centralizada.
Artefactos:
prisma/platform-schema.prisma (NUEVO ARCHIVO ESPECÍFICO):
Define los modelos Tenant (con id, name, status, planId, wabaId?, encryptedWhatsAppApiToken?, encryptedDbConnectionString?, defaultPhoneNumberIdForSending?, isWhatsAppConfigured?, etc.) y cualquier otra tabla necesaria para la gestión de la plataforma global.
Se generará un PrismaClient específico para este schema: @prisma/platform-client.
providers/platform-prisma.service.ts:
NestJS Provider que instancia y provee @prisma/platform-client.
repositories/prisma-tenant.repository.ts:
Implementa ITenantRepositoryPort. Inyecta PlatformPrismaService.
Realiza operaciones CRUD sobre la tabla Tenant en la DB de plataforma.
repositories/secure-tenant-config.repository.ts:
Implementa ITenantConfigRepositoryPort. Inyecta PlatformPrismaService y IEncryptionServicePort.
Lee/escribe campos encriptados (encryptedWhatsAppApiToken, encryptedDbConnectionString) de la tabla Tenant en la DB de plataforma. Desencripta/encripta usando IEncryptionServicePort.
IV.B. Submódulo: security (libs/infrastructure/src/security/)
Propósito: Implementaciones de servicios de seguridad.
Artefactos:
services/aes-encryption.service.ts:
Implementa IEncryptionServicePort (de libs/core/security/ports/ o shared/security/).
Usa crypto de Node.js y la PLATFORM_MASTER_ENCRYPTION_KEY (de ConfigService) para encriptar/desencriptar datos sensibles de los tenants.
passport/jwt-tenant.strategy.ts (para api-main):
Estrategia Passport para validar JWTs de usuarios de tenants. Extrae userId, tenantId, role del payload del token.
guards/roles-tenant.guard.ts (para api-main):
NestJS Guard que verifica si el usuario autenticado (con su rol dentro del tenant) tiene permiso para la acción solicitada.
IV.C. Submódulo: persistence (libs/infrastructure/src/persistence/)
Propósito: Implementación de repositorios para las entidades de negocio de CADA TENANT, operando sobre la base de datos aislada del tenant.
Artefactos:
prisma/schema.prisma (Plantilla para Tenants): Como se definió antes, sin tenantId en los modelos.
providers/tenant-prisma.service.ts (o tenant-prisma-client.factory.ts): ¡CRÍTICO!
Clase TenantPrismaService (NestJS Service Scope.REQUEST) o un Factory.
Dependencias: TenantContextService (para obtener tenantId del request/job actual), ITenantConfigRepositoryPort (para obtener la dbConnectionString del tenant).
Lógica getClient(): PrismaClient (o método similar):
const tenantId = this.tenantContextService.getTenantId();
const decryptedDbConnectionString = await this.tenantConfigRepo.getDecryptedDbConnectionString(tenantId);
Si no hay string o es inválida, lanzar InfrastructureError.
Retornar new PrismaClient({ datasources: { db: { url: decryptedDbConnectionString } } });
Gestión de Pool/Cache de Instancias PrismaClient: Mantener un Map<string, PrismaClient> (clave tenantId) para reutilizar instancias y evitar crear una nueva en cada request. Manejar await prisma.$connect() y await prisma.$disconnect() apropiadamente (ej. onModuleDestroy para el servicio si es Singleton y el Map es estático, o si es Scope.REQUEST, NestJS podría manejarlo).
Repositorios (ej. repositories/prisma-whatsapp-account.repository.ts):
Inyectan TenantPrismaService.
En cada método, obtienen el cliente contextualizado: const prisma = this.tenantPrismaService.getClient();.
Implementan los métodos de los puertos de dominio (IWhatsAppAccountRepositoryPort, ILeadRepositoryPort, etc.).
Acción IA Nx: Generar estos repositorios.
IV.D. Submódulo: cache (libs/infrastructure/src/cache/)
Artefactos:
redis.provider.ts: Provee instancia global de ioredis.
adapters/redis-rate-limiter.adapter.ts:
RedisRateLimiterAdapter implementando IRateLimiterPort.
Usa ioredis y rate-limiter-flexible.
Claves de Redis: rate_limit:${tenantId}:${accountId} y rl_config:${tenantId}:${accountId}.
Método configureLimits(tenantId, accountId, points, duration) actualiza la config en Redis.
Método consumeToken(tenantId, accountId, cost) lee config y consume de la clave principal.
Fallback a RateLimiterMemory si Redis falla.
(Opcional) adapters/redis-tenant-scoped-cache.adapter.ts:
Si se necesita un servicio de cache genérico que sea tenant-aware.
Métodos get(tenantId, key), set(tenantId, key, value, ttl). Claves Redis: cache:${tenantId}:${key}.
IV.E. Submódulo: queue (libs/infrastructure/src/queue/)
Artefactos:
queue.module.ts: Registra colas BullMQ (WHATSAPP_OUTBOUND_QUEUE, WHATSAPP_WEBHOOK_QUEUE, WHATSAPP_CAMPAIGN_LEAD_PROCESSING_QUEUE).
processors/whatsapp-outbound.processor.ts:
WhatsappOutboundProcessor. Job data: { tenantId, ...ISendWhatsAppMessageUseCaseInput }.
Lógica process(job):
Extraer tenantId y payload.
Usar TenantContextService.runWithContext(tenantId, async () => { ... }) para encapsular la lógica que depende del contexto del tenant.
Dentro del callback, resolver/inyectar SendWhatsAppMessageUseCase (que se volverá tenant-aware gracias al TenantContextService que afecta a sus dependencias como PrismaService y TenantConfigRepositoryPort).
Llamar a useCase.execute(payload).
Manejo de errores/reintentos como se detalló.
processors/whatsapp-webhook.processor.ts:
WhatsappWebhookProcessor. Job data: { tenantId, payloadWebhook }.
Lógica process(job):
Extraer tenantId y payloadWebhook.
Usar TenantContextService.runWithContext(tenantId, async () => { ... }).
Dentro del callback, parsear payloadWebhook y usar EventEmitter2 (que podría ser request-scoped o se le podría pasar tenantId al emitir) para emitir eventos de dominio/aplicación que incluyan el tenantId.
processors/whatsapp-campaign-lead.processor.ts: Similar al OutboundProcessor, para procesar lotes de leads de campañas.
IV.F. Submódulos: whatsapp-cloud-api y whatsapp-admin-api (Adaptadores)
Artefactos: WhatsappOfficialApiAdapter y WhatsAppAdminApiAdapter.
Implementación Tenant-Aware:
En el constructor, inyectan TenantContextService y ITenantConfigRepositoryPort.
Cada método público (ej. sendMessage, createMessageTemplate):
Obtiene el tenantId del TenantContextService (o lo recibe como parámetro si es llamado desde un worker de cola que ya tiene el tenantId).
Llama a this.tenantConfigRepo.getDecryptedWhatsAppApiCredentials(tenantId) para obtener el apiToken, wabaId del tenant.
Usa estas credenciales específicas del tenant para realizar la llamada a la API de Meta.
Los Circuit Breakers se gestionan con claves tenantId:${resourceId} (ej. tenantId:${phoneNumberId}).
IV.G. Submódulo: ai-providers (libs/infrastructure/src/ai-providers/)
Artefactos:
adapters/google-gemini.adapter.ts (o AiperAssistanceAdapter):
Implementa IConversationAnalyzerPort.
Tenant-Aware (Opcional/Flexible):
Si cada tenant tiene su propia API Key de Gemini/OpenAI: Inyecta TenantContextService y ITenantConfigRepositoryPort para obtener la API Key del tenant.
Si la plataforma usa una API Key global y factura a los tenants por uso: No necesita tenantId para la autenticación con la IA, pero el AnalyzeConversationTextUseCase (aplicación) pasaría el tenantId como metadato a la IA para tracking/facturación interna.
services/prompt-library.service.ts: Podría cargar prompts base, y permitir que la configuración del tenant (obtenida vía ITenantConfigRepositoryPort) especifique prompts personalizados o ajustes.
IV.H. Submódulo: observability (libs/infrastructure/src/observability/)
Artefactos:
logger/nest-logger.adapter.ts:
Implementa ILoggerPort. Usa Pino.
Tenant-Aware Logging: Intenta inyectar TenantContextService (opcionalmente, usando @Inject({ forwardRef: () => TenantContextService, optional: true })). Si tenantId está disponible en el contexto, lo añade a cada entrada de log.
telemetry/opentelemetry.config.ts (Para api-main y workers):
Configuración del SDK OpenTelemetry, instrumentaciones automáticas (NestJS, HTTP, Prisma, BullMQ), y exportadores (Jaeger/Prometheus).
Tenant-Aware Tracing/Metrics: Los spans y métricas deben, en lo posible, ser etiquetados con el tenantId obtenido del contexto.

**PARTE V: DISEÑO DETALLADO DE LAS APLICACIONES (APPS/)** (SaaS Multi-Tenant)
Las aplicaciones son los puntos de interacción con los usuarios y sistemas externos. Deben ser robustas, seguras y ofrecer una experiencia de usuario adecuada a su propósito, siempre operando dentro del contexto del tenant (para pwa-supervisor y pwa-consultant) o a nivel de plataforma (para admin-platform).
V.A. Aplicación: api-main (API Gateway Principal Multi-Tenant)
Ubicación: apps/api-main/
Tecnología: NestJS, GraphQL (Apollo Server), REST (para Webhooks), WebSockets (Socket.io).
Propósito Principal (Reafirmado): Fachada central para todas las PWAs de tenant, el admin-platform, y futuras integraciones. Gestiona autenticación/autorización, establece contexto de tenant, y orquesta llamadas a Casos de Uso de la Capa de Aplicación.
Estructura y Artefactos Clave (Implementación Detallada):
main.ts:
Configuración de TenantContextMiddleware (global o para rutas específicas de tenant).
Configuración de bodyParser para rawBody.
Configuración de GraphQLModule con context factory que provea tenantId y userId (del JWT) a los resolvers.
Configuración de SocketIoAdapter y NotificationsGateway (tenant-aware).
app.module.ts: Módulo raíz. Importa todos los módulos de dominio de API (ej. LeadsApiModule, WhatsAppApiModule, TenancyApiModule, AuthApiModule, PlatformAdminApiModule).
auth/ (Módulo de Autenticación):
auth.service.ts: Lógica para loginTenantUser (valida credenciales contra IUserRepositoryPort del tenant, genera JWT con userId, tenantId, role) y loginPlatformAdminUser (lógica separada).
jwt-tenant.strategy.ts y jwt-platform-admin.strategy.ts: Estrategias Passport.
auth.resolver.ts: Mutaciones GraphQL para login.
middleware/tenant-context.middleware.ts:
Extrae tenantId del JWT (para rutas protegidas) o de un header/parámetro (para casos especiales o identificación inicial).
Usa TenantContextService.runWithContext(tenantId, next) para establecer el contexto para el resto del request.
Módulos de Dominio API (ej. domains/leads/leads-api.module.ts):
Declara los Resolvers (ej. LeadsResolver).
Importa y Provee los Casos de Uso de la capa de aplicación (@dfs-suite/application) y los Puertos de Dominio (@dfs-suite/core).
Las implementaciones de Repositorio (ej. @Inject(LEAD_REPOSITORY_PORT) useClass: PrismaLeadRepository) se resolverán con el PrismaService contextualizado gracias al TenantContextMiddleware y el Scope.REQUEST del TenantPrismaService.
webhooks/controllers/whatsapp-webhook.controller.ts:
Lógica como se detalló: valida firma global, resuelve tenantId desde WABA_ID (usando ITenantConfigRepositoryPort de la DB de plataforma), y encola job con payload y tenantId.
realtime/notifications.gateway.ts:
Gateway Socket.io.
Conexión Tenant-Aware: Al conectarse un cliente PWA, este debe enviar su JWT. El gateway valida el JWT y suscribe el socket a un "room" específico del tenant (ej. tenant:${tenantId}).
Listeners de Eventos de Aplicación: @OnEvent(...) para eventos como LeadIncomingMessageProcessedEvent({ tenantId, ... }).
Emisión a Clientes: Si el evento es para el tenantId de un room con clientes conectados, emite el mensaje WebSocket a ese room: this.server.to(\tenant:${event.tenantId}`).emit('newEvent', event.payload);`.
Cuellos de Botella a Evitar:
Resolución de tenantId en Webhook Controller: La consulta a la DB de plataforma para mapear WABA_ID a tenantId debe ser muy rápida (cacheable).
Instanciación de PrismaClient por Tenant: El TenantPrismaService debe gestionar eficientemente un pool de clientes o asegurar que la creación bajo demanda no sea un overhead excesivo (Prisma es relativamente rápido en instanciar si la connection string ya está resuelta).
V.B. Aplicación: pwa-supervisor (Detalle Funcional y Técnico)
Flujos de Usuario Clave (Ejemplos Detallados):

1. Login y Carga del Dashboard:
   Frontend: Envía credenciales a api-main (mutación loginTenantUser). Recibe JWT, lo almacena.
   Frontend: Navega a /dashboard. TenantContext (React) se establece con tenantId del JWT.
   Frontend: Múltiples componentes del dashboard realizan queries GraphQL a api-main (ej. getTenantWhatsAppHealthKPIs, getOpenLeadsCount). React Query gestiona el fetching y cacheo. Todas las queries envían el JWT.
   Backend (api-main): TenantContextMiddleware setea tenantId. Resolvers llaman Casos de Uso que operan sobre DB/config del tenant.
   Frontend: Cliente Socket.io se conecta a api-main, se une al room tenant:${tenantId}.
2. Supervisor Crea una Nueva Campaña de Marketing WhatsApp:
   Frontend (whatsapp/campaigns/create):
   Formulario para nombre, selección de plantilla (query listTenantMessageTemplates filtrando por category: MARKETING, status: APPROVED), definición de audiencia (ej. subida de CSV de waIds o selección de segmento), configuración de variables de plantilla, programación.
   Al enviar, llama a mutación GraphQL createCampaign(input: { name, templateId, ...}).
   Backend (api-main):
   CampaignsResolver.createCampaign (con tenantId del contexto) llama a ICreateCampaignUseCase.execute({tenantId, ...}).
   El Caso de Uso crea la entidad Campaign en la DB del tenant.
   Frontend: Muestra confirmación. La lista de campañas se actualiza (vía invalidación de query React Query o evento WebSocket).
3. Supervisor Monitorea un Número WA Específico:
   Frontend (whatsapp/accounts/[phoneNumberId]):
   Muestra quality_rating, messaging_limit_tier, healthScore, operationalStatus (obtenidos vía getTenantWhatsAppAccountDetails).
   Opción para cambiar operationalStatus a MAINTENANCE_BY_ADMIN (llama a mutación).
   Backend (api-main):
   Mutation.updateWhatsAppAccountOperationalStatus llama a IAccountHealthManagerServicePort.setManualOperationalStatus(tenantId, phoneNumberId, newStatus).
   Actualización en Tiempo Real: Si Meta cambia la calidad del número, el flujo de webhook actualiza la DB del tenant, api-main emite evento WebSocket, y la UI del supervisor se actualiza.
   Componentes de libs/ui-shared/ Utilizados: DataTable, Button, Input, Select, DatePicker, Card, KPIWidget, NotificationToast.
   V.C. Aplicación: pwa-consultant (Detalle Funcional y Técnico)
   Flujos de Usuario Clave:
4. Ver "Mis Leads" y Detalle de Lead:
   Frontend: Query listMyAssignedLeads (envía JWT del consultor). Muestra lista.
   Al seleccionar un lead, query getLeadDetailsForConsultant (incluye MessageLog[] filtrado para ese lead y los números del tenant).
5. Responder a un Lead por WhatsApp (desde Vista de Interacción):
   Frontend:
   Si es respuesta libre (CSW abierta): Input de texto.
   Si es plantilla: Selector de plantillas (listApprovedTemplatesForTenant). Campos para variables.
   Botón "Enviar". Llama a mutación sendWhatsAppMessageFromConsultant(input: { leadId, messageContent: {type, text?, template?}, ...}).
   Backend (api-main):
   Resolver la mutación, obtener tenantId y userId del consultor desde JWT.
   Validar que el lead esté asignado a ese consultor (o su equipo).
   Llamar a SendWhatsAppMessageUseCase.execute({ tenantId, recipientPhoneNumber: lead.waId, ...}).
6. Recibir Nuevo Mensaje de un Lead Asignado:
   Flujo de Webhook (como antes) identifica el tenantId y el Lead.
   Si el Lead está asignado a un consultor activo, api-main (vía NotificationsGateway) envía notificación WebSocket al room tenant:${tenantId}:user:${consultantUserId} (o un room de equipo).
   pwa-consultant recibe la notificación y actualiza la UI (badge, toast, refresca conversación).
   Componentes de libs/ui-shared/ Utilizados: ChatInterface, MessageBubble, TaskItem, LeadCard.
   V.D. Aplicación: admin-platform (Detalle Funcional y Técnico)
   Flujos de Usuario Clave (Administrador de Plataforma):
7. Onboarding de Nuevo Tenant:
   Frontend: Formulario para datos del tenant (nombre, plan, email del primer admin).
   Llama a mutación platformCreateTenant (endpoint GraphQL específico para admin de plataforma).
   Backend (api-main): PlatformAdminResolver llama a CreateTenantUseCase (de application/tenancy). Este UC orquesta:
   Creación de registro Tenant en DB de plataforma.
   Llamada a IDatabaseProvisioningServicePort.provisionTenantDatabase(tenantId) (Infraestructura).
   Creación del primer User (rol TENANT_ADMIN) en la NUEVA DB del tenant (vía IUserRepositoryPort contextualizado).
   Envío de email de bienvenida al admin del tenant.
8. Configurar Credenciales WA de un Tenant:
   Frontend: Formulario para tenantId, wabaId, apiTokenWA, etc.
   Llama a mutación platformSetTenantWhatsAppConfig.
   Backend: PlatformAdminResolver llama a SetTenantWhatsAppConfigUseCase.
9. Monitoreo Global:
   Queries GraphQL especiales que agregan datos (anonimizados) de múltiples tenants (ej. número total de mensajes, salud promedio de la plataforma). Requiere lógica de agregación compleja en el backend.

---

---

PARTE VI: CONSIDERACIONES CROSS-CUTTING AVANZADAS (SaaS Multi-Tenant)
Estos son aspectos arquitectónicos y de ingeniería que no pertenecen a un único módulo, sino que atraviesan múltiples capas y componentes de la plataforma dfs-invest-suite. Su correcta implementación es vital para la robustez, seguridad, escalabilidad y mantenibilidad a largo plazo.
VI.A. Seguridad Avanzada (Aplicada a toda la Suite)
Autenticación y Autorización (AuthN/AuthZ):
Usuarios de Tenant (pwa-supervisor, pwa-consultant):
Mecanismo: JWT (JSON Web Tokens) firmados con un algoritmo fuerte (ej. ES256).
Flujo: Login vía api-main (email/password) -> Validación contra IUserRepositoryPort (contextualizado al tenant) y UserAuthenticationDomainService -> Emisión de JWT con userId, tenantId, role (ej. TENANT_ADMIN, SUPERVISOR, CONSULTANT), permissions (granulares, si aplica), y expiration.
Storage JWT en Cliente: HttpOnly, Secure cookies para PWAs web. Para la futura app nativa, almacenamiento seguro específico de la plataforma.
Refresh Tokens: Implementar para extender sesiones sin re-autenticación frecuente.
Administradores de Plataforma (admin-platform):
Mecanismo de autenticación separado y potencialmente más robusto (ej. MFA obligatorio por defecto, integración con SSO de MetaShark/DFS si existe). JWT con platformAdminId, platformRole.
Llamadas API Máquina-a-Máquina (M2M):
Para futuras integraciones de terceros o servicios internos, usar OAuth 2.0 Client Credentials Flow para obtener tokens de acceso con scopes limitados.
RBAC (Role-Based Access Control):
En api-main, guards NestJS (@UseGuards(RolesGuard)) y decoradores (@Roles('TENANT_ADMIN')) para proteger resolvers y controladores, basados en el rol del JWT.
La lógica de UserAuthorizationDomainService (libs/core/users-roles/) define qué puede hacer cada rol.
Seguridad de Datos:
Encriptación en Reposo:
Credenciales sensibles de tenants (tokens API WA, connection strings DB) encriptadas en la DB de plataforma usando AesEncryptionService con una PMEK robusta.
Datos sensibles DENTRO de las DBs de los tenants (ej. PII de leads) pueden requerir encriptación a nivel de columna si el requisito de cumplimiento es muy alto (PostgreSQL tiene extensiones como pgcrypto). Para MVP, asegurar seguridad a nivel de acceso a la DB.
Encriptación en Tránsito: HTTPS/TLS 1.3 obligatorio para todas las comunicaciones (PWAs <-> api-main, api-main <-> APIs Externas, api-main <-> DBs/Redis).
Protección de APIs Externas:
Validación de firma HMAC-SHA256 para todos los webhooks entrantes de WhatsApp.
Validación de firma para webhooks de endpoints de Flows (si dfs-invest-suite los implementa).
Prevención de Vulnerabilidades Comunes (OWASP Top 10):
Validación de input en api-main (DTOs con class-validator).
Sanitización de output en PWAs para prevenir XSS.
Protección CSRF (NestJS tiene soporte, Next.js también).
Cabeceras de seguridad HTTP (Helmet en NestJS).
Manejo seguro de errores (no exponer detalles sensibles).
Seguridad de Infraestructura:
Endurecimiento de configuración de servidores, bases de datos, Redis.
Gestión de acceso a la infraestructura con principio de mínimo privilegio.
Firewalls, VPCs, grupos de seguridad.
VI.B. Observabilidad Integral (Aplicada a toda la Suite)
Logging Estructurado (Pino vía NestLoggerAdapter):
Formato: JSON.
Contexto Automático: timestamp, level, service_name (ej. "api-main", "whatsapp-outbound-processor").
Contexto Adicional (CRÍTICO):
tenantId: Siempre que una operación sea en el contexto de un tenant. El NestLoggerAdapter puede intentar obtenerlo del TenantContextService.
userId: Para acciones iniciadas por un usuario.
traceId: Para correlacionar logs a través de múltiples servicios/operaciones (OpenTelemetry lo provee).
jobId: Para logs dentro de workers BullMQ.
waMessageId, wabaId, phoneNumberId: Para logs específicos de WhatsApp.
Niveles de Log: DEBUG, INFO, WARN, ERROR, FATAL. Configurables por entorno.
Centralización: Enviar logs a un sistema centralizado (ELK Stack, Grafana Loki, Datadog, etc.).
Métricas (Prometheus y Grafana):
Métricas de Aplicación (api-main, Workers):
Tasa de requests, latencia, tasa de error (por ruta/resolver/job).
Uso de CPU/Memoria.
Tamaño de colas BullMQ, tasas de procesamiento, fallos.
Estado de Circuit Breakers (abierto/cerrado, fallos).
(NestJS puede exponer un endpoint /metrics para Prometheus).
Métricas de Negocio (Agregadas y por Tenant):
Número de mensajes enviados/recibidos/fallidos (por dfs-invest-suite).
Calidad promedio de números/plantillas (por dfs-invest-suite, anonimizado).
Número de tenants activos.
(Los KPIs específicos del tenant se exponen en pwa-supervisor).
Métricas de Infraestructura: Salud de DBs, Redis, Kubernetes/VMs.
Tracing Distribuido (OpenTelemetry con Jaeger o Grafana Tempo):
Instrumentación Automática: Para NestJS, HttpService (Axios), Prisma, BullMQ.
Propagación de Contexto de Trace: Asegurar que el traceId se propague a través de llamadas HTTP, mensajes de cola y eventos.
Visualización: En Jaeger/Tempo para analizar la latencia de operaciones completas y identificar cuellos de botella.
Alertas (Alertmanager integrado con Prometheus y Grafana):
Alertas Técnicas: Alta tasa de error API, latencia elevada, colas llenas, Circuit Breakers abiertos por mucho tiempo, fallos de DB/Redis.
Alertas de Negocio/Anti-Ban (para Admins de Plataforma y/o Tenants):
Webhook de ACCOUNT_VIOLATION/ACCOUNT_RESTRICTION recibido.
Número de tenant con quality_rating: RED persistente.
Plantilla de tenant PAUSED/DISABLED.
Baja tasa de entrega masiva para una campaña de un tenant.
VI.C. Performance y Escalabilidad (Estrategias a Nivel de Suite)
Escalabilidad Horizontal de api-main y Workers BullMQ:
Al ser stateless (el estado de tenant se carga dinámicamente), se pueden añadir más instancias detrás de un balanceador de carga (Kubernetes HPA).
Escalabilidad de Bases de Datos (PostgreSQL):
Por Tenant: Si un tenant crece mucho, su DB dedicada puede escalarse verticalmente (más CPU/RAM) o, en casos extremos, moverse a una instancia de servidor de DB más potente.
Lectura: Implementar réplicas de lectura para las DBs de tenants con alta carga de lectura.
Sharding de Plataforma (Muy Futuro): Si la DB de plataforma (que gestiona tenants) crece demasiado, se podría considerar sharding.
Optimización de Queries (Prisma):
Uso de índices adecuados en todas las DBs (plantilla y plataforma).
Análisis de query plans para queries lentas (EXPLAIN ANALYZE).
Evitar N+1 problemas en GraphQL (usar DataLoader de NestJS).
Estrategias de Caching (Redis):
Configuración de Tenant: Cachear la configuración de conexión a DB y tokens WA de tenants (después de desencriptar) en TenantContextService (para la duración de un request) o en un cache Redis de plataforma con TTL corto para reducir lecturas a la DB de plataforma y desencriptaciones.
Datos de Aplicación Frecuentes: Cachear resultados de queries GraphQL comunes (ej. lista de plantillas aprobadas de un tenant, perfil de usuario).
Rate Limiting: Ya cubierto.
Optimización de Frontend (PWAs):
Code splitting, lazy loading de componentes/rutas (Next.js lo hace bien).
Optimización de imágenes.
Caching de Service Worker para PWA offline y assets.
Minimizar tamaño de bundles JavaScript.
VI.D. Gestión de Errores y Resiliencia (Nivel Suite)
Circuit Breakers (Opossum): En TODOS los adaptadores que llaman a APIs externas críticas (WhatsappOfficialApiAdapter, WhatsAppAdminApiAdapter, AiperAssistanceAdapter). Claves por tenantId:resourceId.
Reintentos Inteligentes:
En adaptadores para errores de red/5xx.
En procesadores de cola BullMQ (con backoff exponencial).
Idempotencia: En procesadores de cola y listeners de eventos para manejar re-entregas.
Fallback y Degradación Agraciada:
Si una API de IA externa falla, ¿hay un modelo local más simple o una respuesta por defecto?
Si Redis falla, el RedisRateLimiterAdapter podría tener un fallback a RateLimiterMemory (más conservador y loggeando una alerta crítica).
Dead Letter Queues (DLQs): Para jobs que fallan consistentemente en BullMQ, para análisis manual.
VI.E. Feature Flags y Configuración Dinámica
Feature Flags: Usar un sistema de feature flags (ej. Unleash, LaunchDarkly, o uno simple basado en config) para habilitar/deshabilitar funcionalidades por tenant o globalmente, permitiendo despliegues graduales y A/B testing.
Configuración Centralizada (fuera de .env para algunos parámetros):
Parámetros del Anti-Ban (umbrales de healthScore, costos de token, políticas de warm-up) podrían ser configurables desde admin-platform y almacenados en la DB de plataforma, con un cache en api-main.

---

---

**PARTE VII: ROADMAP DE IMPLEMENTACIÓN HIPERGRANULAR (SaaS Multi-Tenant - CONSOLIDADO Y FINAL)**
Este roadmap es la guía para el desarrollo iterativo e incremental de dfs-invest-suite, priorizando la funcionalidad core para el "Tenant Semilla" mientras se construye la fundación multi-tenant. Cada Sprint se estima en ~2 semanas (ajustable).
Dependencia CRÍTICA Transversal Persistente: Obtención de la documentación oficial de Meta con los detalles JSON finales para:
Creación de Plantillas API Admin: Estructura completa de components y example para TODOS los tipos de header multimedia y botones complejos (OTP, FLOW, MPM, CATALOG).
Webhooks de Gestión: Payloads value para account_update (todos los event), message_template_quality_update, phone_number_quality_update.
API Admin Consulta Números: Campo y estructura para messaging_limits (Tier) y throughput.
Fase 0: Fundación del Proyecto y Setup SaaS Básico (Ya debería estar en curso/completada)
Sprints 0.1-0.3 (Estimado 2-3 semanas):
Workspace Nx, tooling base (TS, ESLint, Prettier, Jest, Husky).
Apps iniciales (api-main, pwa-supervisor). Libs (core, application, infrastructure, shared, ui-shared).
Docker Compose (PostgreSQL para DB Plataforma y DB Tenant Semilla; Redis global).
CI/CD básico.
Dominio tenancy (Tenant entidad, ITenantRepositoryPort, ITenantConfigRepositoryPort).
Infraestructura tenancy-persistence (PrismaTenantRepository para DB Plataforma), security (AesEncryptionService), tenancy-config (SecureTenantConfigRepository).
TenantContextService v0.1. PrismaService dinámico v0.1 (capaz de conectar a DB Tenant Semilla).
Fase ST-1: Conectividad WhatsApp, Mensajería Básica y Webhooks messages (Tenant-Aware)
Sprint ST-1.0: Configuración y Verificación WA para Tenant Semilla (~3-5 días):
Tareas de WA-0 adaptadas: Configurar App Meta global, WABA y Número(s) del Tenant Semilla, generar y almacenar su Token de Usuario del Sistema WA (encriptado).
Endpoint Webhook (WhatsappWebhookController) verificable por Meta, con lógica inicial para resolver tenantId vía WABA_ID y encolar {payload, tenantId}.
Sprint ST-1.1: Envío de Mensajes (Texto y Plantilla Simple) Tenant-Aware (~8-10 días):
WhatsappOfficialApiAdapter v1.0 (tenant-aware: usa token/IDs del tenant obtenidos vía TenantContextService y ITenantConfigRepositoryPort). Envío de texto y plantillas simples. Circuit Breaker por tenantId:phoneNumberId.
Dominio whatsapp: Tipos TWhatsAppApiMessageRequest (para texto, plantilla simple), MessageSentSuccess/FailedEvent (con tenantId).
Dominio message-log: Entidad MessageLog (en DB del tenant). IMessageLogRepositoryPort.
Infraestructura persistence: PrismaMessageLogRepository (tenant-aware).
Aplicación whatsapp: SendWhatsAppMessageUseCase v0.1 (tenant-aware, Anti-Ban mínimo: usa un número activo del tenant).
Infraestructura queue: WhatsappOutboundProcessor v0.1 (tenant-aware, llama a SendWhatsAppMessageUseCase).
Sprint ST-1.2: Recepción de Webhooks messages Tenant-Aware (~8-10 días):
whatsapp-security.utils.ts: Finalizar verifyWebhookSignature (basado en ejemplos Node.js).
WhatsappWebhookController: Integración final de validación de firma y encolamiento con tenantId.
Dominio whatsapp: Tipos TWhatsAppWebhookMessagesValue y sub-tipos (TReceivedMessageObject, TMessageStatusObject, TWebhookErrorObject). Eventos IncomingWhatsAppMessageReceivedEvent y WhatsAppMessageStatusUpdatedEvent (ambos con tenantId).
Infraestructura queue: WhatsappWebhookProcessor v1.0 (tenant-aware, parsea field: "messages", emite eventos de dominio tipados con tenantId).
Aplicación whatsapp (Listeners):
IncomingMessageApplicationListener v0.1 (tenant-aware): Busca/crea Lead (en DB tenant), crea MessageLog (en DB tenant). Llama a IWhatsAppMessagePort.markMessageAsRead.
MessageStatusApplicationListener v0.1 (tenant-aware): Actualiza MessageLog (en DB tenant).
Fase ST-2: Núcleo Anti-Ban v1.0 y Gestión de Salud (Tenant-Aware)
Sprint ST-2.1: Monitoreo Básico de Salud de Números (API Admin y Webhooks) (~8-10 días):
Dominio anti-ban: Entidad WhatsAppAccount v1.1 (con qualityRating, messagingLimitTier de Meta, operationalStatus, healthScore internos). IWhatsAppAccountRepositoryPort.
Infraestructura persistence: PrismaWhatsAppAccountRepository v1.1 (tenant-aware).
Infraestructura whatsapp-admin-api: WhatsAppAdminApiAdapter v1.1 (tenant-aware, implementa getPhoneNumberDetails para calidad/límites, listPhoneNumbers).
GAP: Respuesta exacta de GET /{phone-number-id} para quality_rating y messaging_limits.
Dominio whatsapp: Tipos para webhooks phone_number_quality_update y account_update (BUSINESS_CAPABILITY_UPDATE).
Infraestructura queue: WhatsappWebhookProcessor v1.1 (procesa estos nuevos webhooks, emite eventos con tenantId).
Aplicación anti-ban: AccountHealthManagerService v0.1 (listeners para estos eventos, actualiza WhatsAppAccount en DB del tenant).
Aplicación whatsapp: SyncWhatsAppAssetsUseCase v0.1 (sincroniza números del tenant).
Sprint ST-2.2: Anti-Ban v1.0 (Decisión Multi-Número, Rate Limiter Dinámico) (~8-10 días):
Dominio anti-ban: IRateLimiterPort (con configureLimits). AntiBanDecisionService v1.0 (tenant-aware, usa findNextAvailableForSending con heurística inicial, costo de token, warm-up/cool-down básico).
Infraestructura cache: RedisRateLimiterAdapter v2.0 (con configureLimits dinámico por tenantId:phoneNumberId).
Aplicación anti-ban: AccountHealthManagerService v0.2 (llama a rateLimiter.configureLimits al cambiar Tier).
Job programado para resetear currentConversationsInitiated24h.
Sprint ST-2.3: Manejo de Restricciones y Plantillas Problemáticas (Tenant-Aware) (~5-7 días):
Dominio whatsapp: Tipos para webhooks account_update (ACCOUNT_VIOLATION/RESTRICTION) y message_template_status_update (REJECTED/PAUSED/DISABLED).
Infraestructura queue: WhatsappWebhookProcessor v1.2 (procesa estos webhooks).
Aplicación anti-ban: AccountHealthManagerService v1.1 (reacciona a estos eventos críticos para el tenant, actualiza operationalStatus a SUSPENDED_BY_META_CONFIRMED, alerta).
Aplicación whatsapp: SendWhatsAppMessageUseCase v1.1 (valida estado de plantilla desde IMessageTemplateRecordRepository antes de llamar a Anti-Ban).
GAP: Payloads JSON oficiales de value para estos webhooks de gestión.
Fase ST-3: Gestión Avanzada de Plantillas, Costos, UI pwa-supervisor MVP (Tenant-Aware)
Sprint ST-3.1: Creación/Gestión de Plantillas API (Tenant-Aware) (~10-12 días):
Dominio message-template-record: Entidad MessageTemplateRecord, IMessageTemplateRecordRepositoryPort.
Infraestructura persistence: PrismaMessageTemplateRecordRepository.
Dominio whatsapp: Tipo WhatsAppTemplateCreationApiRequest.
Infraestructura whatsapp-admin-api: WhatsAppAdminApiAdapter v2.0 (implementa createMessageTemplate, listMessageTemplates, updateMessageTemplate, deleteMessageTemplate - tenant-aware).
GAP CRÍTICO: Estructura JSON de components.example para TODOS los tipos de header/botones al crear plantillas.
Aplicación whatsapp: ManageWhatsAppTemplateUseCase v1.0 (crea, lista, sincroniza plantillas para el tenant).
Sprint ST-3.2: Cálculo de Costos y Preparación PMP (Tenant-Aware) (~8-10 días):
Dominio billing: Entidades WhatsAppPricingRate, BilledUsage. Puertos de repositorio.
Infraestructura persistence: Repositorios Prisma para Billing (DB del tenant para BilledUsage, DB de plataforma para WhatsAppPricingRate global).
Aplicación billing: CostCalculationService v1.0 (procesa pricing de webhooks, calcula y registra costos para el tenant).
GAP: Tarjetas de Tarifas oficiales CBP y PMP.
Sprint ST-3.3: pwa-supervisor MVP - Salud WA y Costos (Tenant-Aware) (~10-12 días):
api-main: Resolvers GraphQL para exponer datos de salud de WhatsAppAccount, MessageTemplateRecord, y costos agregados del tenant.
pwa-supervisor: Desarrollo de dashboards y vistas para monitorear estos KPIs (solo del tenant autenticado). Acción para cambiar operationalStatus de números.
Fase ST-4: Funcionalidades Avanzadas (Post-MVP, Tenant-Aware)
Sprints ST-4.x (Iterativo):
Soporte completo para envío/recepción de todos los Mensajes Interactivos y Flows en WhatsappOfficialApiAdapter y WhatsappWebhookProcessor.
Implementación de la estrategia "DFS-Educa" con plantillas de utilidad.
Refinamiento de AntiBanDecisionService (rotación, afinidad, IA predictiva).
pwa-consultant MVP (lista de leads, chat WA, envío de plantillas).
admin-platform MVP (onboarding básico de tenants, monitoreo global simple).
Integración aiper-assistance (IConversationAnalyzerPort).
Fase ST-5: Optimización Continua y Escalado de Plataforma (Continuo)
Monitoreo, optimización de costos de infraestructura y API, adaptación a cambios de Meta, nuevas funcionalidades.

---

---

---

**_Visión Arquitectónica Global de dfs-invest-suite (SaaS Multi-Tenant)_**
Imaginemos dfs-invest-suite como un sistema nervioso central para empresas inmobiliarias, con diferentes "órganos" (aplicaciones) especializados que interactúan a través de una "médula espinal" (API principal) y comparten un "cerebro" (lógica de dominio y aplicación).
I. Estructura del Monorepo Nx (dfs-invest-suite/)
La base es un monorepo Nx que organiza el código en dos categorías principales: apps/ y libs/.
apps/ (Puntos de Interacción con el Usuario/Sistema):
api-main (La Médula Espinal Central):
Tecnología: NestJS, GraphQL (principal), REST (para webhooks y algunas integraciones específicas).
Función: Es la API Gateway principal y el backend orquestador. Maneja TODAS las solicitudes entrantes de las aplicaciones frontend y de sistemas externos (como webhooks de Meta).
Arquitectura Interna: Modularizada por dominio funcional (ej. LeadsModule, WhatsAppModule, TenancyModule, UsersModule). Cada módulo expone resolvers GraphQL y, si es necesario, controladores REST.
Lógica Multi-Tenant: Implementa el TenantContextMiddleware/Guard para identificar al tenant en cada request. Autentica y autoriza usuarios de tenants.
Conexión: Llama a los Casos de Uso en libs/application/.
pwa-supervisor (Anteriormente dev-flow - El Centro de Mando del Tenant):
Tecnología: Next.js (App Router), React, Tailwind CSS, Shadcn/UI, TanStack Query, Zustand.
Función: PWA para los administradores y supervisores de CADA TENANT. Les permite gestionar leads, consultores, campañas, ver la salud de sus números de WhatsApp, sus plantillas, costos, y analíticas específicas de su operación.
Conexión: Consume exclusivamente la API GraphQL de api-main. Usa WebSockets (conectados a api-main) para actualizaciones en tiempo real.
pwa-consultant (La Herramienta de Campo del Tenant):
Tecnología: Similar a pwa-supervisor.
Función: PWA optimizada para que los consultores de CADA TENANT gestionen sus leads asignados, registren interacciones, accedan a historiales, envíen mensajes WhatsApp (libres y plantillas seleccionadas), y vean sus KPIs personales.
Conexión: Consume exclusivamente la API GraphQL de api-main. Usa WebSockets para notificaciones y actualizaciones.
admin-platform (El Panel de Control de la Suite para NOSOTROS):
Tecnología: Similar a pwa-supervisor.
Función: PWA para los administradores de la plataforma dfs-invest-suite (MetaShark/DFS). Permite gestionar tenants (onboarding, planes, facturación - futuro), monitorear la salud global de la plataforma, desplegar configuraciones globales, y acceder a analíticas agregadas (anonimizadas) de uso de la suite.
Conexión: Consume una sección protegida de la API GraphQL de api-main (o potencialmente una API admin separada si la lógica se vuelve muy distinta).
portal-imoveis (Portal Público del Tenant - Plantilla/Futuro):
Tecnología: Next.js (probablemente con enfoque SSG/ISR para performance y SEO).
Función: Un portal web público que CADA TENANT podría desplegar (o nosotros hostear para ellos, usando una plantilla base que desarrollamos) para mostrar sus propiedades/SPEs, capturar leads (formularios, botones de chat WA).
Conexión:
Para la captación de leads: Envía datos a un endpoint específico en api-main (REST o mutación GraphQL) que crea el lead para el tenant correspondiente.
Para mostrar propiedades: Podría consumir datos de api-main (si dfs-invest-suite gestiona el inventario de SPEs) o integrarse con el sistema de inventario del tenant.
(Proyectado) app-native-aggregator (App Móvil para Consultores del Tenant):
Tecnología: React Native o Nativo (iOS/Android).
Función: Cliente móvil que permite a los consultores gestionar conversaciones de WhatsApp de múltiples números de su tenant desde una única interfaz.
Conexión: Consume la API GraphQL de api-main para obtener datos y enviar mensajes. Recibe notificaciones push de api-main para nuevos mensajes/eventos.
libs/ (El Cerebro y los Músculos - Lógica Reutilizable):
core/ (Dominio - El ADN del Negocio):
Tecnología: TypeScript puro, sin dependencias de framework.
Función: Define la lógica de negocio central, entidades, value objects, servicios de dominio y los Puertos (interfaces) que el dominio necesita del mundo exterior.
Subdominios (DDD Táctico):
tenancy/: Entidad Tenant, ITenantRepositoryPort, ITenantConfigRepositoryPort. Define qué es un tenant y cómo se accede a su configuración.
users-roles/: Entidad User (del tenant), Role, lógica de permisos básica. IUserRepositoryPort.
whatsapp/: Tipos TWhatsAppApiMessageRequest (para envío), TWhatsAppWebhookPayloads (para recepción), WhatsAppTemplateFromApi, WabaPhoneNumberDetailsFromApi. Puertos IWhatsAppMessagePort, IWhatsAppAdminPort. Eventos de dominio específicos de WhatsApp.
anti-ban/: Entidad WhatsAppAccount (representa un número del tenant), AntiBanDecisionService, IWhatsAppAccountRepositoryPort (implementado en infra, opera sobre DB del tenant), IRateLimiterPort.
leads-flow/: Entidad Lead, LeadInteraction, ILeadRepositoryPort, LeadQualificationRulesService.
properties-spe/: Entidades para Propiedades, SPEs, etc. (si se gestionan en la suite).
aiper-assistance/: Puertos IConversationAnalyzerPort, IPromptManagerPort. Tipos AnalysisResult.
campaigns/ (Ejemplo de nuevo dominio): Entidad Campaign, ICampaignRepositoryPort.
notifications-core/: Lógica para definir qué notificaciones existen y cuándo deben dispararse (agnóstico al canal de entrega).
analytics-core/: Lógica para definir y calcular KPIs, métricas (agnóstico a la fuente de datos final).
Clave: Totalmente independiente de la infraestructura.
application/ (Casos de Uso - El Director de Orquesta):
Tecnología: TypeScript. Puede tener dependencias mínimas si es necesario para DTOs o inyección de dependencias (pero no NestJS directamente).
Función: Orquesta los flujos de trabajo. Implementa los Casos de Uso (comandos, queries). Llama a los servicios de dominio y usa los puertos de infraestructura (a través de las interfaces de core/). Todos los casos de uso son Tenant-Aware.
Subdominios: Reflejan los de core/ (ej. application/src/whatsapp/use-cases/SendWhatsAppMessageUseCase.ts).
También incluye Listeners de Eventos que se suscriben a eventos de dominio/aplicación y disparan otros casos de uso.
infrastructure/ (Adaptadores - Los Músculos y Sentidos):
Tecnología: NestJS (muchos adaptadores serán Providers de NestJS), TypeScript.
Función: Provee las implementaciones concretas de los Puertos definidos en core/. Interactúa con el mundo exterior (DBs, APIs, Colas, Cache). Todos los adaptadores que manejan datos de tenant son Tenant-Aware.
Subdominios (por tipo de tecnología/propósito):
tenancy-persistence/: PrismaTenantRepository (para DB de plataforma).
tenancy-config/: SecureTenantConfigRepository (para secretos de tenant, usa EncryptionService).
security/: AesEncryptionService (implementa IEncryptionServicePort). Estrategias Passport JWT.
persistence/: PrismaService (dinámico por tenant). Implementaciones de repositorios Prisma para entidades de tenant (PrismaWhatsAppAccountRepository, PrismaLeadRepository, etc.).
cache/: RedisRateLimiterAdapter (implementa IRateLimiterPort, claves tenantId:accountId), RedisHealthCacheAdapter (opcional). Incluye redis.provider.ts.
queue/: QueueModule (configura BullMQ). Procesadores WhatsappWebhookProcessor y WhatsappOutboundProcessor (ambos tenant-aware, establecen TenantContext).
whatsapp-cloud-api/: WhatsappOfficialApiAdapter (implementa IWhatsAppMessagePort, tenant-aware para token/IDs).
whatsapp-admin-api/: WhatsAppAdminApiAdapter (implementa IWhatsAppAdminPort, tenant-aware).
ai-providers/: GoogleGeminiAdapter (implementa IConversationAnalyzerPort, puede ser tenant-aware para API keys).
observability/: NestLoggerAdapter (implementa ILoggerPort, puede incluir tenantId en logs). Configuración OpenTelemetry.
Clave: El PrismaService dinámico y la forma en que los adaptadores obtienen la configuración/credenciales del tenant (vía TenantContextService y ITenantConfigRepositoryPort) son fundamentales aquí.
shared/ (Kit de Herramientas Común):
Tecnología: TypeScript puro.
Función: Tipos globales (DTOs base, Enums), utilidades puras, constantes, errores personalizados, esquemas de validación Zod/Valibot. Reutilizable por backend y potencialmente frontend.
Clave: Cero dependencias de otras libs de dfs-invest-suite.
ui-shared/ (Biblioteca de Componentes Frontend):
Tecnología: React, TypeScript, Tailwind CSS, Shadcn/UI.
Función: Componentes UI (desde átomos hasta organismos) reutilizables en todas las PWAs (pwa-supervisor, pwa-consultant, admin-platform, portal-public-template).
Clave: Asegura consistencia visual y acelera el desarrollo frontend. Podría usar Storybook para desarrollo y documentación.
V. Herramientas y Configuración Raíz:
Prisma: Dos (o más) archivos schema.prisma: uno "plantilla" para las DBs de los tenants, y uno para la DB de plataforma. Scripts para generar clientes y aplicar migraciones.
BullMQ: Configurado para usar Redis. Colas definidas (WHATSAPP_OUTBOUND_QUEUE, WHATSAPP_WEBHOOK_QUEUE, etc.).
Docker & Docker Compose: Para entornos de desarrollo locales consistentes (PostgreSQL, Redis).
Nx: Gestiona dependencias, builds, tests, linting. nx.json y project.json son clave.
TypeScript (tsconfig.base.json y por proyecto): Configuración estricta.
Observabilidad (Open Source):
Logging: Pino (vía NestLoggerAdapter) para logs JSON estructurados.
Métricas: Prometheus (NestJS puede exponer un endpoint /metrics).
Tracing Distribuido: OpenTelemetry (con auto-instrumentación para NestJS, Http, Prisma, BullMQ) exportando a Jaeger o Grafana Tempo.
Visualización y Alertas: Grafana (para dashboards de métricas, logs de Loki si se usa, y traces de Jaeger/Tempo). Alertmanager para alertas basadas en métricas de Prometheus.
Implementación:
libs/infrastructure/observability/ contendrá la configuración del NestLoggerAdapter con Pino.
En apps/api-main/src/main.ts, se inicializará OpenTelemetry SDK.
Se configurarán exportadores de OpenTelemetry para Prometheus (métricas) y Jaeger/Tempo (traces).
Se desplegarán instancias Docker de Prometheus, Grafana, Loki (opcional), Jaeger/Tempo, Alertmanager.
VI. Flujos de Datos Clave (Reafirmando la Lógica Tenant-Aware):
Solicitud de API de PWA de Tenant: JWT identifica al tenant -> TenantContextMiddleware setea tenantId -> Caso de Uso opera con tenantId -> Repositorios usan PrismaService dinámico (conectado a DB del tenant) -> Adaptadores de API externa usan credenciales del tenant.
Webhook de WhatsApp Entrante: Endpoint global -> Valida firma (App Secret de plataforma) -> Resuelve tenantId vía WABA_ID (desde DB de plataforma) -> Encola job con payload y tenantId -> Procesador de Cola setea TenantContext -> Lógica y persistencia ocurren en el entorno del tenant.
VII. El Rol de "Educa" (Módulo de Contenido Educativo - libs/core/src/educa-content/ y libs/application/src/educa-content/):
Concepto: Un nuevo dominio y conjunto de casos de uso para gestionar contenido educativo sobre SPEs, el mercado inmobiliario, finanzas, etc.
Integración con leads-flow y whatsapp:
leads-flow puede identificar (vía IA de aiper-assistance o reglas) que un lead necesita "educación" en un tema específico.
Un NurturingUseCase (en application/leads-flow) podría seleccionar contenido relevante de IEducaContentRepositoryPort.
Este contenido se usaría para personalizar una plantilla de WhatsApp de tipo UTILITY (ej. "Aquí tienes la información que solicitaste sobre X" o "Vimos tu interés en Y, este artículo podría ayudarte a entender Z").
Se envía vía SendWhatsAppMessageUseCase.
Beneficio: Permite la estrategia "DFS-Educa" de forma estructurada, aportando valor al lead y aprovechando el potencial de plantillas de utilidad gratuitas (bajo PMP en CSW).
Acción IA Nx: Crear la estructura base para libs/core/src/educa-content/ y libs/application/src/educa-content/ con sus entidades (EducationalContent, ContentCategory), puertos de repositorio y casos de uso iniciales (CRUD para contenido, FindRelevantContentUseCase).
Este panorama global y la estructura detallada deberían proporcionar a la IA experta en Nx una base sólida para comenzar a generar el proyecto dfs-invest-suite. Los GAPs de información de Meta siguen siendo necesarios para la implementación precisa de la interacción con sus APIs.
