https://aistudio.google.com/app/prompts/1EuZ5p9F3Ew1PkadZR1UljZosc09Y2sl1 iamdfsinvestimentos.dev7

El Plan Maestro de Mejoras Transversales para DFS-Invest-Suite incluirá:
Resumen Ejecutivo:
Breve descripción del estado actual del proyecto (basado en el snapshot y la Fase 0 completada).
Principales áreas de mejora identificadas.
Beneficios esperados de implementar el plan.
Visión General Arquitectónica Actual y Propuesta:
Reiteración de la arquitectura hexagonal y DDD actual.
Cómo las mejoras propuestas refinarán y fortalecerán esta arquitectura.
Plan Detallado de Implementación de Mejoras (Priorizado):
Esta será la sección principal.
Organizaré las mejoras por categoría o impacto (ej. Correcciones Críticas, Mejoras de Robustez del Shared Kernel, Mejoras de Calidad de Código y DX, Mejoras de Testing, etc.).
Para cada mejora o grupo de mejoras relacionadas:
Descripción del Problema/Área de Mejora: Qué se identificó.
Solución Propuesta: Qué se debe hacer. Incluiré referencias a las convenciones del "Documento Maestro de Convenciones" cuando sea aplicable.
Archivos Principales Afectados: Listado de las librerías o archivos clave que se modificarían.
Pasos de Implementación Concretos (Ejemplos):
Proporcionaré un ejemplo de cómo se vería la corrección o mejora en uno de los archivos afectados. Por ejemplo, para el bug del correlationId, mostraré la corrección en CommandBase.ts.
Impacto Esperado y Beneficios: Por qué es importante esta mejora.
Prioridad: (🔴 Crítico, 🟠 Alta, 🟡 Media, 🟢 Baja)
Complejidad Estimada: (Baja, Media, Alta)
Posibles Riesgos o Efectos Secundarios: A considerar durante la implementación.
Artefactos Necesarios/Modificados:
Resumen de los tipos de artefactos que se crearán o modificarán (ej. nuevos tests unitarios, refactorización de clases base, actualización de project.json).
Plan de Pruebas y Verificación:
Estrategia general para validar que las mejoras no rompan la funcionalidad existente.
Cómo se verificaría el cumplimiento de las nuevas convenciones (ej. ejecución de linters, revisión de cobertura).
Modo de Trabajo para este Documento:
No analizaré nuevos archivos en este momento. Me basaré en:
El snapshot 2025-05-12-20-03-02_dfs-invest-suite-snapshot.txt.
El .DOCUMENTO-TECNICO-PROYECTO.md.
El .BITACORA.md.
El .ROADMAP.md.
El .DEUDA-TECNICA.md.
El "Documento Maestro de Convenciones y Estándares" que acabamos de desarrollar.
Todas nuestras discusiones y análisis previos.
Comenzaré a estructurar este "Plan Maestro de Mejoras Transversales". Dado su alcance, también lo presentaré en secciones.
PLAN MAESTRO DE MEJORAS TRANSVERSALES (DFS-Invest-Suite v0.5.1)

1. Resumen Ejecutivo
   El proyecto DFS-Invest-Suite se encuentra actualmente al final de la Fase 0 de su roadmap, con una base arquitectónica sólida establecida. Se ha implementado un monorepo Nx con PNPM, configurado con ESLint, Prettier y Jest. Las librerías fundamentales (shared y core/domain/shared-kernel) están definidas, y la lógica de dominio y aplicación inicial para el bounded context de Tenancy está mayormente implementada (a falta de tests para los Casos de Uso).
   Este Plan Maestro de Mejoras Transversales identifica áreas clave donde el proyecto puede ser fortalecido para asegurar mayor robustez, mantenibilidad, calidad de código y alineación con las mejores prácticas. Las mejoras se centran en:
   Corrección de Bugs Críticos: Principalmente la lógica de generación de correlationId.
   Robustecimiento del Shared Kernel: Añadiendo tests unitarios exhaustivos a las clases base y resolviendo deudas técnicas.
   Mejora de la Developer Experience (DX): Optimizando configuraciones de TypeScript y herramientas.
   Refinamiento de la Estrategia de Testing: Asegurando que passWithNoTests se gestione adecuadamente y se establezcan umbrales de cobertura.
   Consistencia y Adherencia a Convenciones: Reforzando las convenciones definidas.
   La implementación de este plan resultará en una base de código más confiable, más fácil de mantener y evolucionar, y que sirva como un ejemplo sólido para el desarrollo de futuros módulos y funcionalidades.
2. Visión General Arquitectónica Actual y Propuesta
   Actual: La arquitectura hexagonal con DDD táctico está bien delineada con capas shared, domain (shared-kernel y específico), application, y proyecciones para infrastructure y apps. Los tags de Nx y las depConstraints iniciales en ESLint soportan esta estructura.
   Propuesta (Refinamiento): Las mejoras propuestas no alteran fundamentalmente la arquitectura hexagonal existente, sino que la refuerzan y la hacen más robusta. Esto se logra mediante:
   Mayor Seguridad de Tipos: Refinando el uso de Branded Types, tipos de error, y la gestión de IDs.
   Mejor Desacoplamiento: Asegurando que los puertos y adaptadores se implementen correctamente y que la lógica de negocio permanezca pura en el dominio.
   Consistencia Mejorada: Aplicando las convenciones de manera uniforme.
   Calidad Validada: A través de una estrategia de testing más completa, especialmente para los componentes base.
   No se requiere un nuevo diagrama conceptual en este punto, ya que la arquitectura base se mantiene. Las mejoras son a nivel de implementación y calidad de los componentes existentes y futuros.

---

---

¡Perfecto! Continuamos con la Sección 3: Plan Detallado de Implementación de Mejoras (Priorizado) del Plan Maestro de Mejoras Transversales.
(Continuación del Plan Maestro de Mejoras Transversales) 3. Plan Detallado de Implementación de Mejoras (Priorizado)
A continuación, se detallan las mejoras agrupadas por prioridad y área de impacto.
3.1. 🔴 Correcciones Críticas y de Alta Prioridad
Estas mejoras abordan bugs funcionales o debilidades significativas que deben corregirse para asegurar la correcta operatividad y trazabilidad del sistema.
3.1.1. Corrección de Lógica de correlationId por Defecto
Descripción del Problema: Las clases base CommandBase, QueryBase y DomainEventBase utilizan actualmente un placeholder fijo (ej. 'CONTEXT_CORR_ID_CMD_PLACEHOLDER') como correlationId por defecto si no se proporciona uno explícitamente. Esto es un bug funcional grave ya que múltiples instancias compartirían el mismo ID de correlación, anulando el propósito de la trazabilidad única por flujo.
Solución Propuesta: Modificar los constructores de CommandBase.ts, QueryBase.ts y DomainEventBase.ts para que, si props.metadata.correlationId no se provee, se genere un nuevo y único CorrelationId utilizando UuidUtils.generateCorrelationId().
Archivos Principales Afectados:
libs/core/domain/shared-kernel/commands-queries/src/lib/command.base.ts
libs/core/domain/shared-kernel/commands-queries/src/lib/query.base.ts
libs/core/domain/shared-kernel/events/src/lib/domain-event.base.ts
Pasos de Implementación Concretos (Ejemplo para CommandBase.ts):
// libs/core/domain/shared-kernel/commands-queries/src/lib/command.base.ts
// ... imports ...
export abstract class CommandBase implements ICommand {
// ... otras propiedades ...
constructor(props?: Partial<ICommandMetadata>) {
this.commandId = UuidUtils.generate(); // Asumimos que CommandInstanceId es un UUID string

    // Lógica CORREGIDA para correlationId
    const providedCorrelationId = props?.correlationId;
    // Si se proporciona un correlationId y no está vacío, se usa.
    // Si no se proporciona o está vacío, se genera uno nuevo.
    const effectiveCorrelationId = (!Guard.isNil(providedCorrelationId) && !Guard.isEmpty(providedCorrelationId))
        ? providedCorrelationId
        : UuidUtils.generateCorrelationId();

    this.metadata = Object.freeze({
      correlationId: effectiveCorrelationId, // Usar el ID efectivo
      causationId: props?.causationId,
      timestamp: props?.timestamp || Date.now(),
      userId: props?.userId,
    });

}
}
// libs/core/domain/shared-kernel/commands-queries/src/lib/command.base.ts
/_ SECCIÓN DE MEJORAS (Existente, no se modifica por este fix) _/
/_ NOTAS PARA IMPLEMENTACIÓN FUTURA (Existente, no se modifica por este fix) _/

TypeScript
Se aplicarían cambios análogos en QueryBase.ts y DomainEventBase.ts.
Impacto Esperado y Beneficios:
Beneficio: Asegura la trazabilidad única y correcta de cada comando, query y evento a través del sistema. Fundamental para debugging y observabilidad.
Impacto: Corrección crítica. Los tests para estas clases base (a implementar) deberán verificar esta nueva lógica.
Prioridad: 🔴 Crítico
Complejidad Estimada: Baja (modificación de lógica en 3 archivos).
Riesgos/Efectos Secundarios: Mínimos si se implementa correctamente. El principal riesgo es no hacerlo.
3.1.2. Implementar Tests Unitarios para Clases Base del Shared Kernel y Schemas Zod
Descripción del Problema: Las clases base fundamentales (EntityBase, AggregateRootBase, ValueObjectBase, CommandBase, QueryBase, PaginatedQueryBase, DomainEventBase) y los esquemas Zod (common.schemas.ts, pagination.schemas.ts) actualmente no tienen tests unitarios. Las librerías correspondientes tienen passWithNoTests: true en sus project.json.
Solución Propuesta:
Crear archivos .spec.ts para cada una de estas clases base y archivos de schemas.
Implementar tests unitarios exhaustivos que cubran su lógica interna (constructores, métodos, validaciones, generación de valores por defecto, etc.).
Una vez que los tests estén implementados y pasando, cambiar passWithNoTests: true a false (o eliminar la línea) en los project.json de las librerías afectadas:
core-domain-shared-kernel-entities
core-domain-shared-kernel-value-objects
core-domain-shared-kernel-events
core-domain-shared-kernel-commands-queries
shared-validation-schemas
Archivos Principales Afectados:
Todos los project.json de las librerías mencionadas.
Creación de nuevos archivos .spec.ts dentro de cada librería.
Pasos de Implementación Concretos (Ejemplo para ValueObjectBase.spec.ts - esqueleto):
// libs/core/domain/shared-kernel/value-objects/src/lib/value-object.base.spec.ts
import { ValueObject } from './value-object.base';
import { ArgumentNotProvidedException } from '@dfs-suite/shared-errors';

interface TestProps { value: string }
class TestVO extends ValueObject<TestProps> {
constructor(props: TestProps) { super(props); }
protected validate(props: TestProps): void {
if (props.value === 'invalid') throw new Error('Invalid value');
}
}
// ... describe blocks para constructor, equals, unpack, validate (indirectamente) ...
// libs/core/domain/shared-kernel/value-objects/src/lib/value-object.base.spec.ts
/_ SECCIÓN DE MEJORAS _/
/_ NOTAS _/

TypeScript
Impacto Esperado y Beneficios:
Beneficio: Aumenta drásticamente la confianza en la estabilidad y corrección de los componentes más fundamentales del sistema. Previene regresiones. Sirve como documentación ejecutable.
Impacto: Requiere un esfuerzo de desarrollo significativo para escribir todos estos tests. Es un prerrequisito para considerar la Fase 0 como verdaderamente completa.
Prioridad: 🔴 Crítico (para la calidad y fiabilidad a largo plazo)
Complejidad Estimada: Media (por el volumen de tests a crear).
Riesgos/Efectos Secundarios: Descubrir bugs o debilidades en las clases base durante la escritura de tests (lo cual es positivo).
3.1.3. Resolver Deuda Técnica de @typescript-eslint/no-unsafe-return en ValueObjectBase.unpack()
Descripción del Problema: El método unpack() en ValueObjectBase.ts tiene una regla ESLint desactivada debido a que ESLint/TypeScript no puede inferir con certeza el tipo de retorno después de Object.freeze({ ...objectProps }) con genéricos.
Solución Propuesta:
Investigar alternativas de tipado o refactorización para unpack() que satisfagan la regla sin comprometer la funcionalidad.
Posibles enfoques:
Hacer explícito el tipo de propsCopy antes de Object.freeze.
Considerar si el tipo de retorno de unpack() debería ser Readonly<TProps> para alinearse con Object.freeze, y ajustar los VOs concretos (como TenantStatusVO.unpack() que devuelve TenantStatusEnum directamente) o los consumidores. (Actualmente, unpack para primitivos devuelve el primitivo, y para objetos, el objeto de props). La lógica actual de unpack que diferencia IDomainPrimitive es correcta. El problema es con el Object.freeze(propsCopy).
Si no se encuentra una solución de tipado superior, confirmar si la desactivación actual es la opción pragmática más aceptable, documentando extensamente la razón.
Archivos Principales Afectados:
libs/core/domain/shared-kernel/value-objects/src/lib/value-object.base.ts
Impacto Esperado y Beneficios:
Beneficio: Código más limpio, mayor seguridad de tipos si se encuentra una solución, o mayor confianza en la desactivación si se justifica bien.
Impacto: Esfuerzo de investigación y posible refactorización.
Prioridad: 🟠 Alta
Complejidad Estimada: Media (la investigación del tipado puede ser compleja).
Riesgos/Efectos Secundarios: Si se cambia el tipo de retorno de unpack(), podría afectar a muchos VOs y sus tests.
3.1.4. Tipado de IDs Consistente (AggregateId vs. Branded IDs como TenantId)
Descripción del Problema: Hay casts as unknown as AggregateId o as unknown as TenantId en los Casos de Uso (ej. CreateTenantUseCase, ActivateTenantUseCase) porque los puertos de repositorio genéricos (IRepositoryPort) esperan AggregateId, mientras que los comandos o entidades pueden usar IDs más específicos como TenantId.
Solución Propuesta (Mejora Propuesta 1 de repository.port.ts y otras):
Hacer IRepositoryPort<Aggregate extends AggregateRoot<any>, IDType extends AggregateId = AggregateId> genérico para el tipo de ID.
Las interfaces de repositorio específicas definirían el IDType (ej. ITenantRepository extends IRepositoryPort<TenantEntity, TenantId>).
Los métodos en IRepositoryPort (como findOneById) usarían IDType.
Archivos Principales Afectados:
libs/core/domain/shared-kernel/ports/src/lib/repository.port.ts
Todas las interfaces de repositorio específicas (ej. libs/core/domain/tenancy/src/lib/ports/tenant.repository.port.ts).
Todas las implementaciones de repositorio en la capa de infraestructura (futuro).
Casos de Uso que interactúan con repositorios (para eliminar casts).
Impacto Esperado y Beneficios:
Beneficio: Elimina casts inseguros, mejora significativamente la seguridad de tipos y la claridad del código.
Impacto: Refactorización estructural importante en los puertos y sus consumidores.
Prioridad: 🟠 Alta
Complejidad Estimada: Media.
Riesgos/Efectos Secundarios: Requiere tocar muchas firmas de interfaces y clases.

---

---

3.2. 🟡 Mejoras de Robustez del Shared Kernel y Dominios Específicos (Prioridad Media)
Estas mejoras se centran en refinar las abstracciones y la lógica dentro del shared-kernel y los dominios para aumentar su robustez, claridad y alineación con las mejores prácticas de DDD.
3.2.1. Refinamiento de correlationId y userId en Metadata (Comandos, Queries, Eventos)
Descripción del Problema: Además de la corrección del bug del correlationId por defecto, la forma en que se maneja y se requiere el userId en ICommandMetadata (y por ende en IDomainEventMetadata y QueryBase.metadata) es opcional (Maybe<UserId>).
Solución Propuesta:
correlationId: Después de corregir el bug, asegurar que los componentes que crean Comandos/Queries (ej. Controladores API, otros Casos de Uso) propaguen el correlationId existente o pasen undefined para que se genere uno nuevo. Considerar un RequestContextService (ver Sección 3.3.2) para acceso implícito.
userId:
Evaluar si userId debe ser obligatorio para ciertos tipos de comandos (ej. todos los que modifican datos) o eventos.
Si es así, introducir interfaces de metadata más específicas como IAuthenticatedCommandMetadata extends ICommandMetadata { readonly userId: UserId; } y que los comandos/eventos correspondientes la usen.
Para queries, userId podría ser necesario para aplicar filtros de autorización a nivel de datos.
Archivos Principales Afectados:
libs/core/domain/shared-kernel/commands-queries/src/lib/command.interface.ts (y query.interface.ts si se crea IQueryMetadata).
libs/core/domain/shared-kernel/events/src/lib/domain-event.interface.ts.
CommandBase.ts, QueryBase.ts, DomainEventBase.ts (para la lógica de correlationId).
Clases de comando y evento concretas (para usar metadata más específica si se crea).
Casos de Uso y Controladores API (para asegurar la provisión de userId cuando sea requerido).
Impacto Esperado y Beneficios:
Beneficio: Trazabilidad más robusta. Auditoría y autorización más fiables si userId se gestiona de forma más estricta.
Impacto: Requiere un análisis de qué operaciones necesitan un userId obligatorio. Modificaciones en varias interfaces y clases.
Prioridad: 🟡 Media (la corrección del bug de correlationId es Alta/Crítica).
Complejidad Estimada: Media.
3.2.2. Pruebas Detalladas de Payloads de Eventos de Dominio
Descripción del Problema: Los tests actuales para entidades (ej. TenantEntity.spec.ts) verifican la instancia del evento emitido, pero no siempre el contenido completo y correcto de su payload.
Solución Propuesta: Expandir las aserciones en los tests de las entidades para verificar rigurosamente que el payload de cada evento de dominio contenga todos los datos esperados y correctos, y que el aggregateId del evento sea el correcto.
Archivos Principales Afectados:
Todos los archivos _.entity.spec.ts que prueben entidades que emiten eventos (ej. libs/core/domain/tenancy/src/lib/entities/tenant.entity.spec.ts).
Impacto Esperado y Beneficios:
Beneficio: Asegura que los eventos (que son contratos) se emitan con toda la información necesaria y correcta, aumentando la fiabilidad de los manejadores de eventos.
Impacto: Expansión de aserciones en los tests. Puede requerir datos de prueba más específicos.
Prioridad: 🟡 Media
Complejidad Estimada: Baja a Media (dependiendo del número de eventos y la complejidad de sus payloads).
3.2.3. Introducción de Value Objects para Conceptos Clave Adicionales
Descripción del Problema: Propiedades como planId en TenantEntity o key y value en TenantConfigurationEntity son actualmente strings. Si estos conceptos tienen reglas de validación, formato o comportamiento propios, usar strings primitivos puede llevar a una lógica de validación dispersa y menor seguridad de tipos.
Solución Propuesta:
Identificar propiedades en entidades que representan conceptos con sus propias invariantes.
Crear Value Objects (VOs) dedicados para ellos (ej. PlanIdVO, TenantConfigKeyVO, TenantConfigValueVO<T> si el valor puede ser tipado).
Refactorizar las entidades para usar estos VOs.
Archivos Principales Afectados:
Archivos de entidad relevantes (ej. tenant.entity.ts, tenant-configuration.entity.ts).
Creación de nuevos archivos _.vo.ts en las librerías de dominio correspondientes.
Casos de Uso y Mappers que interactúan con estas entidades/propiedades.
Impacto Esperado y Beneficios:
Beneficio: Mayor robustez, encapsulación de lógica de validación, semántica de dominio más rica, mejor seguridad de tipos.
Impacto: Requiere diseño y creación de nuevos VOs, y refactorización de las entidades y sus consumidores.
Prioridad: 🟡 Media
Complejidad Estimada: Media por VO.
3.2.4. Refinamiento de la Gestión de TenantConfigurationEntity (Límite de Agregado)
Descripción del Problema: TenantConfigurationEntity actualmente extiende AggregateRoot. Se debe confirmar si esta es la mejor representación o si debería ser una Entity dentro del agregado TenantEntity.
Solución Propuesta:
Analizar las invariantes y el ciclo de vida: ¿Puede una TenantConfiguration existir sin un Tenant? ¿Los cambios en TenantConfiguration deben ser atómicos con cambios en Tenant?
Si es parte del agregado Tenant:
TenantConfigurationEntity hereda de Entity.
TenantEntity gestiona una colección de TenantConfigurationEntity y métodos para manipularlas.
ITenantConfigurationRepository podría desaparecer o su rol cambiaría.
Si se mantiene como AggregateRoot separado (como está ahora): Asegurar que la coordinación entre TenantEntity y TenantConfigurationEntity (si es necesaria) se maneje limpiamente en los Casos de Uso.
Archivos Principales Afectados:
libs/core/domain/tenancy/src/lib/entities/tenant.entity.ts
libs/core/domain/tenancy/src/lib/entities/tenant-configuration.entity.ts
libs/core/domain/tenancy/src/lib/ports/tenant-configuration.repository.port.ts (y su implementación).
Casos de Uso que manejan configuraciones.
Impacto Esperado y Beneficios:
Beneficio: Modelo de dominio más preciso y alineado con los principios de DDD, asegurando la consistencia transaccional correcta.
Impacto: Potencialmente una refactorización significativa del manejo de configuraciones.
Prioridad: 🟡 Media (requiere una decisión de diseño arquitectónico).
Complejidad Estimada: Media a Alta si se refactoriza.
3.2.5. Tipos de Error Específicos para Puertos y Dominios
Descripción del Problema: Los puertos de repositorio y otros servicios actualmente devuelven Result<..., ExceptionBase | Error>. Esto es muy genérico.
Solución Propuesta:
Definir tipos de error más específicos para operaciones de persistencia (ej. EntityNotFoundError, OptimisticLockError, DatabaseUnavailableError) y otros servicios de infraestructura.
Definir jerarquías de errores por dominio (ej. TenancyDomainError como base para TenantAlreadyExistsError).
Actualizar las firmas de los puertos para usar estos errores más específicos en la parte E de Result<T,E>.
Archivos Principales Afectados:
libs/shared/errors/ (para errores de infraestructura genéricos).
libs/core/domain/<contexto>/src/lib/errors/ (para errores de dominio).
Todas las interfaces de puerto (\*.port.ts).
Implementaciones de adaptadores y Casos de Uso (para manejar/lanzar los nuevos tipos de error).
Impacto Esperado y Beneficios:
Beneficio: Contratos de error más precisos, permite un manejo de errores más granular y significativo por parte de los llamadores.
Impacto: Esfuerzo considerable en la definición de errores y refactorización de firmas y manejo de errores.
Prioridad: 🟡 Media
Complejidad Estimada: Media.
3.2.6. Validación de Formato de IsoDateString y otros Primitivos Brandeados
Descripción del Problema: Tipos como IsoDateString son solo marcas de tipo en TypeScript. No hay validación en runtime de que el string subyacente realmente cumpla el formato. Similar para UuidSchema en UuidUtils si no se validara.
Solución Propuesta:
Para IsoDateString: Considerar un IsoDateStringVO que valide el formato en su creación, o asegurar que toda fuente de IsoDateString (ej. new Date().toISOString(), o datos de API validados con IsoDateStringSchema de Zod) produzca el formato correcto.
Para IDs generados por UuidUtils: La librería uuid es confiable. La validación adicional con regex es opcional (paranoia).
Para IDs recibidos del exterior: Deben ser validados contra UuidSchema (o schemas específicos como TenantIdSchema) en la capa de entrada (API).
Archivos Principales Afectados:
libs/shared/types/src/lib/primitive-types.ts (para documentación de la expectativa).
libs/shared/validation-schemas/ (asegurar que los Zod schemas validen formatos).
Potencialmente crear IsoDateStringVO.ts en libs/core/domain/shared-kernel/value-objects/.
Impacto Esperado y Beneficios:
Beneficio: Mayor robustez al asegurar que los datos no solo estén "brandeados" a nivel de tipo, sino que también cumplan con el formato esperado en runtime.
Impacto: Depende del enfoque. Crear VOs para todo puede ser verboso. Confiar en la validación en los bordes (API DTOs) es a menudo un buen equilibrio.
Prioridad: 🟡 Media
Complejidad Estimada: Baja a Media.

---

---

3.3. 🟡 Mejoras de Calidad de Código, Developer Experience (DX) y Configuraciones (Prioridad Media-Baja)
Estas mejoras se centran en refinar el código para mayor claridad, mejorar la experiencia de los desarrolladores y optimizar las configuraciones de herramientas.
3.3.1. Habilitar declarationMap: true en todos los tsconfig.lib.json
Descripción del Problema: Actualmente, los tsconfig.lib.json no tienen declarationMap: true.
Solución Propuesta: Añadir "declarationMap": true a la sección compilerOptions de todos los archivos tsconfig.lib.json en libs/shared/_ y libs/core/_.
Archivos Principales Afectados: Todos los tsconfig.lib.json de las librerías.
Pasos de Implementación Concretos (Ejemplo para una librería):
// en un tsconfig.lib.json
{
"extends": "./tsconfig.json",
"compilerOptions": {
"outDir": "../../../../dist/out-tsc", // o la ruta correcta
"declaration": true,
"declarationMap": true, // <--- AÑADIR ESTO
"types": ["node"] // o [] según corresponda
},
"include": ["src/**/*.ts"],
"exclude": ["jest.config.ts", "src/**/*.spec.ts", "src/**/*.test.ts"]
}

Json
Impacto Esperado y Beneficios:
Beneficio: Mejora significativamente la DX al usar "Go to Definition" o "Peek Definition" en los IDEs, permitiendo saltar del archivo .d.ts de una librería consumida directamente a su código fuente .ts original.
Impacto: Mínimo. Aumenta ligeramente el tamaño de los artefactos de build (se generan archivos .d.ts.map).
Prioridad: 🟡 Media (mejora de DX importante).
Complejidad Estimada: Baja.
3.3.2. Estandarizar moduleResolution: "node" en tsconfig.spec.json
Descripción del Problema: Algunos tsconfig.spec.json usan "moduleResolution": "node10" mientras que otros podrían usar (o deberían usar) "node".
Solución Propuesta: Revisar todos los tsconfig.spec.json y estandarizar a "moduleResolution": "node".
Archivos Principales Afectados: Todos los tsconfig.spec.json.
Impacto Esperado y Beneficios:
Beneficio: Consistencia en la configuración. "node" es la opción más actual para la resolución de módulos al estilo Node.js.
Impacto: Mínimo, improbable que cause problemas funcionales.
Prioridad: 🟢 Baja (mejora de consistencia menor).
Complejidad Estimada: Baja.
3.3.3. Revisar types: ["node"] vs. types: [] en tsconfig.lib.json
Descripción del Problema: Algunas librerías del shared-kernel (ej. value-objects, ports, mappers) que solo definen interfaces o clases base agnósticas podrían no necesitar los tipos globales de Node.js. Actualmente, muchas tienen types: ["node"].
Solución Propuesta: Para cada librería en libs/shared/ y libs/core/domain/shared-kernel/, evaluar si realmente necesita types: ["node"]. Si no hay dependencias directas o indirectas de APIs de Node.js, cambiar a types: [].
Archivos Principales Afectados: Archivos tsconfig.lib.json de las librerías relevantes.
Impacto Esperado y Beneficios:
Beneficio: Mayor pureza y portabilidad teórica de las librerías base, evitando la inclusión accidental de tipos globales de Node.js si no son necesarios.
Impacto: Requiere un análisis cuidadoso. Si se quita y alguna dependencia transitiva lo requería, podrían surgir errores de tipo. Para librerías destinadas a un backend Node.js, types: ["node"] suele ser una opción segura y sin mayores inconvenientes.
Prioridad: 🟢 Baja
Complejidad Estimada: Baja a Media (el análisis puede llevar tiempo).
3.3.4. Uso Consistente de Exportaciones Nombradas en index.ts (Barrel Files)
Descripción del Problema: La mayoría de los index.ts de las librerías usan export \* from './lib/...'.
Solución Propuesta: Considerar cambiar a exportaciones nombradas explícitas para un control más fino de la API pública de cada librería, como se detalló en la Sección 2.11 del "Documento Maestro de Convenciones".
// Ejemplo para un index.ts
export { MyClass } from './lib/my-class.file';
export { type IMyInterface } from './lib/my-interface.file';

TypeScript
Archivos Principales Afectados: Todos los archivos index.ts en libs/_ /src/.
Impacto Esperado y Beneficios:
Beneficio: Mayor claridad sobre la API pública, previene exportaciones accidentales, puede ayudar ligeramente al tree-shaking, hace los cambios en la API pública más evidentes.
Impacto: Aumenta la verbosidad y el mantenimiento manual de los index.ts. Es una decisión de estilo con pros y contras.
Prioridad: 🟢 Baja (mejora de claridad y control, pero export _ es funcional).
Complejidad Estimada: Media (por el número de archivos a modificar).
3.3.5. Resolver Duplicación de Definición de CorrelationId
Descripción del Problema: El tipo CorrelationId está definido tanto en libs/shared/types/src/lib/primitive-types.ts como en libs/shared/types/src/lib/correlation-id.type.ts.
Solución Propuesta:
Elegir una única fuente de verdad para la definición de CorrelationId (probablemente correlation-id.type.ts por ser más específico).
Eliminar la definición duplicada del otro archivo.
Asegurar que el index.ts de libs/shared/types/ exporte la definición canónica una sola vez.
Archivos Principales Afectados:
libs/shared/types/src/lib/primitive-types.ts
libs/shared/types/src/lib/correlation-id.type.ts
libs/shared/types/src/index.ts
Impacto Esperado y Beneficios:
Beneficio: Cumplimiento del principio DRY, evita inconsistencias y confusión.
Impacto: Refactorización menor.
Prioridad: 🟡 Media (para limpieza y evitar problemas futuros).
Complejidad Estimada: Baja.
3.3.6. Resolver Anomalías Menores de Tests E2E (api-main-e2e)
Descripción del Problema (Según Bitácora):
Necesidad de testMatch explícito en apps/api-main-e2e/jest.config.ts porque los tests no eran detectados.
Proceso de serve (levantado por nx e2e) termina con código 1 después de que los tests E2E pasan.
Solución Propuesta:
testMatch: Investigar la configuración de jest.preset.js y cómo Nx maneja los patrones de descubrimiento para proyectos E2E. El objetivo es entender por qué el patrón por defecto no encuentra \*.e2e-spec.ts y si se puede revertir a una configuración sin testMatch explícito, o si la configuración actual es la solución pragmática.
Código de Salida 1: Investigar el globalTeardown.ts de los tests E2E y cómo Nx finaliza el proceso serve. Podría ser un cierre no del todo limpio del servidor NestJS o algún problema en la comunicación entre Jest y el proceso servidor.
Archivos Principales Afectados:
apps/api-main-e2e/jest.config.ts
apps/api-main-e2e/src/support/global-teardown.ts
Posiblemente jest.preset.js o configuraciones de Nx relacionadas con el ejecutor E2E.
Impacto Esperado y Beneficios:
Beneficio: Configuración de tests más limpia y estándar. Mayor fiabilidad del proceso de tests E2E.
Impacto: Esfuerzo de investigación y debugging.
Prioridad: 🟢 Baja (ya que los tests funcionan con el workaround, pero es bueno para la "salud" del sistema de tests).
Complejidad Estimada: Media (la investigación puede ser no trivial).
3.3.7. Refinamiento de Comentarios JSDoc/TSDoc y Documentación .md
Descripción del Problema: Aunque la documentación es buena, siempre hay espacio para mejorar la completitud, claridad y consistencia de los comentarios JSDoc/TSDoc en todo el código y la documentación en archivos .md.
Solución Propuesta:
Revisar sistemáticamente los comentarios de todos los artefactos exportados (.ts) para asegurar que cumplen con las convenciones (descripción, @param, @returns, etc.).
Expandir los README.md de librerías y aplicaciones.
Mantener actualizados los documentos maestros (.DOCUMENTO-TECNICO-PROYECTO.md, .BITACORA.md, etc.).
Archivos Principales Afectados: Potencialmente todos los archivos .ts y .md.
Impacto Esperado y Beneficios:
Beneficio: Mejor comprensión del código, facilidad de mantenimiento, mejor onboarding.
Impacto: Esfuerzo continuo de documentación.
Prioridad: 🟢 Baja (tarea continua).
Complejidad Estimada: Variable, continua.
3.3.8. Implementar Hooks de Git (Husky + lint-staged)
Descripción del Problema: Actualmente no hay hooks de Git para forzar linting/formateo antes de los commits.
Solución Propuesta: Configurar Husky y lint-staged para ejecutar eslint --fix y prettier --write en los archivos "staged" antes de cada commit, como se describe en la Sección 11.4 del "Documento Maestro de Convenciones".
Archivos Principales Afectados: package.json (para scripts y configuración de lint-staged), creación de directorio .husky/.
Impacto Esperado y Beneficios:
Beneficio: Asegura que solo código formateado y sin errores de linting (auto-corregibles) llegue al repositorio. Mejora la calidad de la base de código desde el inicio.
Impacto: Configuración inicial.
Prioridad: 🟡 Media (mejora significativa para la calidad del repositorio).
Complejidad Estimada: Baja a Media.

---

---

3.4. 🟢 Próximos Pasos del Roadmap e Integración de Mejoras en Nuevas Funcionalidades (Prioridad según Roadmap)
Esta sección no trata de mejoras a código existente, sino de cómo las mejoras y convenciones establecidas impactarán y deben ser aplicadas al desarrollo de las próximas funcionalidades definidas en el .ROADMAP.md.
3.4.1. Tarea 0.5.2 (Roadmap): Implementar Tests Unitarios para Casos de Uso Tenancy
Descripción: Completar la implementación de los tests unitarios para CreateTenantUseCase y ActivateTenantUseCase en libs/core/application/tenancy/.
Aplicación de Mejoras/Convenciones:
Seguir los "Patrones de Pruebas" (Sección 8 del Doc. de Convenciones): estructura AAA, mocking de dependencias (repositorios, logger, servicios de aprovisionamiento), verificación de todos los caminos lógicos (éxito, errores de dominio, errores de infraestructura).
Asegurar que el correlationId se propague y se use en logging dentro de los tests.
Una vez completados, actualizar passWithNoTests: true a false en el project.json de @dfs-suite/core-application-tenancy.
Establecer umbrales de cobertura para estos casos de uso.
Archivos Principales Afectados:
Creación de libs/core/application/tenancy/src/lib/use-cases/create-tenant/create-tenant.use-case.spec.ts
Creación de libs/core/application/tenancy/src/lib/use-cases/activate-tenant/activate-tenant.use-case.spec.ts
libs/core/application/tenancy/project.json
Prioridad: 🟠 Alta (según el flujo del roadmap, es el siguiente paso técnico inmediato).
Complejidad Estimada: Media.
3.4.2. Hitos 0.6, 0.7, 0.8 (Roadmap): Implementación de Capa de Infraestructura y Ensamblaje Inicial para Tenancy
Descripción:
Hito 0.6: Crear librerías de infraestructura para persistencia de Tenancy (Prisma), aprovisionamiento de DB, y emisor de eventos.
Hito 0.7: Implementar y configurar el logger.
Hito 0.8: Ensamblar todo en api-main con un TenancyModule y endpoints básicos.
Aplicación de Mejoras/Convenciones:
Infraestructura (layer:infrastructure):
Las implementaciones de ITenantRepository, ITenantConfigurationRepository, IDatabaseProvisioningServicePort, ILoggerPort, IDomainEventEmitter deben residir aquí.
Utilizar los Symbols de los puertos para la provisión en módulos NestJS.
Implementar Mappers (IMapper) para convertir entre entidades de dominio y modelos de Prisma.
Manejo de Transacciones (Mejora 3.2.2 y 3.1.4): Los adaptadores de repositorio deben implementar el método transaction del IRepositoryPort. Considerar cómo se orquestarán las transacciones que abarcan el aprovisionamiento de DB y la persistencia del tenant.
Publicación de Eventos (Mejora 3.2.3): El adaptador de ITenantRepository (en sus métodos insert/update/save) debe obtener los eventos del agregado (getAndClearDomainEvents()) y publicarlos usando IDomainEventEmitter después de una transacción de DB exitosa.
Seguridad (Encriptación): Si DbConnectionConfigVO contiene datos sensibles, el adaptador de persistencia para TenantEntity (o TenantConfigurationEntity) debe encargarse de encriptar/desencriptar estos datos al interactuar con la DB de plataforma.
API (api-main - scope:app):
Implementar TenancyModule en NestJS, proveyendo los Casos de Uso y sus dependencias (implementaciones de puertos).
Crear Controladores/Resolvers para los endpoints.
Utilizar DTOs de entrada validados con ZodValidationPipe (usando schemas de shared-validation-schemas).
Utilizar IApiResponse para respuestas REST.
Aplicar AllExceptionsFilter y TransformResponseInterceptor.
Implementar CorrelationIdMiddleware y TenantContextMiddleware.
Usar ILoggerPort con correlationId y contexto.
Archivos Principales Afectados:
Creación de nuevas librerías en libs/infrastructure/.
Modificaciones extensas en apps/api-main/.
Prioridad: 🟠 Alta (siguientes en el roadmap).
Complejidad Estimada: Alta (implica mucha implementación nueva y configuración de DI).
3.4.3. Fase 1 y Posteriores (Roadmap): Implementación de MVP Funcional (WhatsApp, Leads, PWAs)
Descripción: Desarrollo de los dominios WhatsApp, Anti-Ban, Leads-Flow, sus capas de aplicación e infraestructura, y las PWAs.
Aplicación de Mejoras/Convenciones:
TODAS las convenciones de nomenclatura, estructura de directorios, patrones DDD, uso de TypeScript, manejo de errores, patrones de pruebas y documentación detalladas en el "Documento Maestro de Convenciones y Estándares" DEBEN aplicarse a estos nuevos módulos y aplicaciones desde su concepción.
Las lecciones aprendidas y las mejoras implementadas en la Fase 0 (ej. correlationId corregido, IRepositoryPort con ID tipado, VOs para conceptos clave) deben ser la base para el nuevo código.
Revisar depConstraints: A medida que se añaden nuevas librerías de dominio, aplicación e infraestructura, actualizar las reglas en eslint.config.mjs (raíz) para mantener la integridad arquitectónica.
PWAs: Definir y seguir convenciones específicas para el frontend (Next.js, React, Tailwind, Shadcn/UI, gestión de estado con Zustand/TanStack Query), posiblemente en un apéndice o documento separado si es muy extenso.
Prioridad: Según roadmap.
Complejidad Estimada: Muy Alta (cuerpo principal del proyecto). 4. Artefactos Necesarios/Modificados (Resumen de la Implementación del Plan)
Modificaciones a Clases Base Existentes:
CommandBase, QueryBase, DomainEventBase: Corrección de correlationId.
ValueObjectBase: Resolución de deuda técnica de unpack().
IRepositoryPort: Tipado de ID genérico.
Nuevos Archivos de Test:
_.spec.ts para todas las clases base del shared-kernel.
_.spec.ts para los schemas Zod.
\*.spec.ts para los Casos de Uso de Tenancy.
Actualización de Archivos de Configuración:
project.json: Cambiar passWithNoTests: true a false.
tsconfig.lib.json: Añadir declarationMap: true, revisar types.
tsconfig.spec.json: Estandarizar moduleResolution.
Nuevas Librerías de Infraestructura: Para persistencia, logging, aprovisionamiento, etc.
Desarrollo en api-main: Módulos, controladores, pipes, filtros, interceptors.
Nuevas Librerías de Dominio y Aplicación: Para WhatsApp, Leads, etc.
Nuevas Aplicaciones (PWAs). 5. Plan de Pruebas y Verificación (Post-Mejoras)
Tests Unitarios: Deben cubrir toda la lógica nueva y refactorizada, especialmente en las clases base y los casos de uso. Los umbrales de cobertura deben empezar a ser forzados.
Linting y Formateo: pnpm nx run-many --target=lint --all y pnpm prettier --check . deben pasar sin errores.
Builds: Todas las aplicaciones y librerías construibles deben compilarse sin errores.
Tests E2E: Los tests E2E existentes para api-main deben seguir pasando. Se añadirán nuevos tests E2E para las nuevas funcionalidades.
Revisión de depConstraints: Ejecutar pnpm nx dep-graph y revisar visualmente que las dependencias entre las nuevas y antiguas librerías sigan la arquitectura hexagonal. Validar con el linter.
Revisión de Código: Todos los cambios deben pasar por Pull Requests y ser revisados contra el "Documento Maestro de Convenciones y Estándares".
Verificación Manual: Para flujos críticos, realizar pruebas manuales en un entorno de staging.
Este Plan Maestro de Mejoras Transversales proporciona una hoja de ruta clara para abordar las debilidades identificadas y asegurar que el desarrollo futuro de DFS-Invest-Suite se realice sobre una base aún más sólida y siguiendo estándares de alta calidad. La implementación de estas mejoras, especialmente las críticas y de alta prioridad, debe ser el foco antes de avanzar significativamente en nuevas funcionalidades complejas.

---

---

Listado de Mejoras por Artefacto/Grupo y Archivos Relacionados
I. Shared Kernel - Clases Base de Mensajería (Comandos, Queries, Eventos)
Artefacto: CommandBase.ts
Ruta: libs/core/domain/shared-kernel/commands-queries/src/lib/command.base.ts
Mejoras Principales:
BUG CRÍTICO: Corregir lógica de correlationId por defecto para que genere un UUID único si no se provee (no usar placeholder fijo).
Tipar commandId como Branded Type CommandInstanceId.
Considerar validación básica de metadata en el constructor.
Revisar/eliminar tipo CommandProps<T> si no se usa.
Archivos Relacionados Afectados:
QueryBase.ts, DomainEventBase.ts (para consistencia en correlationId).
ICommand.ts (si commandId cambia de tipo).
UuidUtils.ts (si se añade generateCommandInstanceId()).
Tests unitarios para CommandBase (a crear).
Artefacto: QueryBase.ts
Ruta: libs/core/domain/shared-kernel/commands-queries/src/lib/query.base.ts
Mejoras Principales:
BUG CRÍTICO: Corregir lógica de correlationId por defecto (similar a CommandBase).
Considerar interfaz IQueryMetadata dedicada en lugar de reutilizar ICommandMetadata.
Considerar añadir queryId (Branded Type).
Archivos Relacionados Afectados:
CommandBase.ts, DomainEventBase.ts (para consistencia en correlationId).
IQuery.ts (si se añade queryId o cambia IQueryMetadata).
Tests unitarios para QueryBase (a crear).
Artefacto: DomainEventBase.ts
Ruta: libs/core/domain/shared-kernel/events/src/lib/domain-event.base.ts
Mejoras Principales:
BUG CRÍTICO: Corregir lógica de correlationId por defecto (similar a CommandBase).
Considerar validación de payload con schema Zod en constructor (opcional).
Considerar inmutabilidad profunda del payload.
Archivos Relacionados Afectados:
CommandBase.ts, QueryBase.ts (para consistencia en correlationId).
IDomainEvent.ts (si se añade eventVersion a metadata).
Tests unitarios para DomainEventBase (a crear).
II. Shared Kernel - Clases Base de Dominio (Entidades, VOs)
Artefacto: EntityBase.ts (Nombre inferido, archivo es entity.base.ts)
Ruta: libs/core/domain/shared-kernel/entities/src/lib/entity.base.ts
Mejoras Principales:
Validar formato UUID para id en validateId().
Reconsiderar/eliminar validación MAX*PROPS en validateProps().
Archivos Relacionados Afectados:
AggregateRootBase.ts (hereda de EntityBase).
Todas las entidades concretas.
Tests unitarios para EntityBase (a crear).
Artefacto: AggregateRootBase.ts (Nombre inferido, archivo es aggregate-root.base.ts)
Ruta: libs/core/domain/shared-kernel/entities/src/lib/aggregate-root.base.ts
Mejoras Principales:
Asegurar que validate() se llame consistentemente antes de addEvent(). (Ya está, mantener).
Archivos Relacionados Afectados:
Todas las entidades Aggregate Root concretas.
Tests unitarios para AggregateRootBase (a crear).
Artefacto: ValueObjectBase.ts (Nombre inferido, archivo es value-object.base.ts)
Ruta: libs/core/domain/shared-kernel/value-objects/src/lib/value-object.base.ts
Mejoras Principales:
DEUDA TÉCNICA: Resolver desactivación de ESLint @typescript-eslint/no-unsafe-return en unpack().
Considerar comparación profunda en equals() si los VOs contienen objetos anidados/Fechas.
Archivos Relacionados Afectados:
Todos los Value Objects concretos.
Tests unitarios para ValueObjectBase (a crear).
III. Shared Kernel - Puertos (Interfaces de Abstracción)
Artefacto: IRepositoryPort.ts (Nombre inferido, archivo es repository.port.ts)
Ruta: libs/core/domain/shared-kernel/ports/src/lib/repository.port.ts
Mejoras Principales:
Hacer genérico para el tipo de ID del Agregado (IRepositoryPort<Agg, IDType extends AggregateId>).
Refinar firma de transaction() para pasar repositorio transaccional.
Considerar tipos de error más específicos que ExceptionBase | Error.
Archivos Relacionados Afectados:
Todas las interfaces de repositorio específicas (ej. ITenantRepository).
Todas las implementaciones de repositorio (futuro).
Casos de Uso que usan estos repositorios.
Artefacto: ILoggerPort.ts (Nombre inferido, archivo es logger.port.ts)
Ruta: libs/core/domain/shared-kernel/ports/src/lib/logger.port.ts
Mejoras Principales:
Considerar que todos los métodos devuelvan Promise<void> para consistencia con logging asíncrono.
Archivos Relacionados Afectados:
Implementación del logger (futuro).
Todos los consumidores del logger.
IV. Librerías shared/* (Tipos, Utilidades, Validación)
Artefacto: primitive-types.ts
Ruta: libs/shared/types/src/lib/primitive-types.ts
Mejoras Principales:
Resolver duplicación de CorrelationId (elegir fuente canónica con correlation-id.type.ts).
Considerar IsoDateStringVO para validación en runtime.
Archivos Relacionados Afectados:
correlation-id.type.ts, index.ts de shared-types.
Consumidores de IsoDateString si se cambia a VO.
Artefacto: common.schemas.ts (y otros archivos de schemas Zod)
Ruta: libs/shared/validation-schemas/src/lib/common.schemas.ts
Mejoras Principales:
Añadir tests unitarios para los schemas Zod.
Refinar EmailSchema si es necesario (regex más robusta o advertencia más fuerte).
Considerar exportar tipos inferidos z.infer<>.
Archivos Relacionados Afectados:
project.json de shared-validation-schemas (para passWithNoTests).
Consumidores de los schemas (ej. Pipes en api-main).
V. Dominio Específico Tenancy (libs/core/domain/tenancy/ y libs/core/application/tenancy/)
Artefacto: TenantEntity.ts
Ruta: libs/core/domain/tenancy/src/lib/entities/tenant.entity.ts
Mejoras Principales:
Considerar VOs para planId.
Refinar manejo de TenantConfigurationEntity (¿parte del agregado o AR separado?).
Asegurar que payloads de eventos emitidos sean completos.
Archivos Relacionados Afectados:
TenantConfigurationEntity.ts, Casos de Uso, ITenantRepository.
Artefacto: CreateTenantUseCase.ts y ActivateTenantUseCase.ts
Ruta: libs/core/application/tenancy/src/lib/use-cases/...
Mejoras Principales:
Implementar tests unitarios (Tarea 0.5.2 del Roadmap).
Resolver casts de ID (depende de mejora en IRepositoryPort).
Manejo de ownerEmail vs ownerUserId (integrar con servicio de usuarios).
Implementar transaccionalidad/sagas para CreateTenantUseCase.
Resolver desactivaciones de ESLint para String(errorCaught).
Archivos Relacionados Afectados:
project.json de core-application-tenancy.
ITenantRepository, IDatabaseProvisioningServicePort.
(Futuro) IUserProvisioningServicePort o IUserRepositoryPort.
VI. Configuraciones Transversales y Herramientas
Artefacto: project.json (de todas las librerías sin tests)
Mejora Principal: Cambiar passWithNoTests: true a false después de añadir tests.
Archivos Afectados: project.json de core-domain-shared-kernel-\_ (entities, value-objects, events, commands-queries), shared-validation-schemas.
Artefacto: tsconfig.lib.json (de todas las librerías)
Mejora Principal: Habilitar "declarationMap": true.
Revisar types: ["node"] vs types: [] para librerías puras.
Archivos Afectados: Todos los tsconfig.lib.json.
Artefacto: tsconfig.spec.json (de todas las librerías con tests)
Mejora Principal: Estandarizar "moduleResolution": "node".
Archivos Afectados: Todos los tsconfig.spec.json.
Artefacto: eslint.config.mjs (raíz)
Mejora Principal: Refinar y expandir depConstraints a medida que se añaden nuevas librerías y tags. Validar que los tags actuales sean usados correctamente.
Archivos Afectados: eslint.config.mjs (raíz), project.json de todas las librerías (para asegurar tags correctos).
Herramientas (Setup): Hooks de Git (husky, lint-staged)
Mejora Principal: Implementar para formateo y linting pre-commit.
Archivos Afectados: package.json, creación de configs de husky y lint-staged.
Este listado es una guía para priorizar las mejoras identificadas, enfocándose en la corrección de bugs, robustecimiento de la base, y luego en la mejora continua de la calidad y DX.

---

---

Resumen Consolidado de Mejoras por Artefacto
Librería: libs/core/domain/shared-kernel/commands-queries/
Ruta: libs/core/domain/shared-kernel/commands-queries/src/lib/command.base.ts
Corregir bug de correlationId por defecto (generar UUID único).
Tipar commandId como Branded Type CommandInstanceId.
Validar metadata básica en constructor.
Revisar/eliminar tipo CommandProps<T>.
Añadir tests unitarios.
Ruta: libs/core/domain/shared-kernel/commands-queries/src/lib/query.base.ts
Corregir bug de correlationId por defecto.
Considerar IQueryMetadata dedicada.
Considerar queryId (Branded Type).
Añadir tests unitarios.
Ruta: libs/core/domain/shared-kernel/commands-queries/src/lib/paginated-query.base.ts
Añadir validación básica de parámetros de paginación.
Alinear tipo de params.sortBy con IPaginatedQueryParams genérico.
Considerar soporte para múltiples campos de ordenación.
Añadir tests unitarios.
Ruta: libs/core/domain/shared-kernel/commands-queries/src/lib/command.interface.ts
Tipar commandId como Branded Type CommandInstanceId.
Tipar timestamp en ICommandMetadata como IsoDateString.
Considerar IAuthenticatedCommandMetadata para userId obligatorio.
Ruta: libs/core/domain/shared-kernel/commands-queries/src/lib/query.interface.ts
Considerar IQueryMetadata dedicada.
Considerar queryName o queryType opcional.
Considerar queryId (Branded Type).
Ruta: libs/core/domain/shared-kernel/commands-queries/src/lib/command-handler.interface.ts
Considerar tipado de error más específico en Result.
Considerar retorno consistente de Promise<void> (si aplica a todas las implementaciones).
Ruta: libs/core/domain/shared-kernel/commands-queries/src/lib/query-handler.interface.ts
Considerar tipado de error más específico en Result.
Ruta: libs/core/domain/shared-kernel/commands-queries/src/index.ts
Usar exportaciones nombradas explícitas.
Añadir documentación de módulo.
Librería: libs/core/domain/shared-kernel/entities/
Ruta: libs/core/domain/shared-kernel/entities/src/lib/entity.base.ts
Validar formato UUID para \_id en validateId().
Reconsiderar/eliminar validación MAX*PROPS en validateProps().
Considerar inmutabilidad profunda en getProps().
Añadir tests unitarios.
Ruta: libs/core/domain/shared-kernel/entities/src/lib/aggregate-root.base.ts
Asegurar que validate() se llame consistentemente antes de addEvent() (ya se hace).
Añadir tests unitarios (verificación de manejo de eventos, llamada a validate()).
Ruta: libs/core/domain/shared-kernel/entities/src/index.ts
Usar exportaciones nombradas explícitas (especialmente para CreateEntityProps, BaseEntityProps).
Añadir documentación de módulo.
Librería: libs/core/domain/shared-kernel/events/
Ruta: libs/core/domain/shared-kernel/events/src/lib/domain-event.base.ts
Corregir bug de correlationId por defecto.
Considerar validación de payload con schema Zod en constructor.
Considerar inmutabilidad profunda del payload.
Añadir tests unitarios.
Ruta: libs/core/domain/shared-kernel/events/src/lib/domain-event.interface.ts
Considerar tipado de eventName con literales/enums (opcional).
Tipar id como DomainEventInstanceId (Branded Type).
Considerar añadir eventVersion a IDomainEventMetadata.
Ruta: libs/core/domain/shared-kernel/events/src/lib/domain-event-emitter.interface.ts
Considerar retorno consistente de Promise<void> para publish y publishAll.
Clarificar contrato de manejo de errores de handlers.
Ruta: libs/core/domain/shared-kernel/events/src/lib/domain-event-handler.interface.ts
Considerar retorno consistente de Promise<void> para handle.
Considerar uso de constructores de evento en listenTo() en lugar de string.
Ruta: libs/core/domain/shared-kernel/events/src/index.ts
Usar exportaciones nombradas explícitas.
Añadir documentación de módulo.
Librería: libs/core/domain/shared-kernel/mappers/
Ruta: libs/core/domain/shared-kernel/mappers/src/lib/mapper.interface.ts
Considerar métodos helper para mapeo de colecciones.
Considerar devolución de Result<..., MappingError> para manejo explícito de errores de mapeo.
Refinar tipado de ResponseDto (ej. unknown por defecto en lugar de any).
Ruta: libs/core/domain/shared-kernel/mappers/src/index.ts
Usar exportaciones nombradas explícitas.
Añadir documentación de módulo.
Librería: libs/core/domain/shared-kernel/ports/
Ruta: libs/core/domain/shared-kernel/ports/src/lib/repository.port.ts
Hacer genérico para el tipo de ID del Agregado (IRepositoryPort<Agg, IDType>).
Refinar firma de transaction() para pasar repositorio transaccional.
Considerar tipos de error de repositorio más específicos.
Considerar soporte para Criterios de Búsqueda/Especificaciones.
Ruta: libs/core/domain/shared-kernel/ports/src/lib/logger.port.ts
Considerar que todos los métodos devuelvan Promise<void>.
Mejorar integración con ExceptionBase para metadata en método error().
Ruta: libs/core/domain/shared-kernel/ports/src/index.ts
Usar exportaciones nombradas explícitas.
Añadir documentación de módulo.
Librería: libs/core/domain/shared-kernel/value-objects/
Ruta: libs/core/domain/shared-kernel/value-objects/src/lib/value-object.base.ts
DEUDA TÉCNICA: Resolver desactivación ESLint @typescript-eslint/no-unsafe-return en unpack().
Mejorar equals() para objetos anidados/Fechas (comparación profunda).
Añadir tests unitarios.
Ruta: libs/core/domain/shared-kernel/value-objects/src/index.ts
Usar exportaciones nombradas explícitas (para ValueObject, Primitives, IDomainPrimitive).
Añadir documentación de módulo.
Librería: libs/shared/constants/
Ruta: libs/shared/constants/src/lib/pagination.constants.ts
Considerar configurabilidad por entorno para límites/defaults.
Ruta: libs/shared/constants/src/lib/regex.constants.ts
Considerar regex de email más robusta o reforzar advertencias.
Documentar fuentes de regex y añadir tests unitarios (indirectamente a través de schemas Zod).
Ruta: libs/shared/constants/src/index.ts
Usar exportaciones nombradas explícitas.
Añadir documentación de módulo.
Librería: libs/shared/errors/
Ruta: libs/shared/errors/src/lib/exception.base.ts
Mejorar manejo de correlationId por defecto (no placeholder, obtener de contexto si es posible).
Permitir metadata tipada con genéricos.
Serialización de cause más detallada (recursiva si es ExceptionBase).
Considerar propiedad getSuggestedHttpStatus().
Ruta: libs/shared/errors/src/lib/exception.codes.ts
Considerar estructura anidada para códigos si la lista crece.
Añadir JSDoc específico para cada código.
Ruta: libs/shared/errors/src/lib/generic.exceptions.ts
Considerar jerarquía adicional para excepciones de argumento.
Considerar metadata estructurada para errores de argumento (nombre del argumento).
Ruta: libs/shared/errors/src/index.ts
Usar exportaciones nombradas explícitas.
Añadir documentación de módulo.
Librería: libs/shared/result/
Ruta: libs/shared/result/src/lib/result.type.ts
Considerar métodos de conveniencia adicionales (match, tap, tapErr).
Considerar ResultAsync para operaciones asíncronas encadenadas.
Ruta: libs/shared/result/src/lib/result.utils.ts
Implementar métodos de conveniencia si se añaden a la interfaz.
Optimizar/robustecer JSON.stringify en mensajes de error de unwrap.
Añadir tests unitarios.
Ruta: libs/shared/result/src/index.ts
Usar exportaciones nombradas explícitas.
Añadir documentación de módulo.
Librería: libs/shared/types/
Ruta: libs/shared/types/src/lib/api-response.interface.ts
Tipado más fuerte para error.details.
Incluir path opcional en el objeto error.
Ruta: libs/shared/types/src/lib/brand.type.ts
Considerar funciones helper para brand/unbrand (opcional).
Ruta: libs/shared/types/src/lib/correlation-id.type.ts
Resolver duplicación con primitive-types.ts (elegir una fuente canónica).
Ruta: libs/shared/types/src/lib/maybe.type.ts
Considerar distinción Optional<T> vs Nullable<T> si es semánticamente necesario.
Ruta: libs/shared/types/src/lib/paginated.interface.ts
Tipado estricto para sortBy en IPaginatedQueryParams (con genéricos).
Considerar soporte para paginación basada en cursor.
Ruta: libs/shared/types/src/lib/primitive-types.ts
Resolver duplicación de CorrelationId.
Considerar IsoDateStringVO para validación en runtime.
Ruta: libs/shared/types/src/index.ts
Resolver exportación de CorrelationId (una vez resuelta duplicación).
Usar exportaciones nombradas explícitas.
Añadir documentación de módulo.
Librería: libs/shared/utils/
Ruta: libs/shared/utils/src/lib/guard.ts
Considerar métodos de guarda que lancen excepciones directamente.
Añadir más type guards específicos (ej. isString, isNumber).
Clarificar/documentar comportamiento de isEmpty para objetos y en lengthIsBetween.
Añadir tests unitarios.
Ruta: libs/shared/utils/src/lib/uuid.utils.ts
Considerar inyección de dependencia para uuidv4 (para testabilidad extrema) o mockeo estático.
Añadir tests unitarios (verificando el "branding").
Ruta: libs/shared/utils/src/index.ts
Usar exportaciones nombradas explícitas.
Añadir documentación de módulo.
Librería: libs/shared/validation-schemas/
Ruta: libs/shared/validation-schemas/src/lib/common.schemas.ts
Refinar EmailSchema (regex más robusta o advertencia).
Considerar i18n para mensajes de error de Zod.
Añadir más schemas comunes.
Añadir tests unitarios.
Ruta: libs/shared/validation-schemas/src/lib/pagination.schemas.ts
Validación de sortBy contra campos permitidos (con genéricos).
Añadir tests unitarios.
Ruta: libs/shared/validation-schemas/src/index.ts
Usar exportaciones nombradas explícitas.
Considerar exportar tipos inferidos de Zod.
Añadir documentación de módulo.
Librería: libs/core/domain/tenancy/
Ruta: libs/core/domain/tenancy/src/lib/entities/tenant.entity.ts
Usar VOs para planId.
Decidir y refinar manejo de TenantConfigurationEntity (agregado o entidad hija).
Asegurar que payloads de eventos emitidos sean completos y correctos.
(Tests ya implementados, pero revisar tras refactorizaciones).
Ruta: libs/core/domain/tenancy/src/lib/entities/tenant-configuration.entity.ts
Considerar emitir eventos de dominio propios.
Considerar TValue genérico para value.
Decidir si es AggregateRoot o Entity hija de TenantEntity.
Ruta: Archivos de Eventos (*.event.ts) en libs/core/domain/tenancy/src/lib/events/
Enriquecer payloads (ej. TenantSuspendedEvent con razón).
Resolver problemas de firma de índice en payloads si es posible con mejor tipado en DomainEventBase.
Ruta: Archivos de Errores (_.error.ts) en libs/core/domain/tenancy/src/lib/errors/
Añadir contexto (fromStatus, toStatus, conflictingField) a la metadata de los errores.
Considerar jerarquía TenancyDomainError.
Ruta: Archivos de Puertos (_.port.ts) en libs/core/domain/tenancy/src/lib/ports/
Actualizar para usar IRepositoryPort<Agg, IDType> si se implementa esa mejora.
Añadir paginación/búsqueda por criterios.
Librería: libs/core/application/tenancy/
Ruta: libs/core/application/tenancy/src/lib/use-cases/create-tenant/create-tenant.use-case.ts
Implementar tests unitarios.
Resolver casts de ID (depende de IRepositoryPort).
Integrar UserProvisioningServicePort para ownerEmail -> UserId.
Implementar transaccionalidad/Sagas.
Validar planId.
Resolver desactivaciones ESLint para String(errorCaught).
Ruta: libs/core/application/tenancy/src/lib/use-cases/activate-tenant/activate-tenant.use-case.ts
Implementar tests unitarios (ya generé esqueleto).
Resolver casts de ID.
Considerar manejo de transacciones y publicación de eventos.
Añadir lógica de autorización.
Resolver desactivaciones ESLint para String(errorCaught).
Ruta: libs/core/application/tenancy/src/lib/dtos/tenant-details.dto.ts
Usar TenantStatusEnum estrictamente para status.
Añadir isDatabaseConfigured: boolean.
VII. Configuraciones Transversales (project.json, tsconfig.\_.json, eslint.config.mjs raíz)

- Actualizar passWithNoTests: true a false en project.json tras añadir tests.
- Habilitar declarationMap: true en todos los tsconfig.lib.json.
- Estandarizar moduleResolution: "node" en tsconfig.spec.json.
- Refinar y expandir depConstraints en eslint.config.mjs (raíz).
- Implementar Hooks de Git (Husky + lint-staged).

---

---
