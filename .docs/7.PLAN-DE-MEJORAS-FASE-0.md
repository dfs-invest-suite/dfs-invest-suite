https://aistudio.google.com/app/prompts/1EuZ5p9F3Ew1PkadZR1UljZosc09Y2sl1 iamdfsinvestimentos.dev7

El Plan Maestro de Mejoras Transversales para DFS-Invest-Suite incluir谩:
Resumen Ejecutivo:
Breve descripci贸n del estado actual del proyecto (basado en el snapshot y la Fase 0 completada).
Principales 谩reas de mejora identificadas.
Beneficios esperados de implementar el plan.
Visi贸n General Arquitect贸nica Actual y Propuesta:
Reiteraci贸n de la arquitectura hexagonal y DDD actual.
C贸mo las mejoras propuestas refinar谩n y fortalecer谩n esta arquitectura.
Plan Detallado de Implementaci贸n de Mejoras (Priorizado):
Esta ser谩 la secci贸n principal.
Organizar茅 las mejoras por categor铆a o impacto (ej. Correcciones Cr铆ticas, Mejoras de Robustez del Shared Kernel, Mejoras de Calidad de C贸digo y DX, Mejoras de Testing, etc.).
Para cada mejora o grupo de mejoras relacionadas:
Descripci贸n del Problema/rea de Mejora: Qu茅 se identific贸.
Soluci贸n Propuesta: Qu茅 se debe hacer. Incluir茅 referencias a las convenciones del "Documento Maestro de Convenciones" cuando sea aplicable.
Archivos Principales Afectados: Listado de las librer铆as o archivos clave que se modificar铆an.
Pasos de Implementaci贸n Concretos (Ejemplos):
Proporcionar茅 un ejemplo de c贸mo se ver铆a la correcci贸n o mejora en uno de los archivos afectados. Por ejemplo, para el bug del correlationId, mostrar茅 la correcci贸n en CommandBase.ts.
Impacto Esperado y Beneficios: Por qu茅 es importante esta mejora.
Prioridad: ( Cr铆tico,  Alta,  Media,  Baja)
Complejidad Estimada: (Baja, Media, Alta)
Posibles Riesgos o Efectos Secundarios: A considerar durante la implementaci贸n.
Artefactos Necesarios/Modificados:
Resumen de los tipos de artefactos que se crear谩n o modificar谩n (ej. nuevos tests unitarios, refactorizaci贸n de clases base, actualizaci贸n de project.json).
Plan de Pruebas y Verificaci贸n:
Estrategia general para validar que las mejoras no rompan la funcionalidad existente.
C贸mo se verificar铆a el cumplimiento de las nuevas convenciones (ej. ejecuci贸n de linters, revisi贸n de cobertura).
Modo de Trabajo para este Documento:
No analizar茅 nuevos archivos en este momento. Me basar茅 en:
El snapshot 2025-05-12-20-03-02_dfs-invest-suite-snapshot.txt.
El .DOCUMENTO-TECNICO-PROYECTO.md.
El .BITACORA.md.
El .ROADMAP.md.
El .DEUDA-TECNICA.md.
El "Documento Maestro de Convenciones y Est谩ndares" que acabamos de desarrollar.
Todas nuestras discusiones y an谩lisis previos.
Comenzar茅 a estructurar este "Plan Maestro de Mejoras Transversales". Dado su alcance, tambi茅n lo presentar茅 en secciones.
PLAN MAESTRO DE MEJORAS TRANSVERSALES (DFS-Invest-Suite v0.5.1)

1. Resumen Ejecutivo
   El proyecto DFS-Invest-Suite se encuentra actualmente al final de la Fase 0 de su roadmap, con una base arquitect贸nica s贸lida establecida. Se ha implementado un monorepo Nx con PNPM, configurado con ESLint, Prettier y Jest. Las librer铆as fundamentales (shared y core/domain/shared-kernel) est谩n definidas, y la l贸gica de dominio y aplicaci贸n inicial para el bounded context de Tenancy est谩 mayormente implementada (a falta de tests para los Casos de Uso).
   Este Plan Maestro de Mejoras Transversales identifica 谩reas clave donde el proyecto puede ser fortalecido para asegurar mayor robustez, mantenibilidad, calidad de c贸digo y alineaci贸n con las mejores pr谩cticas. Las mejoras se centran en:
   Correcci贸n de Bugs Cr铆ticos: Principalmente la l贸gica de generaci贸n de correlationId.
   Robustecimiento del Shared Kernel: A帽adiendo tests unitarios exhaustivos a las clases base y resolviendo deudas t茅cnicas.
   Mejora de la Developer Experience (DX): Optimizando configuraciones de TypeScript y herramientas.
   Refinamiento de la Estrategia de Testing: Asegurando que passWithNoTests se gestione adecuadamente y se establezcan umbrales de cobertura.
   Consistencia y Adherencia a Convenciones: Reforzando las convenciones definidas.
   La implementaci贸n de este plan resultar谩 en una base de c贸digo m谩s confiable, m谩s f谩cil de mantener y evolucionar, y que sirva como un ejemplo s贸lido para el desarrollo de futuros m贸dulos y funcionalidades.
2. Visi贸n General Arquitect贸nica Actual y Propuesta
   Actual: La arquitectura hexagonal con DDD t谩ctico est谩 bien delineada con capas shared, domain (shared-kernel y espec铆fico), application, y proyecciones para infrastructure y apps. Los tags de Nx y las depConstraints iniciales en ESLint soportan esta estructura.
   Propuesta (Refinamiento): Las mejoras propuestas no alteran fundamentalmente la arquitectura hexagonal existente, sino que la refuerzan y la hacen m谩s robusta. Esto se logra mediante:
   Mayor Seguridad de Tipos: Refinando el uso de Branded Types, tipos de error, y la gesti贸n de IDs.
   Mejor Desacoplamiento: Asegurando que los puertos y adaptadores se implementen correctamente y que la l贸gica de negocio permanezca pura en el dominio.
   Consistencia Mejorada: Aplicando las convenciones de manera uniforme.
   Calidad Validada: A trav茅s de una estrategia de testing m谩s completa, especialmente para los componentes base.
   No se requiere un nuevo diagrama conceptual en este punto, ya que la arquitectura base se mantiene. Las mejoras son a nivel de implementaci贸n y calidad de los componentes existentes y futuros.

---

---

隆Perfecto! Continuamos con la Secci贸n 3: Plan Detallado de Implementaci贸n de Mejoras (Priorizado) del Plan Maestro de Mejoras Transversales.
(Continuaci贸n del Plan Maestro de Mejoras Transversales) 3. Plan Detallado de Implementaci贸n de Mejoras (Priorizado)
A continuaci贸n, se detallan las mejoras agrupadas por prioridad y 谩rea de impacto.
3.1.  Correcciones Cr铆ticas y de Alta Prioridad
Estas mejoras abordan bugs funcionales o debilidades significativas que deben corregirse para asegurar la correcta operatividad y trazabilidad del sistema.
3.1.1. Correcci贸n de L贸gica de correlationId por Defecto
Descripci贸n del Problema: Las clases base CommandBase, QueryBase y DomainEventBase utilizan actualmente un placeholder fijo (ej. 'CONTEXT_CORR_ID_CMD_PLACEHOLDER') como correlationId por defecto si no se proporciona uno expl铆citamente. Esto es un bug funcional grave ya que m煤ltiples instancias compartir铆an el mismo ID de correlaci贸n, anulando el prop贸sito de la trazabilidad 煤nica por flujo.
Soluci贸n Propuesta: Modificar los constructores de CommandBase.ts, QueryBase.ts y DomainEventBase.ts para que, si props.metadata.correlationId no se provee, se genere un nuevo y 煤nico CorrelationId utilizando UuidUtils.generateCorrelationId().
Archivos Principales Afectados:
libs/core/domain/shared-kernel/commands-queries/src/lib/command.base.ts
libs/core/domain/shared-kernel/commands-queries/src/lib/query.base.ts
libs/core/domain/shared-kernel/events/src/lib/domain-event.base.ts
Pasos de Implementaci贸n Concretos (Ejemplo para CommandBase.ts):
// libs/core/domain/shared-kernel/commands-queries/src/lib/command.base.ts
// ... imports ...
export abstract class CommandBase implements ICommand {
// ... otras propiedades ...
constructor(props?: Partial<ICommandMetadata>) {
this.commandId = UuidUtils.generate(); // Asumimos que CommandInstanceId es un UUID string

    // L贸gica CORREGIDA para correlationId
    const providedCorrelationId = props?.correlationId;
    // Si se proporciona un correlationId y no est谩 vac铆o, se usa.
    // Si no se proporciona o est谩 vac铆o, se genera uno nuevo.
    const effectiveCorrelationId = (!Guard.isNil(providedCorrelationId) && !Guard.isEmpty(providedCorrelationId))
        ? providedCorrelationId
        : UuidUtils.generateCorrelationId();

    this.metadata = Object.freeze({
      correlationId: effectiveCorrelationId, // Usar el ID efectivo
      causationId: props?.causationId,
      timestamp: props?.timestamp || Date.now(),
      userId: props?.userId,
    });

}
}
// libs/core/domain/shared-kernel/commands-queries/src/lib/command.base.ts
/_ SECCIN DE MEJORAS (Existente, no se modifica por este fix) _/
/_ NOTAS PARA IMPLEMENTACIN FUTURA (Existente, no se modifica por este fix) _/

TypeScript
Se aplicar铆an cambios an谩logos en QueryBase.ts y DomainEventBase.ts.
Impacto Esperado y Beneficios:
Beneficio: Asegura la trazabilidad 煤nica y correcta de cada comando, query y evento a trav茅s del sistema. Fundamental para debugging y observabilidad.
Impacto: Correcci贸n cr铆tica. Los tests para estas clases base (a implementar) deber谩n verificar esta nueva l贸gica.
Prioridad:  Cr铆tico
Complejidad Estimada: Baja (modificaci贸n de l贸gica en 3 archivos).
Riesgos/Efectos Secundarios: M铆nimos si se implementa correctamente. El principal riesgo es no hacerlo.
3.1.2. Implementar Tests Unitarios para Clases Base del Shared Kernel y Schemas Zod
Descripci贸n del Problema: Las clases base fundamentales (EntityBase, AggregateRootBase, ValueObjectBase, CommandBase, QueryBase, PaginatedQueryBase, DomainEventBase) y los esquemas Zod (common.schemas.ts, pagination.schemas.ts) actualmente no tienen tests unitarios. Las librer铆as correspondientes tienen passWithNoTests: true en sus project.json.
Soluci贸n Propuesta:
Crear archivos .spec.ts para cada una de estas clases base y archivos de schemas.
Implementar tests unitarios exhaustivos que cubran su l贸gica interna (constructores, m茅todos, validaciones, generaci贸n de valores por defecto, etc.).
Una vez que los tests est茅n implementados y pasando, cambiar passWithNoTests: true a false (o eliminar la l铆nea) en los project.json de las librer铆as afectadas:
core-domain-shared-kernel-entities
core-domain-shared-kernel-value-objects
core-domain-shared-kernel-events
core-domain-shared-kernel-commands-queries
shared-validation-schemas
Archivos Principales Afectados:
Todos los project.json de las librer铆as mencionadas.
Creaci贸n de nuevos archivos .spec.ts dentro de cada librer铆a.
Pasos de Implementaci贸n Concretos (Ejemplo para ValueObjectBase.spec.ts - esqueleto):
// libs/core/domain/shared-kernel/value-objects/src/lib/value-object.base.spec.ts
import { ValueObject } from './value-object.base';
import { ArgumentNotProvidedException } from '@dfs-suite/shared-errors';

interface TestProps { value: string }
class TestVO extends ValueObject<TestProps> {
constructor(props: TestProps) { super(props); }
protected validate(props: TestProps): void {
if (props.value === 'invalid') throw new Error('Invalid value');
}
}
// ... describe blocks para constructor, equals, unpack, validate (indirectamente) ...
// libs/core/domain/shared-kernel/value-objects/src/lib/value-object.base.spec.ts
/_ SECCIN DE MEJORAS _/
/_ NOTAS _/

TypeScript
Impacto Esperado y Beneficios:
Beneficio: Aumenta dr谩sticamente la confianza en la estabilidad y correcci贸n de los componentes m谩s fundamentales del sistema. Previene regresiones. Sirve como documentaci贸n ejecutable.
Impacto: Requiere un esfuerzo de desarrollo significativo para escribir todos estos tests. Es un prerrequisito para considerar la Fase 0 como verdaderamente completa.
Prioridad:  Cr铆tico (para la calidad y fiabilidad a largo plazo)
Complejidad Estimada: Media (por el volumen de tests a crear).
Riesgos/Efectos Secundarios: Descubrir bugs o debilidades en las clases base durante la escritura de tests (lo cual es positivo).
3.1.3. Resolver Deuda T茅cnica de @typescript-eslint/no-unsafe-return en ValueObjectBase.unpack()
Descripci贸n del Problema: El m茅todo unpack() en ValueObjectBase.ts tiene una regla ESLint desactivada debido a que ESLint/TypeScript no puede inferir con certeza el tipo de retorno despu茅s de Object.freeze({ ...objectProps }) con gen茅ricos.
Soluci贸n Propuesta:
Investigar alternativas de tipado o refactorizaci贸n para unpack() que satisfagan la regla sin comprometer la funcionalidad.
Posibles enfoques:
Hacer expl铆cito el tipo de propsCopy antes de Object.freeze.
Considerar si el tipo de retorno de unpack() deber铆a ser Readonly<TProps> para alinearse con Object.freeze, y ajustar los VOs concretos (como TenantStatusVO.unpack() que devuelve TenantStatusEnum directamente) o los consumidores. (Actualmente, unpack para primitivos devuelve el primitivo, y para objetos, el objeto de props). La l贸gica actual de unpack que diferencia IDomainPrimitive es correcta. El problema es con el Object.freeze(propsCopy).
Si no se encuentra una soluci贸n de tipado superior, confirmar si la desactivaci贸n actual es la opci贸n pragm谩tica m谩s aceptable, documentando extensamente la raz贸n.
Archivos Principales Afectados:
libs/core/domain/shared-kernel/value-objects/src/lib/value-object.base.ts
Impacto Esperado y Beneficios:
Beneficio: C贸digo m谩s limpio, mayor seguridad de tipos si se encuentra una soluci贸n, o mayor confianza en la desactivaci贸n si se justifica bien.
Impacto: Esfuerzo de investigaci贸n y posible refactorizaci贸n.
Prioridad:  Alta
Complejidad Estimada: Media (la investigaci贸n del tipado puede ser compleja).
Riesgos/Efectos Secundarios: Si se cambia el tipo de retorno de unpack(), podr铆a afectar a muchos VOs y sus tests.
3.1.4. Tipado de IDs Consistente (AggregateId vs. Branded IDs como TenantId)
Descripci贸n del Problema: Hay casts as unknown as AggregateId o as unknown as TenantId en los Casos de Uso (ej. CreateTenantUseCase, ActivateTenantUseCase) porque los puertos de repositorio gen茅ricos (IRepositoryPort) esperan AggregateId, mientras que los comandos o entidades pueden usar IDs m谩s espec铆ficos como TenantId.
Soluci贸n Propuesta (Mejora Propuesta 1 de repository.port.ts y otras):
Hacer IRepositoryPort<Aggregate extends AggregateRoot<any>, IDType extends AggregateId = AggregateId> gen茅rico para el tipo de ID.
Las interfaces de repositorio espec铆ficas definir铆an el IDType (ej. ITenantRepository extends IRepositoryPort<TenantEntity, TenantId>).
Los m茅todos en IRepositoryPort (como findOneById) usar铆an IDType.
Archivos Principales Afectados:
libs/core/domain/shared-kernel/ports/src/lib/repository.port.ts
Todas las interfaces de repositorio espec铆ficas (ej. libs/core/domain/tenancy/src/lib/ports/tenant.repository.port.ts).
Todas las implementaciones de repositorio en la capa de infraestructura (futuro).
Casos de Uso que interact煤an con repositorios (para eliminar casts).
Impacto Esperado y Beneficios:
Beneficio: Elimina casts inseguros, mejora significativamente la seguridad de tipos y la claridad del c贸digo.
Impacto: Refactorizaci贸n estructural importante en los puertos y sus consumidores.
Prioridad:  Alta
Complejidad Estimada: Media.
Riesgos/Efectos Secundarios: Requiere tocar muchas firmas de interfaces y clases.

---

---

3.2.  Mejoras de Robustez del Shared Kernel y Dominios Espec铆ficos (Prioridad Media)
Estas mejoras se centran en refinar las abstracciones y la l贸gica dentro del shared-kernel y los dominios para aumentar su robustez, claridad y alineaci贸n con las mejores pr谩cticas de DDD.
3.2.1. Refinamiento de correlationId y userId en Metadata (Comandos, Queries, Eventos)
Descripci贸n del Problema: Adem谩s de la correcci贸n del bug del correlationId por defecto, la forma en que se maneja y se requiere el userId en ICommandMetadata (y por ende en IDomainEventMetadata y QueryBase.metadata) es opcional (Maybe<UserId>).
Soluci贸n Propuesta:
correlationId: Despu茅s de corregir el bug, asegurar que los componentes que crean Comandos/Queries (ej. Controladores API, otros Casos de Uso) propaguen el correlationId existente o pasen undefined para que se genere uno nuevo. Considerar un RequestContextService (ver Secci贸n 3.3.2) para acceso impl铆cito.
userId:
Evaluar si userId debe ser obligatorio para ciertos tipos de comandos (ej. todos los que modifican datos) o eventos.
Si es as铆, introducir interfaces de metadata m谩s espec铆ficas como IAuthenticatedCommandMetadata extends ICommandMetadata { readonly userId: UserId; } y que los comandos/eventos correspondientes la usen.
Para queries, userId podr铆a ser necesario para aplicar filtros de autorizaci贸n a nivel de datos.
Archivos Principales Afectados:
libs/core/domain/shared-kernel/commands-queries/src/lib/command.interface.ts (y query.interface.ts si se crea IQueryMetadata).
libs/core/domain/shared-kernel/events/src/lib/domain-event.interface.ts.
CommandBase.ts, QueryBase.ts, DomainEventBase.ts (para la l贸gica de correlationId).
Clases de comando y evento concretas (para usar metadata m谩s espec铆fica si se crea).
Casos de Uso y Controladores API (para asegurar la provisi贸n de userId cuando sea requerido).
Impacto Esperado y Beneficios:
Beneficio: Trazabilidad m谩s robusta. Auditor铆a y autorizaci贸n m谩s fiables si userId se gestiona de forma m谩s estricta.
Impacto: Requiere un an谩lisis de qu茅 operaciones necesitan un userId obligatorio. Modificaciones en varias interfaces y clases.
Prioridad:  Media (la correcci贸n del bug de correlationId es Alta/Cr铆tica).
Complejidad Estimada: Media.
3.2.2. Pruebas Detalladas de Payloads de Eventos de Dominio
Descripci贸n del Problema: Los tests actuales para entidades (ej. TenantEntity.spec.ts) verifican la instancia del evento emitido, pero no siempre el contenido completo y correcto de su payload.
Soluci贸n Propuesta: Expandir las aserciones en los tests de las entidades para verificar rigurosamente que el payload de cada evento de dominio contenga todos los datos esperados y correctos, y que el aggregateId del evento sea el correcto.
Archivos Principales Afectados:
Todos los archivos _.entity.spec.ts que prueben entidades que emiten eventos (ej. libs/core/domain/tenancy/src/lib/entities/tenant.entity.spec.ts).
Impacto Esperado y Beneficios:
Beneficio: Asegura que los eventos (que son contratos) se emitan con toda la informaci贸n necesaria y correcta, aumentando la fiabilidad de los manejadores de eventos.
Impacto: Expansi贸n de aserciones en los tests. Puede requerir datos de prueba m谩s espec铆ficos.
Prioridad:  Media
Complejidad Estimada: Baja a Media (dependiendo del n煤mero de eventos y la complejidad de sus payloads).
3.2.3. Introducci贸n de Value Objects para Conceptos Clave Adicionales
Descripci贸n del Problema: Propiedades como planId en TenantEntity o key y value en TenantConfigurationEntity son actualmente strings. Si estos conceptos tienen reglas de validaci贸n, formato o comportamiento propios, usar strings primitivos puede llevar a una l贸gica de validaci贸n dispersa y menor seguridad de tipos.
Soluci贸n Propuesta:
Identificar propiedades en entidades que representan conceptos con sus propias invariantes.
Crear Value Objects (VOs) dedicados para ellos (ej. PlanIdVO, TenantConfigKeyVO, TenantConfigValueVO<T> si el valor puede ser tipado).
Refactorizar las entidades para usar estos VOs.
Archivos Principales Afectados:
Archivos de entidad relevantes (ej. tenant.entity.ts, tenant-configuration.entity.ts).
Creaci贸n de nuevos archivos _.vo.ts en las librer铆as de dominio correspondientes.
Casos de Uso y Mappers que interact煤an con estas entidades/propiedades.
Impacto Esperado y Beneficios:
Beneficio: Mayor robustez, encapsulaci贸n de l贸gica de validaci贸n, sem谩ntica de dominio m谩s rica, mejor seguridad de tipos.
Impacto: Requiere dise帽o y creaci贸n de nuevos VOs, y refactorizaci贸n de las entidades y sus consumidores.
Prioridad:  Media
Complejidad Estimada: Media por VO.
3.2.4. Refinamiento de la Gesti贸n de TenantConfigurationEntity (L铆mite de Agregado)
Descripci贸n del Problema: TenantConfigurationEntity actualmente extiende AggregateRoot. Se debe confirmar si esta es la mejor representaci贸n o si deber铆a ser una Entity dentro del agregado TenantEntity.
Soluci贸n Propuesta:
Analizar las invariantes y el ciclo de vida: 驴Puede una TenantConfiguration existir sin un Tenant? 驴Los cambios en TenantConfiguration deben ser at贸micos con cambios en Tenant?
Si es parte del agregado Tenant:
TenantConfigurationEntity hereda de Entity.
TenantEntity gestiona una colecci贸n de TenantConfigurationEntity y m茅todos para manipularlas.
ITenantConfigurationRepository podr铆a desaparecer o su rol cambiar铆a.
Si se mantiene como AggregateRoot separado (como est谩 ahora): Asegurar que la coordinaci贸n entre TenantEntity y TenantConfigurationEntity (si es necesaria) se maneje limpiamente en los Casos de Uso.
Archivos Principales Afectados:
libs/core/domain/tenancy/src/lib/entities/tenant.entity.ts
libs/core/domain/tenancy/src/lib/entities/tenant-configuration.entity.ts
libs/core/domain/tenancy/src/lib/ports/tenant-configuration.repository.port.ts (y su implementaci贸n).
Casos de Uso que manejan configuraciones.
Impacto Esperado y Beneficios:
Beneficio: Modelo de dominio m谩s preciso y alineado con los principios de DDD, asegurando la consistencia transaccional correcta.
Impacto: Potencialmente una refactorizaci贸n significativa del manejo de configuraciones.
Prioridad:  Media (requiere una decisi贸n de dise帽o arquitect贸nico).
Complejidad Estimada: Media a Alta si se refactoriza.
3.2.5. Tipos de Error Espec铆ficos para Puertos y Dominios
Descripci贸n del Problema: Los puertos de repositorio y otros servicios actualmente devuelven Result<..., ExceptionBase | Error>. Esto es muy gen茅rico.
Soluci贸n Propuesta:
Definir tipos de error m谩s espec铆ficos para operaciones de persistencia (ej. EntityNotFoundError, OptimisticLockError, DatabaseUnavailableError) y otros servicios de infraestructura.
Definir jerarqu铆as de errores por dominio (ej. TenancyDomainError como base para TenantAlreadyExistsError).
Actualizar las firmas de los puertos para usar estos errores m谩s espec铆ficos en la parte E de Result<T,E>.
Archivos Principales Afectados:
libs/shared/errors/ (para errores de infraestructura gen茅ricos).
libs/core/domain/<contexto>/src/lib/errors/ (para errores de dominio).
Todas las interfaces de puerto (\*.port.ts).
Implementaciones de adaptadores y Casos de Uso (para manejar/lanzar los nuevos tipos de error).
Impacto Esperado y Beneficios:
Beneficio: Contratos de error m谩s precisos, permite un manejo de errores m谩s granular y significativo por parte de los llamadores.
Impacto: Esfuerzo considerable en la definici贸n de errores y refactorizaci贸n de firmas y manejo de errores.
Prioridad:  Media
Complejidad Estimada: Media.
3.2.6. Validaci贸n de Formato de IsoDateString y otros Primitivos Brandeados
Descripci贸n del Problema: Tipos como IsoDateString son solo marcas de tipo en TypeScript. No hay validaci贸n en runtime de que el string subyacente realmente cumpla el formato. Similar para UuidSchema en UuidUtils si no se validara.
Soluci贸n Propuesta:
Para IsoDateString: Considerar un IsoDateStringVO que valide el formato en su creaci贸n, o asegurar que toda fuente de IsoDateString (ej. new Date().toISOString(), o datos de API validados con IsoDateStringSchema de Zod) produzca el formato correcto.
Para IDs generados por UuidUtils: La librer铆a uuid es confiable. La validaci贸n adicional con regex es opcional (paranoia).
Para IDs recibidos del exterior: Deben ser validados contra UuidSchema (o schemas espec铆ficos como TenantIdSchema) en la capa de entrada (API).
Archivos Principales Afectados:
libs/shared/types/src/lib/primitive-types.ts (para documentaci贸n de la expectativa).
libs/shared/validation-schemas/ (asegurar que los Zod schemas validen formatos).
Potencialmente crear IsoDateStringVO.ts en libs/core/domain/shared-kernel/value-objects/.
Impacto Esperado y Beneficios:
Beneficio: Mayor robustez al asegurar que los datos no solo est茅n "brandeados" a nivel de tipo, sino que tambi茅n cumplan con el formato esperado en runtime.
Impacto: Depende del enfoque. Crear VOs para todo puede ser verboso. Confiar en la validaci贸n en los bordes (API DTOs) es a menudo un buen equilibrio.
Prioridad:  Media
Complejidad Estimada: Baja a Media.

---

---

3.3.  Mejoras de Calidad de C贸digo, Developer Experience (DX) y Configuraciones (Prioridad Media-Baja)
Estas mejoras se centran en refinar el c贸digo para mayor claridad, mejorar la experiencia de los desarrolladores y optimizar las configuraciones de herramientas.
3.3.1. Habilitar declarationMap: true en todos los tsconfig.lib.json
Descripci贸n del Problema: Actualmente, los tsconfig.lib.json no tienen declarationMap: true.
Soluci贸n Propuesta: A帽adir "declarationMap": true a la secci贸n compilerOptions de todos los archivos tsconfig.lib.json en libs/shared/_ y libs/core/_.
Archivos Principales Afectados: Todos los tsconfig.lib.json de las librer铆as.
Pasos de Implementaci贸n Concretos (Ejemplo para una librer铆a):
// en un tsconfig.lib.json
{
"extends": "./tsconfig.json",
"compilerOptions": {
"outDir": "../../../../dist/out-tsc", // o la ruta correcta
"declaration": true,
"declarationMap": true, // <--- AADIR ESTO
"types": ["node"] // o [] seg煤n corresponda
},
"include": ["src/**/*.ts"],
"exclude": ["jest.config.ts", "src/**/*.spec.ts", "src/**/*.test.ts"]
}

Json
Impacto Esperado y Beneficios:
Beneficio: Mejora significativamente la DX al usar "Go to Definition" o "Peek Definition" en los IDEs, permitiendo saltar del archivo .d.ts de una librer铆a consumida directamente a su c贸digo fuente .ts original.
Impacto: M铆nimo. Aumenta ligeramente el tama帽o de los artefactos de build (se generan archivos .d.ts.map).
Prioridad:  Media (mejora de DX importante).
Complejidad Estimada: Baja.
3.3.2. Estandarizar moduleResolution: "node" en tsconfig.spec.json
Descripci贸n del Problema: Algunos tsconfig.spec.json usan "moduleResolution": "node10" mientras que otros podr铆an usar (o deber铆an usar) "node".
Soluci贸n Propuesta: Revisar todos los tsconfig.spec.json y estandarizar a "moduleResolution": "node".
Archivos Principales Afectados: Todos los tsconfig.spec.json.
Impacto Esperado y Beneficios:
Beneficio: Consistencia en la configuraci贸n. "node" es la opci贸n m谩s actual para la resoluci贸n de m贸dulos al estilo Node.js.
Impacto: M铆nimo, improbable que cause problemas funcionales.
Prioridad:  Baja (mejora de consistencia menor).
Complejidad Estimada: Baja.
3.3.3. Revisar types: ["node"] vs. types: [] en tsconfig.lib.json
Descripci贸n del Problema: Algunas librer铆as del shared-kernel (ej. value-objects, ports, mappers) que solo definen interfaces o clases base agn贸sticas podr铆an no necesitar los tipos globales de Node.js. Actualmente, muchas tienen types: ["node"].
Soluci贸n Propuesta: Para cada librer铆a en libs/shared/ y libs/core/domain/shared-kernel/, evaluar si realmente necesita types: ["node"]. Si no hay dependencias directas o indirectas de APIs de Node.js, cambiar a types: [].
Archivos Principales Afectados: Archivos tsconfig.lib.json de las librer铆as relevantes.
Impacto Esperado y Beneficios:
Beneficio: Mayor pureza y portabilidad te贸rica de las librer铆as base, evitando la inclusi贸n accidental de tipos globales de Node.js si no son necesarios.
Impacto: Requiere un an谩lisis cuidadoso. Si se quita y alguna dependencia transitiva lo requer铆a, podr铆an surgir errores de tipo. Para librer铆as destinadas a un backend Node.js, types: ["node"] suele ser una opci贸n segura y sin mayores inconvenientes.
Prioridad:  Baja
Complejidad Estimada: Baja a Media (el an谩lisis puede llevar tiempo).
3.3.4. Uso Consistente de Exportaciones Nombradas en index.ts (Barrel Files)
Descripci贸n del Problema: La mayor铆a de los index.ts de las librer铆as usan export \* from './lib/...'.
Soluci贸n Propuesta: Considerar cambiar a exportaciones nombradas expl铆citas para un control m谩s fino de la API p煤blica de cada librer铆a, como se detall贸 en la Secci贸n 2.11 del "Documento Maestro de Convenciones".
// Ejemplo para un index.ts
export { MyClass } from './lib/my-class.file';
export { type IMyInterface } from './lib/my-interface.file';

TypeScript
Archivos Principales Afectados: Todos los archivos index.ts en libs/_ /src/.
Impacto Esperado y Beneficios:
Beneficio: Mayor claridad sobre la API p煤blica, previene exportaciones accidentales, puede ayudar ligeramente al tree-shaking, hace los cambios en la API p煤blica m谩s evidentes.
Impacto: Aumenta la verbosidad y el mantenimiento manual de los index.ts. Es una decisi贸n de estilo con pros y contras.
Prioridad:  Baja (mejora de claridad y control, pero export _ es funcional).
Complejidad Estimada: Media (por el n煤mero de archivos a modificar).
3.3.5. Resolver Duplicaci贸n de Definici贸n de CorrelationId
Descripci贸n del Problema: El tipo CorrelationId est谩 definido tanto en libs/shared/types/src/lib/primitive-types.ts como en libs/shared/types/src/lib/correlation-id.type.ts.
Soluci贸n Propuesta:
Elegir una 煤nica fuente de verdad para la definici贸n de CorrelationId (probablemente correlation-id.type.ts por ser m谩s espec铆fico).
Eliminar la definici贸n duplicada del otro archivo.
Asegurar que el index.ts de libs/shared/types/ exporte la definici贸n can贸nica una sola vez.
Archivos Principales Afectados:
libs/shared/types/src/lib/primitive-types.ts
libs/shared/types/src/lib/correlation-id.type.ts
libs/shared/types/src/index.ts
Impacto Esperado y Beneficios:
Beneficio: Cumplimiento del principio DRY, evita inconsistencias y confusi贸n.
Impacto: Refactorizaci贸n menor.
Prioridad:  Media (para limpieza y evitar problemas futuros).
Complejidad Estimada: Baja.
3.3.6. Resolver Anomal铆as Menores de Tests E2E (api-main-e2e)
Descripci贸n del Problema (Seg煤n Bit谩cora):
Necesidad de testMatch expl铆cito en apps/api-main-e2e/jest.config.ts porque los tests no eran detectados.
Proceso de serve (levantado por nx e2e) termina con c贸digo 1 despu茅s de que los tests E2E pasan.
Soluci贸n Propuesta:
testMatch: Investigar la configuraci贸n de jest.preset.js y c贸mo Nx maneja los patrones de descubrimiento para proyectos E2E. El objetivo es entender por qu茅 el patr贸n por defecto no encuentra \*.e2e-spec.ts y si se puede revertir a una configuraci贸n sin testMatch expl铆cito, o si la configuraci贸n actual es la soluci贸n pragm谩tica.
C贸digo de Salida 1: Investigar el globalTeardown.ts de los tests E2E y c贸mo Nx finaliza el proceso serve. Podr铆a ser un cierre no del todo limpio del servidor NestJS o alg煤n problema en la comunicaci贸n entre Jest y el proceso servidor.
Archivos Principales Afectados:
apps/api-main-e2e/jest.config.ts
apps/api-main-e2e/src/support/global-teardown.ts
Posiblemente jest.preset.js o configuraciones de Nx relacionadas con el ejecutor E2E.
Impacto Esperado y Beneficios:
Beneficio: Configuraci贸n de tests m谩s limpia y est谩ndar. Mayor fiabilidad del proceso de tests E2E.
Impacto: Esfuerzo de investigaci贸n y debugging.
Prioridad:  Baja (ya que los tests funcionan con el workaround, pero es bueno para la "salud" del sistema de tests).
Complejidad Estimada: Media (la investigaci贸n puede ser no trivial).
3.3.7. Refinamiento de Comentarios JSDoc/TSDoc y Documentaci贸n .md
Descripci贸n del Problema: Aunque la documentaci贸n es buena, siempre hay espacio para mejorar la completitud, claridad y consistencia de los comentarios JSDoc/TSDoc en todo el c贸digo y la documentaci贸n en archivos .md.
Soluci贸n Propuesta:
Revisar sistem谩ticamente los comentarios de todos los artefactos exportados (.ts) para asegurar que cumplen con las convenciones (descripci贸n, @param, @returns, etc.).
Expandir los README.md de librer铆as y aplicaciones.
Mantener actualizados los documentos maestros (.DOCUMENTO-TECNICO-PROYECTO.md, .BITACORA.md, etc.).
Archivos Principales Afectados: Potencialmente todos los archivos .ts y .md.
Impacto Esperado y Beneficios:
Beneficio: Mejor comprensi贸n del c贸digo, facilidad de mantenimiento, mejor onboarding.
Impacto: Esfuerzo continuo de documentaci贸n.
Prioridad:  Baja (tarea continua).
Complejidad Estimada: Variable, continua.
3.3.8. Implementar Hooks de Git (Husky + lint-staged)
Descripci贸n del Problema: Actualmente no hay hooks de Git para forzar linting/formateo antes de los commits.
Soluci贸n Propuesta: Configurar Husky y lint-staged para ejecutar eslint --fix y prettier --write en los archivos "staged" antes de cada commit, como se describe en la Secci贸n 11.4 del "Documento Maestro de Convenciones".
Archivos Principales Afectados: package.json (para scripts y configuraci贸n de lint-staged), creaci贸n de directorio .husky/.
Impacto Esperado y Beneficios:
Beneficio: Asegura que solo c贸digo formateado y sin errores de linting (auto-corregibles) llegue al repositorio. Mejora la calidad de la base de c贸digo desde el inicio.
Impacto: Configuraci贸n inicial.
Prioridad:  Media (mejora significativa para la calidad del repositorio).
Complejidad Estimada: Baja a Media.

---

---

3.4.  Pr贸ximos Pasos del Roadmap e Integraci贸n de Mejoras en Nuevas Funcionalidades (Prioridad seg煤n Roadmap)
Esta secci贸n no trata de mejoras a c贸digo existente, sino de c贸mo las mejoras y convenciones establecidas impactar谩n y deben ser aplicadas al desarrollo de las pr贸ximas funcionalidades definidas en el .ROADMAP.md.
3.4.1. Tarea 0.5.2 (Roadmap): Implementar Tests Unitarios para Casos de Uso Tenancy
Descripci贸n: Completar la implementaci贸n de los tests unitarios para CreateTenantUseCase y ActivateTenantUseCase en libs/core/application/tenancy/.
Aplicaci贸n de Mejoras/Convenciones:
Seguir los "Patrones de Pruebas" (Secci贸n 8 del Doc. de Convenciones): estructura AAA, mocking de dependencias (repositorios, logger, servicios de aprovisionamiento), verificaci贸n de todos los caminos l贸gicos (茅xito, errores de dominio, errores de infraestructura).
Asegurar que el correlationId se propague y se use en logging dentro de los tests.
Una vez completados, actualizar passWithNoTests: true a false en el project.json de @dfs-suite/core-application-tenancy.
Establecer umbrales de cobertura para estos casos de uso.
Archivos Principales Afectados:
Creaci贸n de libs/core/application/tenancy/src/lib/use-cases/create-tenant/create-tenant.use-case.spec.ts
Creaci贸n de libs/core/application/tenancy/src/lib/use-cases/activate-tenant/activate-tenant.use-case.spec.ts
libs/core/application/tenancy/project.json
Prioridad:  Alta (seg煤n el flujo del roadmap, es el siguiente paso t茅cnico inmediato).
Complejidad Estimada: Media.
3.4.2. Hitos 0.6, 0.7, 0.8 (Roadmap): Implementaci贸n de Capa de Infraestructura y Ensamblaje Inicial para Tenancy
Descripci贸n:
Hito 0.6: Crear librer铆as de infraestructura para persistencia de Tenancy (Prisma), aprovisionamiento de DB, y emisor de eventos.
Hito 0.7: Implementar y configurar el logger.
Hito 0.8: Ensamblar todo en api-main con un TenancyModule y endpoints b谩sicos.
Aplicaci贸n de Mejoras/Convenciones:
Infraestructura (layer:infrastructure):
Las implementaciones de ITenantRepository, ITenantConfigurationRepository, IDatabaseProvisioningServicePort, ILoggerPort, IDomainEventEmitter deben residir aqu铆.
Utilizar los Symbols de los puertos para la provisi贸n en m贸dulos NestJS.
Implementar Mappers (IMapper) para convertir entre entidades de dominio y modelos de Prisma.
Manejo de Transacciones (Mejora 3.2.2 y 3.1.4): Los adaptadores de repositorio deben implementar el m茅todo transaction del IRepositoryPort. Considerar c贸mo se orquestar谩n las transacciones que abarcan el aprovisionamiento de DB y la persistencia del tenant.
Publicaci贸n de Eventos (Mejora 3.2.3): El adaptador de ITenantRepository (en sus m茅todos insert/update/save) debe obtener los eventos del agregado (getAndClearDomainEvents()) y publicarlos usando IDomainEventEmitter despu茅s de una transacci贸n de DB exitosa.
Seguridad (Encriptaci贸n): Si DbConnectionConfigVO contiene datos sensibles, el adaptador de persistencia para TenantEntity (o TenantConfigurationEntity) debe encargarse de encriptar/desencriptar estos datos al interactuar con la DB de plataforma.
API (api-main - scope:app):
Implementar TenancyModule en NestJS, proveyendo los Casos de Uso y sus dependencias (implementaciones de puertos).
Crear Controladores/Resolvers para los endpoints.
Utilizar DTOs de entrada validados con ZodValidationPipe (usando schemas de shared-validation-schemas).
Utilizar IApiResponse para respuestas REST.
Aplicar AllExceptionsFilter y TransformResponseInterceptor.
Implementar CorrelationIdMiddleware y TenantContextMiddleware.
Usar ILoggerPort con correlationId y contexto.
Archivos Principales Afectados:
Creaci贸n de nuevas librer铆as en libs/infrastructure/.
Modificaciones extensas en apps/api-main/.
Prioridad:  Alta (siguientes en el roadmap).
Complejidad Estimada: Alta (implica mucha implementaci贸n nueva y configuraci贸n de DI).
3.4.3. Fase 1 y Posteriores (Roadmap): Implementaci贸n de MVP Funcional (WhatsApp, Leads, PWAs)
Descripci贸n: Desarrollo de los dominios WhatsApp, Anti-Ban, Leads-Flow, sus capas de aplicaci贸n e infraestructura, y las PWAs.
Aplicaci贸n de Mejoras/Convenciones:
TODAS las convenciones de nomenclatura, estructura de directorios, patrones DDD, uso de TypeScript, manejo de errores, patrones de pruebas y documentaci贸n detalladas en el "Documento Maestro de Convenciones y Est谩ndares" DEBEN aplicarse a estos nuevos m贸dulos y aplicaciones desde su concepci贸n.
Las lecciones aprendidas y las mejoras implementadas en la Fase 0 (ej. correlationId corregido, IRepositoryPort con ID tipado, VOs para conceptos clave) deben ser la base para el nuevo c贸digo.
Revisar depConstraints: A medida que se a帽aden nuevas librer铆as de dominio, aplicaci贸n e infraestructura, actualizar las reglas en eslint.config.mjs (ra铆z) para mantener la integridad arquitect贸nica.
PWAs: Definir y seguir convenciones espec铆ficas para el frontend (Next.js, React, Tailwind, Shadcn/UI, gesti贸n de estado con Zustand/TanStack Query), posiblemente en un ap茅ndice o documento separado si es muy extenso.
Prioridad: Seg煤n roadmap.
Complejidad Estimada: Muy Alta (cuerpo principal del proyecto). 4. Artefactos Necesarios/Modificados (Resumen de la Implementaci贸n del Plan)
Modificaciones a Clases Base Existentes:
CommandBase, QueryBase, DomainEventBase: Correcci贸n de correlationId.
ValueObjectBase: Resoluci贸n de deuda t茅cnica de unpack().
IRepositoryPort: Tipado de ID gen茅rico.
Nuevos Archivos de Test:
_.spec.ts para todas las clases base del shared-kernel.
_.spec.ts para los schemas Zod.
\*.spec.ts para los Casos de Uso de Tenancy.
Actualizaci贸n de Archivos de Configuraci贸n:
project.json: Cambiar passWithNoTests: true a false.
tsconfig.lib.json: A帽adir declarationMap: true, revisar types.
tsconfig.spec.json: Estandarizar moduleResolution.
Nuevas Librer铆as de Infraestructura: Para persistencia, logging, aprovisionamiento, etc.
Desarrollo en api-main: M贸dulos, controladores, pipes, filtros, interceptors.
Nuevas Librer铆as de Dominio y Aplicaci贸n: Para WhatsApp, Leads, etc.
Nuevas Aplicaciones (PWAs). 5. Plan de Pruebas y Verificaci贸n (Post-Mejoras)
Tests Unitarios: Deben cubrir toda la l贸gica nueva y refactorizada, especialmente en las clases base y los casos de uso. Los umbrales de cobertura deben empezar a ser forzados.
Linting y Formateo: pnpm nx run-many --target=lint --all y pnpm prettier --check . deben pasar sin errores.
Builds: Todas las aplicaciones y librer铆as construibles deben compilarse sin errores.
Tests E2E: Los tests E2E existentes para api-main deben seguir pasando. Se a帽adir谩n nuevos tests E2E para las nuevas funcionalidades.
Revisi贸n de depConstraints: Ejecutar pnpm nx dep-graph y revisar visualmente que las dependencias entre las nuevas y antiguas librer铆as sigan la arquitectura hexagonal. Validar con el linter.
Revisi贸n de C贸digo: Todos los cambios deben pasar por Pull Requests y ser revisados contra el "Documento Maestro de Convenciones y Est谩ndares".
Verificaci贸n Manual: Para flujos cr铆ticos, realizar pruebas manuales en un entorno de staging.
Este Plan Maestro de Mejoras Transversales proporciona una hoja de ruta clara para abordar las debilidades identificadas y asegurar que el desarrollo futuro de DFS-Invest-Suite se realice sobre una base a煤n m谩s s贸lida y siguiendo est谩ndares de alta calidad. La implementaci贸n de estas mejoras, especialmente las cr铆ticas y de alta prioridad, debe ser el foco antes de avanzar significativamente en nuevas funcionalidades complejas.

---

---

Listado de Mejoras por Artefacto/Grupo y Archivos Relacionados
I. Shared Kernel - Clases Base de Mensajer铆a (Comandos, Queries, Eventos)
Artefacto: CommandBase.ts
Ruta: libs/core/domain/shared-kernel/commands-queries/src/lib/command.base.ts
Mejoras Principales:
BUG CRTICO: Corregir l贸gica de correlationId por defecto para que genere un UUID 煤nico si no se provee (no usar placeholder fijo).
Tipar commandId como Branded Type CommandInstanceId.
Considerar validaci贸n b谩sica de metadata en el constructor.
Revisar/eliminar tipo CommandProps<T> si no se usa.
Archivos Relacionados Afectados:
QueryBase.ts, DomainEventBase.ts (para consistencia en correlationId).
ICommand.ts (si commandId cambia de tipo).
UuidUtils.ts (si se a帽ade generateCommandInstanceId()).
Tests unitarios para CommandBase (a crear).
Artefacto: QueryBase.ts
Ruta: libs/core/domain/shared-kernel/commands-queries/src/lib/query.base.ts
Mejoras Principales:
BUG CRTICO: Corregir l贸gica de correlationId por defecto (similar a CommandBase).
Considerar interfaz IQueryMetadata dedicada en lugar de reutilizar ICommandMetadata.
Considerar a帽adir queryId (Branded Type).
Archivos Relacionados Afectados:
CommandBase.ts, DomainEventBase.ts (para consistencia en correlationId).
IQuery.ts (si se a帽ade queryId o cambia IQueryMetadata).
Tests unitarios para QueryBase (a crear).
Artefacto: DomainEventBase.ts
Ruta: libs/core/domain/shared-kernel/events/src/lib/domain-event.base.ts
Mejoras Principales:
BUG CRTICO: Corregir l贸gica de correlationId por defecto (similar a CommandBase).
Considerar validaci贸n de payload con schema Zod en constructor (opcional).
Considerar inmutabilidad profunda del payload.
Archivos Relacionados Afectados:
CommandBase.ts, QueryBase.ts (para consistencia en correlationId).
IDomainEvent.ts (si se a帽ade eventVersion a metadata).
Tests unitarios para DomainEventBase (a crear).
II. Shared Kernel - Clases Base de Dominio (Entidades, VOs)
Artefacto: EntityBase.ts (Nombre inferido, archivo es entity.base.ts)
Ruta: libs/core/domain/shared-kernel/entities/src/lib/entity.base.ts
Mejoras Principales:
Validar formato UUID para id en validateId().
Reconsiderar/eliminar validaci贸n MAX*PROPS en validateProps().
Archivos Relacionados Afectados:
AggregateRootBase.ts (hereda de EntityBase).
Todas las entidades concretas.
Tests unitarios para EntityBase (a crear).
Artefacto: AggregateRootBase.ts (Nombre inferido, archivo es aggregate-root.base.ts)
Ruta: libs/core/domain/shared-kernel/entities/src/lib/aggregate-root.base.ts
Mejoras Principales:
Asegurar que validate() se llame consistentemente antes de addEvent(). (Ya est谩, mantener).
Archivos Relacionados Afectados:
Todas las entidades Aggregate Root concretas.
Tests unitarios para AggregateRootBase (a crear).
Artefacto: ValueObjectBase.ts (Nombre inferido, archivo es value-object.base.ts)
Ruta: libs/core/domain/shared-kernel/value-objects/src/lib/value-object.base.ts
Mejoras Principales:
DEUDA TCNICA: Resolver desactivaci贸n de ESLint @typescript-eslint/no-unsafe-return en unpack().
Considerar comparaci贸n profunda en equals() si los VOs contienen objetos anidados/Fechas.
Archivos Relacionados Afectados:
Todos los Value Objects concretos.
Tests unitarios para ValueObjectBase (a crear).
III. Shared Kernel - Puertos (Interfaces de Abstracci贸n)
Artefacto: IRepositoryPort.ts (Nombre inferido, archivo es repository.port.ts)
Ruta: libs/core/domain/shared-kernel/ports/src/lib/repository.port.ts
Mejoras Principales:
Hacer gen茅rico para el tipo de ID del Agregado (IRepositoryPort<Agg, IDType extends AggregateId>).
Refinar firma de transaction() para pasar repositorio transaccional.
Considerar tipos de error m谩s espec铆ficos que ExceptionBase | Error.
Archivos Relacionados Afectados:
Todas las interfaces de repositorio espec铆ficas (ej. ITenantRepository).
Todas las implementaciones de repositorio (futuro).
Casos de Uso que usan estos repositorios.
Artefacto: ILoggerPort.ts (Nombre inferido, archivo es logger.port.ts)
Ruta: libs/core/domain/shared-kernel/ports/src/lib/logger.port.ts
Mejoras Principales:
Considerar que todos los m茅todos devuelvan Promise<void> para consistencia con logging as铆ncrono.
Archivos Relacionados Afectados:
Implementaci贸n del logger (futuro).
Todos los consumidores del logger.
IV. Librer铆as shared/* (Tipos, Utilidades, Validaci贸n)
Artefacto: primitive-types.ts
Ruta: libs/shared/types/src/lib/primitive-types.ts
Mejoras Principales:
Resolver duplicaci贸n de CorrelationId (elegir fuente can贸nica con correlation-id.type.ts).
Considerar IsoDateStringVO para validaci贸n en runtime.
Archivos Relacionados Afectados:
correlation-id.type.ts, index.ts de shared-types.
Consumidores de IsoDateString si se cambia a VO.
Artefacto: common.schemas.ts (y otros archivos de schemas Zod)
Ruta: libs/shared/validation-schemas/src/lib/common.schemas.ts
Mejoras Principales:
A帽adir tests unitarios para los schemas Zod.
Refinar EmailSchema si es necesario (regex m谩s robusta o advertencia m谩s fuerte).
Considerar exportar tipos inferidos z.infer<>.
Archivos Relacionados Afectados:
project.json de shared-validation-schemas (para passWithNoTests).
Consumidores de los schemas (ej. Pipes en api-main).
V. Dominio Espec铆fico Tenancy (libs/core/domain/tenancy/ y libs/core/application/tenancy/)
Artefacto: TenantEntity.ts
Ruta: libs/core/domain/tenancy/src/lib/entities/tenant.entity.ts
Mejoras Principales:
Considerar VOs para planId.
Refinar manejo de TenantConfigurationEntity (驴parte del agregado o AR separado?).
Asegurar que payloads de eventos emitidos sean completos.
Archivos Relacionados Afectados:
TenantConfigurationEntity.ts, Casos de Uso, ITenantRepository.
Artefacto: CreateTenantUseCase.ts y ActivateTenantUseCase.ts
Ruta: libs/core/application/tenancy/src/lib/use-cases/...
Mejoras Principales:
Implementar tests unitarios (Tarea 0.5.2 del Roadmap).
Resolver casts de ID (depende de mejora en IRepositoryPort).
Manejo de ownerEmail vs ownerUserId (integrar con servicio de usuarios).
Implementar transaccionalidad/sagas para CreateTenantUseCase.
Resolver desactivaciones de ESLint para String(errorCaught).
Archivos Relacionados Afectados:
project.json de core-application-tenancy.
ITenantRepository, IDatabaseProvisioningServicePort.
(Futuro) IUserProvisioningServicePort o IUserRepositoryPort.
VI. Configuraciones Transversales y Herramientas
Artefacto: project.json (de todas las librer铆as sin tests)
Mejora Principal: Cambiar passWithNoTests: true a false despu茅s de a帽adir tests.
Archivos Afectados: project.json de core-domain-shared-kernel-\_ (entities, value-objects, events, commands-queries), shared-validation-schemas.
Artefacto: tsconfig.lib.json (de todas las librer铆as)
Mejora Principal: Habilitar "declarationMap": true.
Revisar types: ["node"] vs types: [] para librer铆as puras.
Archivos Afectados: Todos los tsconfig.lib.json.
Artefacto: tsconfig.spec.json (de todas las librer铆as con tests)
Mejora Principal: Estandarizar "moduleResolution": "node".
Archivos Afectados: Todos los tsconfig.spec.json.
Artefacto: eslint.config.mjs (ra铆z)
Mejora Principal: Refinar y expandir depConstraints a medida que se a帽aden nuevas librer铆as y tags. Validar que los tags actuales sean usados correctamente.
Archivos Afectados: eslint.config.mjs (ra铆z), project.json de todas las librer铆as (para asegurar tags correctos).
Herramientas (Setup): Hooks de Git (husky, lint-staged)
Mejora Principal: Implementar para formateo y linting pre-commit.
Archivos Afectados: package.json, creaci贸n de configs de husky y lint-staged.
Este listado es una gu铆a para priorizar las mejoras identificadas, enfoc谩ndose en la correcci贸n de bugs, robustecimiento de la base, y luego en la mejora continua de la calidad y DX.

---

---

Resumen Consolidado de Mejoras por Artefacto
Librer铆a: libs/core/domain/shared-kernel/commands-queries/
Ruta: libs/core/domain/shared-kernel/commands-queries/src/lib/command.base.ts
Corregir bug de correlationId por defecto (generar UUID 煤nico).
Tipar commandId como Branded Type CommandInstanceId.
Validar metadata b谩sica en constructor.
Revisar/eliminar tipo CommandProps<T>.
A帽adir tests unitarios.
Ruta: libs/core/domain/shared-kernel/commands-queries/src/lib/query.base.ts
Corregir bug de correlationId por defecto.
Considerar IQueryMetadata dedicada.
Considerar queryId (Branded Type).
A帽adir tests unitarios.
Ruta: libs/core/domain/shared-kernel/commands-queries/src/lib/paginated-query.base.ts
A帽adir validaci贸n b谩sica de par谩metros de paginaci贸n.
Alinear tipo de params.sortBy con IPaginatedQueryParams gen茅rico.
Considerar soporte para m煤ltiples campos de ordenaci贸n.
A帽adir tests unitarios.
Ruta: libs/core/domain/shared-kernel/commands-queries/src/lib/command.interface.ts
Tipar commandId como Branded Type CommandInstanceId.
Tipar timestamp en ICommandMetadata como IsoDateString.
Considerar IAuthenticatedCommandMetadata para userId obligatorio.
Ruta: libs/core/domain/shared-kernel/commands-queries/src/lib/query.interface.ts
Considerar IQueryMetadata dedicada.
Considerar queryName o queryType opcional.
Considerar queryId (Branded Type).
Ruta: libs/core/domain/shared-kernel/commands-queries/src/lib/command-handler.interface.ts
Considerar tipado de error m谩s espec铆fico en Result.
Considerar retorno consistente de Promise<void> (si aplica a todas las implementaciones).
Ruta: libs/core/domain/shared-kernel/commands-queries/src/lib/query-handler.interface.ts
Considerar tipado de error m谩s espec铆fico en Result.
Ruta: libs/core/domain/shared-kernel/commands-queries/src/index.ts
Usar exportaciones nombradas expl铆citas.
A帽adir documentaci贸n de m贸dulo.
Librer铆a: libs/core/domain/shared-kernel/entities/
Ruta: libs/core/domain/shared-kernel/entities/src/lib/entity.base.ts
Validar formato UUID para \_id en validateId().
Reconsiderar/eliminar validaci贸n MAX*PROPS en validateProps().
Considerar inmutabilidad profunda en getProps().
A帽adir tests unitarios.
Ruta: libs/core/domain/shared-kernel/entities/src/lib/aggregate-root.base.ts
Asegurar que validate() se llame consistentemente antes de addEvent() (ya se hace).
A帽adir tests unitarios (verificaci贸n de manejo de eventos, llamada a validate()).
Ruta: libs/core/domain/shared-kernel/entities/src/index.ts
Usar exportaciones nombradas expl铆citas (especialmente para CreateEntityProps, BaseEntityProps).
A帽adir documentaci贸n de m贸dulo.
Librer铆a: libs/core/domain/shared-kernel/events/
Ruta: libs/core/domain/shared-kernel/events/src/lib/domain-event.base.ts
Corregir bug de correlationId por defecto.
Considerar validaci贸n de payload con schema Zod en constructor.
Considerar inmutabilidad profunda del payload.
A帽adir tests unitarios.
Ruta: libs/core/domain/shared-kernel/events/src/lib/domain-event.interface.ts
Considerar tipado de eventName con literales/enums (opcional).
Tipar id como DomainEventInstanceId (Branded Type).
Considerar a帽adir eventVersion a IDomainEventMetadata.
Ruta: libs/core/domain/shared-kernel/events/src/lib/domain-event-emitter.interface.ts
Considerar retorno consistente de Promise<void> para publish y publishAll.
Clarificar contrato de manejo de errores de handlers.
Ruta: libs/core/domain/shared-kernel/events/src/lib/domain-event-handler.interface.ts
Considerar retorno consistente de Promise<void> para handle.
Considerar uso de constructores de evento en listenTo() en lugar de string.
Ruta: libs/core/domain/shared-kernel/events/src/index.ts
Usar exportaciones nombradas expl铆citas.
A帽adir documentaci贸n de m贸dulo.
Librer铆a: libs/core/domain/shared-kernel/mappers/
Ruta: libs/core/domain/shared-kernel/mappers/src/lib/mapper.interface.ts
Considerar m茅todos helper para mapeo de colecciones.
Considerar devoluci贸n de Result<..., MappingError> para manejo expl铆cito de errores de mapeo.
Refinar tipado de ResponseDto (ej. unknown por defecto en lugar de any).
Ruta: libs/core/domain/shared-kernel/mappers/src/index.ts
Usar exportaciones nombradas expl铆citas.
A帽adir documentaci贸n de m贸dulo.
Librer铆a: libs/core/domain/shared-kernel/ports/
Ruta: libs/core/domain/shared-kernel/ports/src/lib/repository.port.ts
Hacer gen茅rico para el tipo de ID del Agregado (IRepositoryPort<Agg, IDType>).
Refinar firma de transaction() para pasar repositorio transaccional.
Considerar tipos de error de repositorio m谩s espec铆ficos.
Considerar soporte para Criterios de B煤squeda/Especificaciones.
Ruta: libs/core/domain/shared-kernel/ports/src/lib/logger.port.ts
Considerar que todos los m茅todos devuelvan Promise<void>.
Mejorar integraci贸n con ExceptionBase para metadata en m茅todo error().
Ruta: libs/core/domain/shared-kernel/ports/src/index.ts
Usar exportaciones nombradas expl铆citas.
A帽adir documentaci贸n de m贸dulo.
Librer铆a: libs/core/domain/shared-kernel/value-objects/
Ruta: libs/core/domain/shared-kernel/value-objects/src/lib/value-object.base.ts
DEUDA TCNICA: Resolver desactivaci贸n ESLint @typescript-eslint/no-unsafe-return en unpack().
Mejorar equals() para objetos anidados/Fechas (comparaci贸n profunda).
A帽adir tests unitarios.
Ruta: libs/core/domain/shared-kernel/value-objects/src/index.ts
Usar exportaciones nombradas expl铆citas (para ValueObject, Primitives, IDomainPrimitive).
A帽adir documentaci贸n de m贸dulo.
Librer铆a: libs/shared/constants/
Ruta: libs/shared/constants/src/lib/pagination.constants.ts
Considerar configurabilidad por entorno para l铆mites/defaults.
Ruta: libs/shared/constants/src/lib/regex.constants.ts
Considerar regex de email m谩s robusta o reforzar advertencias.
Documentar fuentes de regex y a帽adir tests unitarios (indirectamente a trav茅s de schemas Zod).
Ruta: libs/shared/constants/src/index.ts
Usar exportaciones nombradas expl铆citas.
A帽adir documentaci贸n de m贸dulo.
Librer铆a: libs/shared/errors/
Ruta: libs/shared/errors/src/lib/exception.base.ts
Mejorar manejo de correlationId por defecto (no placeholder, obtener de contexto si es posible).
Permitir metadata tipada con gen茅ricos.
Serializaci贸n de cause m谩s detallada (recursiva si es ExceptionBase).
Considerar propiedad getSuggestedHttpStatus().
Ruta: libs/shared/errors/src/lib/exception.codes.ts
Considerar estructura anidada para c贸digos si la lista crece.
A帽adir JSDoc espec铆fico para cada c贸digo.
Ruta: libs/shared/errors/src/lib/generic.exceptions.ts
Considerar jerarqu铆a adicional para excepciones de argumento.
Considerar metadata estructurada para errores de argumento (nombre del argumento).
Ruta: libs/shared/errors/src/index.ts
Usar exportaciones nombradas expl铆citas.
A帽adir documentaci贸n de m贸dulo.
Librer铆a: libs/shared/result/
Ruta: libs/shared/result/src/lib/result.type.ts
Considerar m茅todos de conveniencia adicionales (match, tap, tapErr).
Considerar ResultAsync para operaciones as铆ncronas encadenadas.
Ruta: libs/shared/result/src/lib/result.utils.ts
Implementar m茅todos de conveniencia si se a帽aden a la interfaz.
Optimizar/robustecer JSON.stringify en mensajes de error de unwrap.
A帽adir tests unitarios.
Ruta: libs/shared/result/src/index.ts
Usar exportaciones nombradas expl铆citas.
A帽adir documentaci贸n de m贸dulo.
Librer铆a: libs/shared/types/
Ruta: libs/shared/types/src/lib/api-response.interface.ts
Tipado m谩s fuerte para error.details.
Incluir path opcional en el objeto error.
Ruta: libs/shared/types/src/lib/brand.type.ts
Considerar funciones helper para brand/unbrand (opcional).
Ruta: libs/shared/types/src/lib/correlation-id.type.ts
Resolver duplicaci贸n con primitive-types.ts (elegir una fuente can贸nica).
Ruta: libs/shared/types/src/lib/maybe.type.ts
Considerar distinci贸n Optional<T> vs Nullable<T> si es sem谩nticamente necesario.
Ruta: libs/shared/types/src/lib/paginated.interface.ts
Tipado estricto para sortBy en IPaginatedQueryParams (con gen茅ricos).
Considerar soporte para paginaci贸n basada en cursor.
Ruta: libs/shared/types/src/lib/primitive-types.ts
Resolver duplicaci贸n de CorrelationId.
Considerar IsoDateStringVO para validaci贸n en runtime.
Ruta: libs/shared/types/src/index.ts
Resolver exportaci贸n de CorrelationId (una vez resuelta duplicaci贸n).
Usar exportaciones nombradas expl铆citas.
A帽adir documentaci贸n de m贸dulo.
Librer铆a: libs/shared/utils/
Ruta: libs/shared/utils/src/lib/guard.ts
Considerar m茅todos de guarda que lancen excepciones directamente.
A帽adir m谩s type guards espec铆ficos (ej. isString, isNumber).
Clarificar/documentar comportamiento de isEmpty para objetos y en lengthIsBetween.
A帽adir tests unitarios.
Ruta: libs/shared/utils/src/lib/uuid.utils.ts
Considerar inyecci贸n de dependencia para uuidv4 (para testabilidad extrema) o mockeo est谩tico.
A帽adir tests unitarios (verificando el "branding").
Ruta: libs/shared/utils/src/index.ts
Usar exportaciones nombradas expl铆citas.
A帽adir documentaci贸n de m贸dulo.
Librer铆a: libs/shared/validation-schemas/
Ruta: libs/shared/validation-schemas/src/lib/common.schemas.ts
Refinar EmailSchema (regex m谩s robusta o advertencia).
Considerar i18n para mensajes de error de Zod.
A帽adir m谩s schemas comunes.
A帽adir tests unitarios.
Ruta: libs/shared/validation-schemas/src/lib/pagination.schemas.ts
Validaci贸n de sortBy contra campos permitidos (con gen茅ricos).
A帽adir tests unitarios.
Ruta: libs/shared/validation-schemas/src/index.ts
Usar exportaciones nombradas expl铆citas.
Considerar exportar tipos inferidos de Zod.
A帽adir documentaci贸n de m贸dulo.
Librer铆a: libs/core/domain/tenancy/
Ruta: libs/core/domain/tenancy/src/lib/entities/tenant.entity.ts
Usar VOs para planId.
Decidir y refinar manejo de TenantConfigurationEntity (agregado o entidad hija).
Asegurar que payloads de eventos emitidos sean completos y correctos.
(Tests ya implementados, pero revisar tras refactorizaciones).
Ruta: libs/core/domain/tenancy/src/lib/entities/tenant-configuration.entity.ts
Considerar emitir eventos de dominio propios.
Considerar TValue gen茅rico para value.
Decidir si es AggregateRoot o Entity hija de TenantEntity.
Ruta: Archivos de Eventos (*.event.ts) en libs/core/domain/tenancy/src/lib/events/
Enriquecer payloads (ej. TenantSuspendedEvent con raz贸n).
Resolver problemas de firma de 铆ndice en payloads si es posible con mejor tipado en DomainEventBase.
Ruta: Archivos de Errores (_.error.ts) en libs/core/domain/tenancy/src/lib/errors/
A帽adir contexto (fromStatus, toStatus, conflictingField) a la metadata de los errores.
Considerar jerarqu铆a TenancyDomainError.
Ruta: Archivos de Puertos (_.port.ts) en libs/core/domain/tenancy/src/lib/ports/
Actualizar para usar IRepositoryPort<Agg, IDType> si se implementa esa mejora.
A帽adir paginaci贸n/b煤squeda por criterios.
Librer铆a: libs/core/application/tenancy/
Ruta: libs/core/application/tenancy/src/lib/use-cases/create-tenant/create-tenant.use-case.ts
Implementar tests unitarios.
Resolver casts de ID (depende de IRepositoryPort).
Integrar UserProvisioningServicePort para ownerEmail -> UserId.
Implementar transaccionalidad/Sagas.
Validar planId.
Resolver desactivaciones ESLint para String(errorCaught).
Ruta: libs/core/application/tenancy/src/lib/use-cases/activate-tenant/activate-tenant.use-case.ts
Implementar tests unitarios (ya gener茅 esqueleto).
Resolver casts de ID.
Considerar manejo de transacciones y publicaci贸n de eventos.
A帽adir l贸gica de autorizaci贸n.
Resolver desactivaciones ESLint para String(errorCaught).
Ruta: libs/core/application/tenancy/src/lib/dtos/tenant-details.dto.ts
Usar TenantStatusEnum estrictamente para status.
A帽adir isDatabaseConfigured: boolean.
VII. Configuraciones Transversales (project.json, tsconfig.\_.json, eslint.config.mjs ra铆z)

- Actualizar passWithNoTests: true a false en project.json tras a帽adir tests.
- Habilitar declarationMap: true en todos los tsconfig.lib.json.
- Estandarizar moduleResolution: "node" en tsconfig.spec.json.
- Refinar y expandir depConstraints en eslint.config.mjs (ra铆z).
- Implementar Hooks de Git (Husky + lint-staged).

---

---
