### Deuda Técnica Registrada

*   **Librería:** `core-domain-shared-kernel-value-objects`
*   **Archivo:** `libs/core/domain/shared-kernel/value-objects/src/lib/value-object.base.ts`
*   **Problema:** Persiste un error de lint `@typescript-eslint/no-unsafe-return` en el método `unpack()` a pesar de los intentos de casteo explícito.
*   **Decisión:** Se procede desactivando temporalmente la regla ESLint para esta línea específica con una justificación en el código. Se marca como deuda técnica para revisitar. El objetivo es no bloquear el avance en la configuración de otras librerías y reglas de arquitectura.
Explicación del Archivo y la Regla (para tu comprensión y la de la IA):
Archivo: libs/core/domain/shared-kernel/value-objects/src/lib/value-object.base.ts
Propósito: Este archivo define la clase base abstracta ValueObject<TProps>. Es un bloque de construcción fundamental en Domain-Driven Design (DDD). Un Value Object representa un concepto del dominio que se define por sus atributos y no por una identidad única (a diferencia de las Entidades). Son inmutables y su igualdad se determina comparando todos sus atributos.
Funcionalidad Clave:
Asegura la inmutabilidad de sus propiedades (props) mediante Object.freeze().
Proporciona un método equals() para la comparación estructural.
Proporciona un método unpack() para obtener los valores crudos de sus propiedades.
Fuerza la validación de sus propiedades a través de un método abstracto validate() que las clases hijas deben implementar.
Maneja el concepto de IDomainPrimitive para VOs que encapsulan un solo valor primitivo.
Importancia: Permite modelar conceptos del dominio de forma más rica y segura que usando solo tipos primitivos, encapsulando lógica y validaciones.
Regla ESLint: @typescript-eslint/no-unsafe-return
Propósito: Esta regla de @typescript-eslint previene que una función o método retorne un valor de tipo any o unknown cuando se espera un tipo más específico. El objetivo es mejorar la seguridad de tipos y evitar errores en tiempo de ejecución que podrían ocurrir si se devuelve un valor de un tipo inesperado.
Por qué se activa (en nuestro caso): En el método unpack(), cuando hacemos const propsCopy = { ...objectProps }; y luego return Object.freeze(propsCopy);, aunque casteamos objectProps a Readonly<TProps> y propsCopy debería ser inferido como TProps, la combinación de genéricos (TProps), el operador spread (...), y la función Object.freeze() (que devuelve Readonly<typeof T>) puede hacer que el analizador de ESLint no esté completamente seguro del tipo final y lo trate como potencialmente "unsafe" (similar a any).
Por qué la desactivamos (temporalmente): Creemos que, en este contexto específico, el tipo TProps devuelto es correcto y la estructura coincide con lo esperado. La regla está siendo excesivamente estricta para este patrón particular. Desactivarla nos permite avanzar, pero documentamos la necesidad de revisitarlo.
---
OTRA DEUDA TECNICA
// libs/core/domain/shared-kernel/value-objects/src/lib/value-object.base.ts
import { ArgumentNotProvidedException } from '@dfs-suite/shared-errors';
import { Maybe } from '@dfs-suite/shared-types';
import { Guard } from '@dfs-suite/shared-utils';

export type Primitives = string | number | boolean;
export interface IDomainPrimitive<T extends Primitives | Date> {
  value: T;
}

type ValueObjectPropsType<P> = P extends Primitives | Date ? IDomainPrimitive<P> : P;

export abstract class ValueObject<TProps> {
  protected readonly props: Readonly<ValueObjectPropsType<TProps>>;

  constructor(props: ValueObjectPropsType<TProps>) {
    this.checkIfEmpty(props);
    this.validate(props);
    this.props = Object.freeze(props);
  }

  protected abstract validate(props: ValueObjectPropsType<TProps>): void;

  static isValueObject(obj: unknown): obj is ValueObject<unknown> {
    return obj instanceof ValueObject;
  }

  public equals(vo?: Maybe<ValueObject<TProps>>): boolean {
    if (Guard.isNil(vo)) {
      return false;
    }
    if (this.constructor.name !== vo.constructor.name) {
        return false;
    }
    return JSON.stringify(this.props) === JSON.stringify(vo.props);
  }

  public unpack(): TProps {
    if (this.isDomainPrimitive(this.props)) {
      return this.props.value;
    }

    const objectProps = this.props as Readonly<TProps>;
    const propsCopy = { ...objectProps };

    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
    return Object.freeze(propsCopy);
  }

  private checkIfEmpty(props: ValueObjectPropsType<TProps>): void {
    if (
      Guard.isEmpty(props) ||
      (this.isDomainPrimitive(props) && Guard.isEmpty(props.value))
    ) {
      throw new ArgumentNotProvidedException(
        `${this.constructor.name} props cannot be empty`,
      );
    }
  }

  private isDomainPrimitive(
    obj: unknown,
  ): obj is IDomainPrimitive<TProps & (Primitives | Date)> {
    return typeof obj === 'object' && obj !== null && Object.prototype.hasOwnProperty.call(obj, 'value');
  }
}
// libs/core/domain/shared-kernel/value-objects/src/lib/value-object.base.ts
/* SECCIÓN DE MEJORAS

[
  Mejora propuesta 1: El método `equals` podría ser más robusto si TProps contiene objetos anidados o Dates, ya que `JSON.stringify` puede tener comportamientos inesperados con Dates o perder funciones. Considerar una comparación profunda si es necesario, o requerir que las TProps sean serializables a JSON de forma predecible. Para Dates, sería mejor compararlas individualmente.
]
[
  Mejora propuesta 2: Para `unpack()`, si `TProps` es un primitivo (y no un `IDomainPrimitive`), la lógica actual podría no ser la más directa. Sin embargo, la restricción `ValueObjectPropsType<P> = P extends Primitives | Date ? IDomainPrimitive<P> : P;` asegura que si `TProps` es un primitivo, `this.props` será del tipo `IDomainPrimitive`.
]

*/

/* NOTAS PARA IMPLEMENTACIÓN FUTURA

[
  Nota estratégica 1: La inmutabilidad profunda de `props` en el constructor mediante `Object.freeze(props)` es una buena práctica. Si `TProps` puede contener objetos anidados, se podría considerar un `deepFreeze` si la complejidad lo justifica y no impacta demasiado el rendimiento en la creación de VOs.
]
[
  Nota estratégica 2: El método `isDomainPrimitive` asume que un `IDomainPrimitive` siempre tendrá una propiedad `value`. Esto es consistente con su definición.
]

*/

/* REGISTRO DE DEUDA TÉCNICA Y ANOTACIONES DE LINTING

[
  **Deuda Técnica Registrada (2025-05-12):**
    *   **Archivo:** `libs/core/domain/shared-kernel/value-objects/src/lib/value-object.base.ts`
    *   **Regla ESLint Involucrada:** `@typescript-eslint/no-unsafe-return`
    *   **Problema:** La regla se activa en el método `unpack()` en la línea `return Object.freeze(propsCopy);`. Aunque se espera que `propsCopy` sea del tipo `TProps` (el tipo genérico de las propiedades del Value Object), la combinación de genéricos, el operador spread y `Object.freeze()` (que devuelve `Readonly<typeof T>`) hace que el analizador de ESLint no pueda garantizar completamente el tipo de retorno, tratándolo como potencialmente "unsafe" (similar a `any` o `unknown`).
    *   **Acción Tomada:** Se desactivó la regla ESLint para esta línea específica (`// eslint-disable-next-line @typescript-eslint/no-unsafe-return`) para permitir el avance del proyecto.
    *   **Justificación para la Desactivación Temporal:**
        1.  Se considera que, en el contexto de este patrón de Value Object, la estructura de `propsCopy` coincide con `TProps`, y `Object.freeze` solo añade inmutabilidad sin alterar la estructura de datos fundamental que se espera retornar.
        2.  La regla, en este caso particular con genéricos y transformaciones de inmutabilidad, parece ser excesivamente estricta.
        3.  Evitar el bloqueo del desarrollo de otras funcionalidades y la configuración arquitectónica.
    *   **Tarea Pendiente (Deuda Técnica):**
        1.  Investigar si existe una forma de tipado más explícita o un patrón de refactorización para el método `unpack()` que satisfaga la regla `@typescript-eslint/no-unsafe-return` sin comprometer la funcionalidad o la claridad.
        2.  Evaluar si la desactivación de la regla para esta línea es la solución pragmática más aceptable a largo plazo si no se encuentra una alternativa de tipado superior.
        3.  Considerar si el tipo de retorno de `unpack()` debería ser `Readonly<TProps>` para alinearse mejor con `Object.freeze`, y ajustar los consumidores si es necesario.
]

*/
---
