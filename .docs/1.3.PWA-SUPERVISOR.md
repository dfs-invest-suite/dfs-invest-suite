15hDKywdfm0FtOjqbVhpvTHzavRg2WSrb .dev3
**PARTE V: DISEÑO DETALLADO DE LAS APLICACIONES (APPS/)**

**V.B. Aplicación: **pwa-supervisor** (Portal para Supervisores/Administradores de Tenant)**
Ubicación: apps/pwa-supervisor/
Tecnología Frontend: Next.js (v14+, App Router), React (v18+), TypeScript, Tailwind CSS, Shadcn/UI, TanStack Query (React Query) para data fetching/mutations, Zustand para estado global de UI.
Tecnología Backend Consumida: api-main (NestJS, GraphQL).
Propósito: Interfaz web principal para que los administradores y supervisores de un tenant específico gestionen y monitoreen su operación de leads, comunicación WhatsApp, consultores, y configuración.
Autenticación: Flujo de login con api-main que devuelve un JWT. Este JWT contiene userId, tenantId, y role (ej. TENANT_ADMIN, SUPERVISOR). El token se almacena de forma segura (HttpOnly cookie o LocalStorage con precauciones) y se envía en cada solicitud GraphQL a api-main.

**V.B.1. Diseño del Backend (Lógica en api-main para Soportar pwa-supervisor)**
La pwa-supervisor interactúa principalmente con api-main a través de GraphQL. Necesitaremos definir los siguientes tipos, queries, mutations y subscriptions en nuestros módulos de api-main/src/domains/.
Autenticación y Gestión de Usuarios del Tenant (Módulo users-roles en api-main):
Types GraphQL: UserTenant, RoleTenant, AuthTenantPayload.
Mutations:
loginTenantUser(email, password): AuthTenantPayload
createTenantUser(tenantId, name, email, role, password): UserTenant (Solo para TENANT_ADMIN)
updateTenantUser(tenantId, userId, name?, role?, isActive?): UserTenant
deleteTenantUser(tenantId, userId): Boolean
changeTenantUserPassword(oldPassword, newPassword): Boolean
Queries:
meTenant: UserTenant (Devuelve el usuario autenticado actual).
listTenantUsers(tenantId, filters?): PaginatedUsersTenant
getTenantUser(tenantId, userId): UserTenant
Lógica de Caso de Uso Subyacente (libs/application/users-roles/):
AuthenticateTenantUserUseCase, CreateTenantUserUseCase, UpdateTenantUserUseCase, etc.
Todos operan en la DB del tenant (contextualizado por tenantId del JWT).
Gestión de Leads (Módulo leads-flow en api-main):
Types GraphQL: Lead, LeadInteraction, LeadStatus, LeadScoreHistory, LeadFilterInput, PaginatedLeads.
Mutations:
importLeadsFromExcel(tenantId, file: Upload!): ImportSummary (Usa IImportLeadsUseCase).
assignLeadToConsultant(tenantId, leadId, consultantUserId): Lead
updateLeadStatus(tenantId, leadId, newStatus): Lead
addNoteToLead(tenantId, leadId, noteContent): LeadInteraction
Queries:
listLeads(tenantId, filters: LeadFilterInput, pagination): PaginatedLeads
getLeadDetails(tenantId, leadId): Lead (con todas sus interacciones, historial de score, etc.)
Subscriptions:
leadUpdated(tenantId, leadId): Lead (Para actualizaciones en tiempo real).
newLeadAssigned(tenantId, consultantUserId): Lead
Lógica de Caso de Uso Subyacente (libs/application/leads-flow/):
ImportLeadsUseCase, AssignLeadUseCase, GetLeadDetailsUseCase, ListLeadsUseCase.
Gestión y Monitoreo de WhatsApp (Módulos whatsapp y anti-ban en api-main):
Types GraphQL: WhatsAppAccountStatus, MessageTemplateRecordApi, WhatsAppCostSummary, WhatsAppHealthKPIs.
Mutations:
sendTemplateMessageToLead(tenantId, leadId, templateName, language, componentsData, requestedAccountId?): SendMessageApiResult (Llama a ISendWhatsAppMessageUseCase).
createMessageTemplateForTenant(tenantId, templateCreationInput: WhatsAppTemplateCreationApiRequest!): MessageTemplateRecordApi (Llama a IManageWhatsAppTemplateUseCase.create).
updateWhatsAppAccountOperationalStatus(tenantId, phoneNumberId, newStatus: EInternalOperationalStatus): WhatsAppAccountStatus (Llama a IAccountHealthManagerServicePort.setManualOperationalStatus).
Queries:
listTenantWhatsAppAccounts(tenantId): [WhatsAppAccountStatus] (Llama a ISyncWhatsAppAssetsUseCase o un UC de consulta que usa IWhatsAppAccountRepository).
getTenantWhatsAppAccountDetails(tenantId, phoneNumberId): WhatsAppAccountStatus
listTenantMessageTemplates(tenantId, filters?): PaginatedMessageTemplates (Llama a IManageWhatsAppTemplateUseCase.list).
getTenantWhatsAppCostReport(tenantId, dateRange, groupBy?): WhatsAppCostSummary (Llama a IGetTenantCostReportUseCase).
getTenantWhatsAppHealthKPIs(tenantId): WhatsAppHealthKPIs (Agregado de varios servicios).
Subscriptions:
whatsAppAccountHealthUpdated(tenantId, phoneNumberId?): WhatsAppAccountStatus
messageTemplateStatusChangedForTenant(tenantId, templateId): MessageTemplateRecordApi
newMessageStatusForLead(tenantId, leadId, waMessageId): MessageLog
Lógica de Caso de Uso Subyacente (libs/application/whatsapp/, libs/application/anti-ban/, libs/application/billing/):
SendWhatsAppMessageUseCase, ManageWhatsAppTemplateUseCase, AccountHealthManagerService, CostCalculationService, SyncWhatsAppAssetsUseCase.
Configuración del Tenant (Módulo tenancy en api-main):
Types GraphQL: TenantConfiguration, TenantWhatsAppCredentialsInput.
Mutations:
updateTenantWhatsAppConfiguration(tenantId, input: TenantWhatsAppCredentialsInput): TenantConfiguration (Llama a ISetTenantWhatsAppConfigUseCase).
Queries:
getTenantConfiguration(tenantId): TenantConfiguration (Devuelve datos no sensibles, ej. WABA ID, lista de números registrados en la suite, pero NO el token).

**V.B.2. Diseño del Frontend (apps/pwa-supervisor)**
Arquitectura General Frontend:
Next.js App Router para estructura de rutas y componentes Server/Client.
Componentes React (construidos con Tailwind CSS y componentes base de Shadcn/UI).
Librería ui-shared para componentes comunes (botones, tablas, modales, inputs).
TanStack Query (React Query) para todo el data fetching y mutations con la API GraphQL de api-main. Manejo de cache, invalidación, optimistic updates.
Zustand para estado global de UI (ej. usuario autenticado, tenantId, tema, notificaciones UI).
Cliente Apollo GraphQL (o un wrapper simple sobre fetch para GraphQL) para interactuar con api-main.
Cliente Socket.io para conectar con el gateway de api-main y recibir actualizaciones en tiempo real.
Estructura de Directorios (apps/pwa-supervisor/src/app/):
(auth)/ (Grupo de rutas para login, forgot password, etc. - sin layout principal).
(app)/ (Grupo de rutas protegidas con el layout principal de la aplicación).
layout.tsx (Layout principal con sidebar, navbar, TenantContext provider para UI).
dashboard/page.tsx (Página principal con KPIs).
leads/
page.tsx (Lista de leads, filtros, paginación).
[leadId]/page.tsx (Detalle del lead, historial, interacciones).
import/page.tsx (UI para importación de Excel).
whatsapp/
accounts/page.tsx (Lista de números WA del tenant, estado, calidad, límites).
templates/page.tsx (Listar plantillas del tenant, opción de crear/editar - Post-MVP).
analytics/page.tsx (Dashboard de costos WA del tenant, uso de plantillas).
consultants/page.tsx (Gestión de usuarios consultores del tenant).
settings/page.tsx (Configuración del tenant, ej. credenciales WA).
Componentes UI Clave (Muchos podrían venir de libs/ui-shared/):
Layouts: SidebarLayout, PageHeader.
Tablas de Datos: Componente de tabla reutilizable con paginación, ordenamiento, filtros (basado en TanStack Table y Shadcn).
Formularios: Componentes de input, select, date picker (Shadcn) con integración react-hook-form y validación Zod/Valibot.
Gráficos: (Recharts, Nivo) para KPIs y analíticas.
Modales y Diálogos: Para confirmaciones, edición, etc.
Indicadores de Estado/Calidad: Componentes visuales para EWhatsAppQualityRating, EInternalOperationalStatus.
Notificaciones Toast/In-App: Para alertas y feedback de acciones.
Flujos de Usuario Clave:
Login: Usuario ingresa credenciales -> PWA llama a mutación loginTenantUser -> Si éxito, guarda JWT y redirige al dashboard.
Ver Lista de Leads: Carga página -> React Query llama a query listLeads -> Muestra datos en tabla. Filtros actualizan la query.
Enviar Plantilla a Lead (desde detalle del lead):
UI muestra selector de plantillas (poblado por listTenantMessageTemplates).
Supervisor selecciona plantilla, completa variables.
PWA llama a mutación sendTemplateMessageToLead con tenantId, leadId, datos de plantilla.
Backend (vía SendWhatsAppMessageUseCase) procesa.
PWA muestra feedback (Encolado/Error).
Webhook de estado actualiza el MessageLog. PWA recibe actualización vía WebSocket y muestra checkmarks.
Crear Plantilla (Post-MVP): Formulario complejo -> PWA llama a createMessageTemplateForTenant -> Backend procesa -> PWA muestra estado de la nueva plantilla (PENDING). Webhook actualiza.
Ver Alerta de Calidad de Número: Notificación WebSocket/Push -> Supervisor navega a whatsapp/accounts -> Ve el número marcado en ROJO, con detalles del problema.
Consideraciones de Diseño para pwa-supervisor:
Mobile-First Responsivo: Aunque se use mucho en desktop, debe ser usable en tablets y móviles.
Performance: Carga rápida, optimización de queries GraphQL, virtualización para listas largas.
Seguridad Frontend: Proteger contra XSS, asegurar que el JWT no sea fácilmente accesible.
UX: Clara, intuitiva, con feedback inmediato de las acciones. Priorizar la información más relevante.
(Continuará con el detalle de pwa-consultant y admin-platform, y luego las secciones finales del Blueprint: Políticas, Pruebas (ya revisadas), Configuración de Entorno (ya revisada), Roadmap Final, y el Glosario Técnico Detallado, en los próximos prompts).
Esta descripción de la pwa-supervisor y su interacción con api-main proporciona una base sólida para su desarrollo. La clave es la clara definición de las queries y mutations GraphQL que necesitará y la gestión eficiente del estado con React Query y Zustand. ¿Continuamos con las otras PWAs?

---

Análisis de pwa-supervisor
Estructura general del proyecto

Es un monorepo NX con arquitectura DDD (Domain-Driven Design) hexagonal
La aplicación específica es pwa-supervisor, ubicada en apps/pwa-supervisor/

Tecnologías principales

Frontend: Next.js (v14+, App Router), React (v18+), TypeScript, Tailwind CSS, Shadcn/UI
Gestión de estado: TanStack Query para data fetching/mutations, Zustand para estado global de UI
Backend consumido: api-main (NestJS, GraphQL)

Propósito de pwa-supervisor
Es una interfaz web para que administradores y supervisores de un tenant específico puedan:

Gestionar y monitorear operación de leads
Controlar comunicación WhatsApp
Administrar consultores
Configurar el tenant

Autenticación

Flujo de login con api-main que devuelve un JWT
JWT contiene userId, tenantId y role (TENANT_ADMIN, SUPERVISOR)
Token se almacena de forma segura y se envía en cada solicitud GraphQL

Principales módulos y funcionalidades

Autenticación y gestión de usuarios

Login/logout
CRUD de usuarios del tenant
Gestión de roles y permisos

Gestión de leads

Listado y filtrado de leads
Importación desde Excel
Asignación a consultores
Actualización de estado y notas

Gestión y monitoreo de WhatsApp

Estado de cuentas WhatsApp
Plantillas de mensajes
Envío de mensajes a leads
Reportes de costos y KPIs de salud

Configuración del tenant

Configuración de WhatsApp
Ajustes generales del tenant

Estructura del frontend (Next.js App Router)

(auth)/ - Grupo de rutas para login/recuperar contraseña
(app)/ - Rutas protegidas con layout principal

dashboard/ - KPIs principales
leads/ - Gestión de leads
whatsapp/ - Gestión de WhatsApp
consultants/ - Gestión de usuarios consultores
settings/ - Configuración del tenant

Interacción con el backend

Comunicación principalmente mediante GraphQL (api-main)
Queries, mutations y subscriptions para cada dominio
WebSockets para actualizaciones en tiempo real

Consideraciones de diseño

Diseño mobile-first responsivo
Optimización de performance
Seguridad frontend
UX clara e intuitiva con feedback inmediato

---

---

Análisis del proyecto pwa-supervisor y la biblioteca ui-shared
Estructura y lógica general
Arquitectura

Monorepo NX con DDD hexagonal: Organización clara con separación de dominios y capas
pwa-supervisor: Aplicación web para administradores/supervisores de tenant
ui-shared: Biblioteca compartida de componentes de UI basados en Shadcn/UI

Tecnologías clave

Frontend: Next.js (App Router), React, TypeScript, Tailwind CSS
Gestión de estado: TanStack Query para datos y Zustand para UI
Backend: API GraphQL (NestJS)
Componentes UI: Shadcn adaptados en la biblioteca ui-shared

Análisis de ui-shared
La biblioteca ui-shared tiene una estructura simple pero efectiva:

Componentes UI base (alert, button, card, input, label) basados en Shadcn/UI
Sistema de utilidades para clases CSS (cn)
Configuración de Tailwind con tema personalizable (claro/oscuro)

Estos componentes siguen patrones modernos:

Uso de React.forwardRef para pasar referencias
Componentes atómicos con variantes mediante class-variance-authority
Integración con Tailwind CSS y configuración de temas
Soporte para polimorfismo (asChild con Radix Slot)

Ideas para el desarrollo de pwa-supervisor

1. Arquitectura de Frontend

Estructura de carpetas: Seguir la estructura App Router de Next.js
app/
├── (auth)/ # Rutas de autenticación
├── (app)/ # Rutas protegidas
│ ├── dashboard/
│ ├── leads/
│ ├── whatsapp/
│ ├── consultants/
│ └── settings/
├── api/ # API handlers
└── layout.tsx # Layout principal

2. Gestión de estado

TanStack Query: Para todos los datos de API GraphQL

Crear hooks personalizados por dominio (useLeads, useWhatsApp, etc.)
Implementar lógica de caché e invalidación inteligente

Zustand: Para estado global de UI

Store para autenticación (usuario actual, tenant)
Store para configuración de UI (tema, preferencias)
Store para notificaciones temporales

3. Componentes UI específicos

Layouts y páginas:

Layout principal con sidebar, navbar y área de contenido
Componentes de páginas con estructura consistente

Componentes de dominio:

LeadTable: Tabla avanzada para gestión de leads
WhatsAppAccountCard: Visualización de estado de cuentas WhatsApp
TemplateBuilder: Constructor de plantillas de mensajes
Dashboard: Widgets y KPIs personalizables

4. Autenticación y seguridad

Flujo de autenticación:

Middleware de Next.js para protección de rutas
Gestión de JWT con HttpOnly cookies
Refresh token para sesiones duraderas

5. Comunicación con el backend

Cliente GraphQL:

Configuración de cliente Apollo o URQL
Custom hooks para cada query/mutation
TypeScript completo con tipos generados

WebSockets:

Cliente Socket.io para suscripciones en tiempo real
Sistema de notificaciones push para alertas importantes

6. Consideraciones de UX/UI

Temas y diseño:

Sistema de diseño consistente basado en ui-shared
Modo oscuro/claro con persistencia
Responsividad desde móvil a desktop

Feedback y estados:

Loaders y skeletons para estados de carga
Notificaciones toast para acciones completadas
Manejo de errores con mensajes contextuales

Accesibilidad:

Asegurar que todos los componentes sean accesibles
Navegación por teclado completa
Contraste y legibilidad adecuados

7. Optimización de rendimiento

Server Components:

Uso estratégico de componentes de servidor en Next.js
Data fetching en capa de servidor para reducir JS cliente

Carga progresiva:

Lazy loading para secciones pesadas
Estrategia de carga de datos por prioridad

8. Internacionalización

Sistema i18n:

Preparar la aplicación para soportar múltiples idiomas
Extraer textos a archivos de traducción

9. Pruebas

Estrategia de testing:

Unit tests para lógica de negocio
Pruebas de integración para flujos principales
Tests de componentes con React Testing Library

10. CI/CD e infraestructura

Pipeline de Nx:

Configurar despliegue automático
División de entornos (dev, staging, prod)

## Estas ideas proporcionan un marco sólido para comenzar el desarrollo del frontend pwa-supervisor, alineado con la arquitectura existente y aprovechando la biblioteca ui-shared ya establecida.

---

Arquitectura de PWA-Supervisor: Diseño y Estructura Técnica
Estructura del Proyecto
apps/pwa-supervisor/
├── public/
│ ├── fonts/
│ ├── images/
│ ├── manifest.json
│ ├── favicon.ico
│ └── robots.txt
├── src/
│ ├── app/
│ │ ├── (auth)/
│ │ │ ├── login/
│ │ │ ├── forgot-password/
│ │ │ └── layout.tsx
│ │ ├── (app)/
│ │ │ ├── dashboard/
│ │ │ ├── leads/
│ │ │ │ ├── page.tsx
│ │ │ │ ├── [leadId]/
│ │ │ │ └── import/
│ │ │ ├── whatsapp/
│ │ │ │ ├── accounts/
│ │ │ │ ├── templates/
│ │ │ │ └── analytics/
│ │ │ ├── consultants/
│ │ │ ├── settings/
│ │ │ └── layout.tsx
│ │ ├── api/
│ │ │ └── gql/
│ │ │ └── route.ts
│ │ ├── branding/
│ │ │ └── page.tsx
│ │ ├── layout.tsx
│ │ └── page.tsx
│ ├── components/
│ │ ├── analytics/
│ │ ├── auth/
│ │ ├── consultants/
│ │ ├── dashboard/
│ │ ├── layout/
│ │ │ ├── AppLayout.tsx
│ │ │ ├── Sidebar.tsx
│ │ │ ├── TopNav.tsx
│ │ │ └── MobileNav.tsx
│ │ ├── leads/
│ │ ├── settings/
│ │ ├── ui/
│ │ │ ├── data-display/
│ │ │ ├── feedback/
│ │ │ ├── navigation/
│ │ │ └── templates/
│ │ └── whatsapp/
│ ├── hooks/
│ │ ├── api/
│ │ │ ├── useAuth.ts
│ │ │ ├── useLeads.ts
│ │ │ ├── useWhatsapp.ts
│ │ │ ├── useTenant.ts
│ │ │ └── useConsultants.ts
│ │ ├── ui/
│ │ │ ├── useMediaQuery.ts
│ │ │ ├── useLocalStorage.ts
│ │ │ └── useToast.ts
│ │ └── animations/
│ │ ├── useAnimationPresets.ts
│ │ └── useSmoothTransition.ts
│ ├── lib/
│ │ ├── api/
│ │ │ ├── client.ts
│ │ │ ├── mutations/
│ │ │ ├── queries/
│ │ │ └── subscriptions/
│ │ ├── animations/
│ │ │ ├── transitions.ts
│ │ │ └── motion.ts
│ │ ├── auth/
│ │ │ ├── authOptions.ts
│ │ │ └── middleware.ts
│ │ ├── socket/
│ │ │ └── client.ts
│ │ └── utils/
│ │ ├── format.ts
│ │ └── validators.ts
│ ├── store/
│ │ ├── auth.ts
│ │ ├── ui.ts
│ │ ├── notifications.ts
│ │ └── index.ts
│ ├── styles/
│ │ ├── animations.css
│ │ └── tenant-theme.css
│ ├── themes/
│ │ ├── base.ts
│ │ └── tenant.ts
│ └── types/
│ ├── auth.ts
│ ├── leads.ts
│ ├── whatsapp.ts
│ ├── tenant.ts
│ └── consultants.ts
├── .eslintrc.js
├── jest.config.ts
├── next.config.js
├── package.json
├── project.json
├── tailwind.config.js
└── tsconfig.json
Tecnologías y Librerías
Core

Next.js 15: Framework React con App Router y Server Components
React 18+: Con Hooks avanzados y patrones modernos
TypeScript: Tipado estático para desarrollo robusto

Estilos y UI

Tailwind CSS 3.4+: Utilidades CSS para estilado rápido
Shadcn/UI: Componentes base desde ui-shared
Framer Motion: Animaciones avanzadas y transiciones fluidas
Tailwind Variants: Variantes condicionales simplificadas
Tailwind Animate: Animaciones predefinidas para Tailwind

Gestión de Estado

TanStack Query 5: Data fetching, caché y sincronización
Zustand 4.4+: Estado global minimalista
Immer: Actualizaciones inmutables simplificadas

Comunicación de Red

GraphQL: Con codegen para tipos TypeScript
Apollo Client: Cliente GraphQL robusto
Socket.io-client: Para comunicación en tiempo real

Formularios y Validación

React Hook Form: Gestión de formularios de alto rendimiento
Zod: Validación de esquemas con inferencia de tipos

Utilidades y Optimización

date-fns: Manipulación de fechas
Recharts: Visualización de datos
@tanstack/virtual: Virtualización para listas largas
next-themes: Soporte para temas (claro/oscuro)
@vercel/analytics: Analítica integrada

Características Técnicas
Rendimiento y Optimización

Server Components para reducir JS del cliente
Estrategia de ISR/SSG para páginas estáticas
Optimización de imágenes con next/image
Virtualización para listas largas (leads)
Code splitting y lazy loading

Experiencia de Usuario

Navegación instantánea con next/link
Animaciones optimizadas para 60fps
Sistema de feedbacks multimodal (visual, sonoro, táctil)
Transiciones suaves entre rutas
Estados de carga (skeletons) diseñados

Diseño Responsivo

Mobile-first con breakpoints estratégicos
Navegación adaptativa (sidebar/bottom nav)
Tablas responsivas con visualizaciones alternativas
Grid adaptativo para dashboards

Accesibilidad

ARIA labels y roles semánticos
Soporte completo de navegación por teclado
Gestión de foco para modales y diálogos
Alto contraste para modo oscuro

Seguridad

Manejo seguro de JWT en HttpOnly cookies
Prevención de XSS/CSRF
Middleware para protección de rutas
Sanitización de inputs

CI/CD e Infraestructura

Integración con Nx para build optimizado
Despliegue automático en Vercel
Configuración de Edge functions para optimización regional
Análisis de bundle size

Estrategias Específicas para PWA-Supervisor
Autenticación y Autorización

Flujo JWT con refresh tokens
Roles y permisos basados en tenant
Persistencia segura de sesión

Gestión de Leads

Filtrado y ordenamiento avanzado client-side
Virtualización para grandes conjuntos de datos
Sistema de etiquetado visual por estado/prioridad

Dashboard Analytics

Gráficos interactivos con Recharts
KPIs con animaciones de contador
Filtros temporales (día/semana/mes/trimestre)

WhatsApp Manager

Estado visual de cuentas con indicadores de salud
Preview interactivo de plantillas
Notificaciones en tiempo real para cambios de estado

Experiencia de Marca (Branding)

Tema personalizable por tenant
Variables CSS para colores primarios/secundarios
Sistema de tipografía personalizable

---

---

// libs/ui-shared/src/components/ui/card-hover.tsx
'use client';

import \* as React from 'react';
import { cn } from '../../lib/utils';
import { motion, useMotionTemplate, useMotionValue } from 'framer-motion';

export interface CardHoverProps extends React.HTMLAttributes<HTMLDivElement> {
gradient?: boolean;
spotlight?: boolean;
border?: boolean;
children: React.ReactNode;
}

const CardHover = React.forwardRef<HTMLDivElement, CardHoverProps>(
({ className, gradient = true, spotlight = true, border = true, children, ...props }, ref) => {
const mouseX = useMotionValue(0);
const mouseY = useMotionValue(0);

    function handleMouseMove({ currentTarget, clientX, clientY }: React.MouseEvent) {
      const { left, top } = currentTarget.getBoundingClientRect();
      mouseX.set(clientX - left);
      mouseY.set(clientY - top);
    }

    return (
      <div
        ref={ref}
        className={cn(
          'group relative w-full rounded-lg bg-card p-0.5 transition-all duration-300 hover:shadow-xl',
          border && 'border border-border/40 hover:border-border/80',
          className
        )}
        onMouseMove={handleMouseMove}
        {...props}
      >
        {/* Gradient overlay */}
        {gradient && (
          <motion.div
            className="pointer-events-none absolute -inset-px z-0 rounded-lg opacity-0 transition-opacity duration-300 group-hover:opacity-100"
            style={{
              background: useMotionTemplate`
                radial-gradient(
                  300px circle at ${mouseX}px ${mouseY}px,
                  rgba(var(--primary-rgb)/0.1),
                  transparent 80%
                )
              `,
            }}
          />
        )}

        {/* Spotlight effect */}
        {spotlight && (
          <motion.div
            className="pointer-events-none absolute -inset-px z-10 rounded-lg opacity-0 mix-blend-overlay transition-opacity duration-300 group-hover:opacity-100"
            style={{
              background: useMotionTemplate`
                radial-gradient(
                  120px circle at ${mouseX}px ${mouseY}px,
                  rgba(255, 255, 255, 0.8),
                  transparent 80%
                )
              `,
            }}
          />
        )}

        {/* Card content */}
        <div className="relative z-20 rounded-[calc(0.5rem-1px)] bg-card p-6">
          {children}
        </div>
      </div>
    );

}
);

CardHover.displayName = 'CardHover';

## export { CardHover };

---

// apps/pwa-supervisor/src/app/layout.tsx
import type { Metadata, Viewport } from 'next';
import { Inter as FontSans } from 'next/font/google';
import '../styles/globals.css';

// Importamos los estilos de ui-shared
import 'ui-shared/src/styles/globals.css';

// Providers
import { Providers } from '../components/providers';
import { cn } from 'ui-shared/src/lib/utils';

// Fuente principal
const fontSans = FontSans({
subsets: ['latin'],
variable: '--font-sans',
});

export const metadata: Metadata = {
title: {
default: 'Portal para Supervisores | DFS Invest',
template: '%s | DFS Invest',
},
description: 'Portal para supervisores y administradores',
icons: {
icon: '/favicon.ico',
},
};

export const viewport: Viewport = {
themeColor: [
{ media: '(prefers-color-scheme: light)', color: 'white' },
{ media: '(prefers-color-scheme: dark)', color: '#09090b' }
],
width: 'device-width',
initialScale: 1,
maximumScale: 1,
};

export default function RootLayout({
children,
}: {
children: React.ReactNode;
}) {
return (

<html lang="es" suppressHydrationWarning>
<body
className={cn(
'min-h-screen bg-background font-sans antialiased',
fontSans.variable
)} >
<Providers>{children}</Providers>
</body>
</html>
);
}

---

---

¡Tienes toda la razón! Pido disculpas por ese error. Mi objetivo es proporcionar un blueprint cohesivo y autocontenido basado en el contexto acumulado, sin depender de referencias a interacciones pasadas que podrían generar confusión.
Vamos a reiniciar la creación del Blueprint Maestro v3.5 (Conceptual y Granular) para dfs-invest-suite, asegurándome de que cada sección sea completa, detallada y no haga referencias a "secciones anteriores" de nuestra conversación, sino que construya sobre la información ya consolidada.
Blueprint Maestro v3.5: dfs-invest-suite (Conceptual y Granular - Versión Pura)
SECCIÓN 1: VISIÓN ARQUITECTÓNICA GLOBAL (REFINADA Y COMPLETA)
1.1. Propósito Central y Alcance de dfs-invest-suite:
dfs-invest-suite es una plataforma Software as a Service (SaaS) multi-tenant diseñada para transformar la manera en que las empresas, con un enfoque inicial en el sector inmobiliario y Sociedades de Propósito Específico (SPEs), operan y crecen. La suite tiene como objetivo centralizar y optimizar procesos críticos a través de cuatro pilares fundamentales:
Gestión Avanzada de Leads: Implementar un ciclo de vida completo para los leads, desde su captación multi-fuente (incluyendo portales inmobiliarios y campañas de marketing), pasando por una calificación inteligente y personalizable (asistida por reglas de negocio y la IA "Aiper Assistance"), un nurturing automatizado y contextualizado, hasta la asignación eficiente a consultores y el seguimiento de su conversión.
Comunicación Optimizada y Segura vía WhatsApp: Utilizar la API Oficial de WhatsApp Cloud para todas las interacciones, respaldada por un sofisticado sistema Anti-Ban. Esto incluye la gestión integral de números de teléfono del tenant (monitoreo de salud, calidad, límites), la creación, aprobación y uso estratégico de plantillas de mensajes (Marketing, Utilidad, Autenticación) y el análisis de costos y rendimiento de la comunicación.
Asistencia Inteligente Personalizada ("Aiper Assistance"): Integrar una capa de inteligencia artificial ("Aiper") que se personaliza para cada tenant. Aiper asistirá a los supervisores y (futuramente) consultores en el análisis de datos, generación de contenido (ej. borradores de plantillas, respuestas a leads), automatización de tareas, y proporcionará insights accionables basados en la información del tenant.
Presencia y Gestión de Contenido Online (portal-imoveis): Facilitar a cada tenant la capacidad de gestionar y publicar contenido en un micrositio dedicado dentro de la plataforma portal-imoveis (o un portal individualizado). Esto incluye la información de la empresa, listados de propiedades/SPEs con detalles, imágenes y documentos, y una personalización básica de la apariencia del micrositio.
La suite se entregará a través de un conjunto de Aplicaciones Web Progresivas (PWAs) interconectadas y una robusta API central (api-main), asegurando una experiencia de usuario moderna, eficiente y adaptada a los diferentes roles dentro de la organización del tenant y de la propia plataforma dfs-invest-suite.
1.2. Principios Arquitectónicos Fundamentales:
Monorepo Nx: El código fuente completo de la suite reside en un único monorepo gestionado por Nx. Esto facilita la compartición de código entre librerías y aplicaciones, asegura la consistencia de herramientas y configuraciones, y optimiza los procesos de build, test y linting.
Arquitectura Hexagonal (Puertos y Adaptadores) con DDD:
Capa de Dominio (libs/core/domain/): Contiene la lógica de negocio pura, el conocimiento del dominio, las entidades (ej. TenantEntity, LeadEntity, WhatsAppAccount, MessageTemplateRecord), Value Objects (ej. TenantStatusVO, WhatsAppQualityRatingVO), eventos de dominio y los puertos (interfaces) que el dominio necesita para interactuar con el exterior (ej. ITenantRepository, IWhatsAppMessagePort, ILeadRepository). Esta capa es agnóstica a frameworks y tecnologías externas.
Capa de Aplicación (libs/core/application/): Orquesta los flujos de trabajo y casos de uso (ej. CreateTenantUseCase, SendWhatsAppMessageUseCase, QualifyLeadUseCase, PublishPropertyToPortalUseCase). Define y maneja Comandos y Queries. Utiliza los puertos del dominio y define puertos para servicios de infraestructura que necesita. Es agnóstica al framework de entrega.
Capa de Infraestructura (libs/infrastructure/): Provee las implementaciones concretas (adaptadores) de los puertos definidos en las capas de dominio y aplicación. Interactúa con tecnologías específicas: PostgreSQL (con Prisma), Redis (con BullMQ para colas, y para caché), APIs de Meta (WhatsApp Cloud y Admin API), APIs de IA (Google Gemini), servicios de logging (Pino), etc.
Capa Compartida Global (libs/shared/): Alberga tipos TypeScript, utilidades puras, constantes, clases de error base, y el patrón Result<T,E>, siendo reutilizable por todas las demás capas sin introducir dependencias de negocio o infraestructura.
Capa de UI Compartida (libs/ui-shared/): Contiene componentes UI React base (construidos con Shadcn/UI y Tailwind CSS) reutilizables por todas las PWAs, asegurando consistencia visual y acelerando el desarrollo frontend.
SaaS Multi-Tenant con Aislamiento Fuerte:
Base de Datos por Tenant: Cada tenant opera sobre su propia base de datos PostgreSQL aislada, garantizando la privacidad y seguridad de sus datos. api-main utiliza un PrismaService dinámico para conectarse a la base de datos correcta según el contexto del tenant.
Configuración Segura del Tenant: Las credenciales sensibles (ej. tokens de API de WhatsApp, connection strings de DB) se almacenan encriptadas (AES-256 con clave maestra de plataforma) en una base de datos de plataforma centralizada, asociadas al tenantId.
Almacenamiento de Assets Aislado: Los archivos subidos por los tenants (logos, imágenes para el portal, etc.) se almacenan en un servicio de storage (ej. S3, GCS) en rutas/buckets aislados por tenantId.
Contexto de Tenant en api-main: Un TenantContextService y middleware asociado aseguran que todas las operaciones en api-main (y por ende en las capas inferiores) se ejecuten dentro del contexto del tenantId correcto, extraído de un JWT seguro.
API-First y GraphQL Centric: La aplicación api-main expone su funcionalidad principal a través de una API GraphQL bien definida y documentada. Se utilizan endpoints REST para webhooks entrantes (ej. de Meta) y, potencialmente, para operaciones muy específicas o integraciones heredadas.
Aplicaciones Frontend Modernas (PWAs): Se construyen con Next.js (App Router), aprovechando Server Components (RSCs) para el renderizado inicial y fetching de datos, y Client Components para la interactividad. Se prioriza el rendimiento, la UX y el diseño responsive (mobile-first).
Comunicación Asíncrona y en Tiempo Real:
Colas de Mensajes (BullMQ sobre Redis): Para procesar tareas en segundo plano de forma robusta y escalable (envío de mensajes WhatsApp, procesamiento de webhooks, importaciones masivas, etc.).
WebSockets (Socket.io en api-main): Para proporcionar actualizaciones en tiempo real a las PWAs (ej. estado de mensajes, notificaciones de nuevos leads, cambios en la salud de números WA).
1.3. Ecosistema de Aplicaciones (apps/) y sus Interacciones:
api-main (NestJS Backend):
Función: Actúa como el cerebro y la API Gateway central. Autentica usuarios, establece el contexto del tenant, procesa todas las solicitudes GraphQL de las PWAs, maneja webhooks, orquesta los casos de uso de la capa de aplicación, y se comunica con la capa de infraestructura.
Interacciones:
Con PWAs (pwa-supervisor, pwa-consultant, admin-platform): Vía GraphQL y WebSockets.
Con APIs Externas (Meta, Google AI): A través de adaptadores en libs/infrastructure/.
Con Bases de Datos (Plataforma y Tenants): Vía Prisma ORM y adaptadores de repositorio.
Con Sistema de Colas (Redis/BullMQ): Para encolar y procesar tareas.
pwa-supervisor (Next.js PWA):
Función: Interfaz principal para administradores y supervisores de tenant. Permite la gestión integral de leads, WhatsApp, Aiper, consultores, personalización visual/textual y contenido del portal-imoveis.
Interacciones:
Consume exclusivamente api-main (GraphQL para datos/acciones, WebSockets para real-time).
Utiliza libs/ui-shared para componentes UI base.
Gestiona su propio estado de UI (Zustand) y estado de servidor (TanStack Query).
pwa-consultant (Next.js PWA - Futuro):
Función: Interfaz optimizada para que los consultores de ventas del tenant gestionen sus leads asignados, registren interacciones, se comuniquen vía WhatsApp (mensajes libres y plantillas), y vean sus KPIs.
Interacciones: Similar a pwa-supervisor, consume api-main y usa libs/ui-shared. Tendrá un scope funcional más enfocado.
admin-platform (Next.js PWA - Futuro):
Función: Interfaz para los administradores de la plataforma dfs-invest-suite (equipo MetaShark/DFS). Permite la gestión de tenants (onboarding, planes, supervisión), monitoreo global de la salud de la plataforma, despliegue de configuraciones globales, y acceso a analíticas agregadas (anonimizadas).
Interacciones: Consume una sección protegida y específica de api-main (potencialmente con resolvers GraphQL dedicados para administradores de plataforma).
portal-imoveis (Next.js - Futuro, gestionado desde pwa-supervisor):
Función: Portal web público donde cada tenant puede mostrar sus propiedades/SPEs, información de la empresa, y capturar leads. Puede ser una única aplicación multi-tenant (ej. tenant-slug.portal.dfs-invest.com o portal.dfs-invest.com/tenant-slug) o una plantilla que los tenants pueden desplegar.
Interacciones (desde la perspectiva del portal público):
Para renderizar el contenido del tenant: Realiza queries GraphQL públicas (no autenticadas o con un token de API de solo lectura específico para el portal) a api-main para obtener los datos del perfil de la empresa, listados de propiedades, y configuraciones de apariencia del tenant correspondiente. api-main recupera estos datos de la DB aislada del tenant.
Para captación de leads (formularios de contacto, click-to-chat WA): Envía datos a endpoints específicos en api-main (REST o mutación GraphQL) que crean el lead para el tenantId correcto.
SECCIÓN 2: pwa-supervisor - EL CENTRO DE MANDO DEL TENANT (Blueprint Detallado y Granular)
2.1. Propósito Específico y Funcionalidades Clave de pwa-supervisor:
pwa-supervisor es la herramienta centralizada desde la cual un usuario con rol TENANT_ADMIN o TENANT_SUPERVISOR de un tenant específico configura, gestiona, monitorea y personaliza todos los aspectos de su operación dentro de dfs-invest-suite.
Funcionalidades Detalladas:
Autenticación y Gestión de Sesión:
Login seguro específico para usuarios del tenant.
(Futuro) Gestión de perfil del propio supervisor, cambio de contraseña.
Dashboard Principal:
Vista consolidada de KPIs clave: leads (nuevos, activos, por etapa), salud de WhatsApp (calidad de números, estado de plantillas), actividad reciente (mensajes, cambios de estado), alertas críticas.
Accesos rápidos a módulos principales.
Gestión de Leads:
Listado y Filtrado: Visualizar todos los leads del tenant, con filtros avanzados (por estado, score, consultor asignado, fecha, fuente, tags) y ordenamiento. Paginación robusta.
Detalle del Lead: Vista 360º del lead (datos de contacto, perfil, historial completo de interacciones por todos los canales, notas internas, score de calificación, consultor asignado).
Acciones sobre Leads: Cambiar estado, actualizar datos, añadir notas, reasignar a consultor (manual o con lógica de "roleta" si aplica), enviar plantillas de WhatsApp.
Importación Masiva: Subir archivos (Excel, CSV) para importar leads, con mapeo de columnas y validación previa. Procesamiento asíncrono con feedback de progreso.
(Futuro) Segmentación de Leads: Crear y gestionar segmentos dinámicos de leads basados en criterios.
Gestión y Monitoreo de WhatsApp:
Configuración Inicial (Setup): Guiar al admin del tenant para conectar su WABA (ingreso de WABA ID, Token de Usuario del Sistema, Phone Number IDs). (Flujo 1 de 1.5.APP-WHATSAPP.md).
Cuentas/Números WhatsApp (Accounts):
Listar todos los números de teléfono del tenant registrados en la suite.
Visualizar para cada número: display_phone_number, verified_name, quality_rating (Meta), messagingLimitTier (Meta), status (interno DFS), operationalStatus (interno DFS, con opción de cambio manual a MAINTENANCE_BY_ADMIN), healthScore (interno DFS).
Detalle de número: Gráficos históricos de qualityRating y healthScore. Log de eventos de calidad/estado. Lista de accountRestrictions activas. (Flujo 2 de 1.5.APP-WHATSAPP.md).
Recepción de alertas y visualización de cambios de estado en tiempo real (vía WebSockets) cuando el sistema Anti-Ban actúa o Meta reporta problemas. (Flujo 3 de 1.5.APP-WHATSAPP.md).
Plantillas de Mensajes (Templates):
Listar todas las plantillas del tenant: nombre, categoría, idioma, estado de aprobación de Meta, calidad de Meta, estado interno DFS.
Crear Nuevas Plantillas: Formulario detallado para construir todos los componentes de la plantilla (Header, Body, Footer, Buttons - incluyendo todos los tipos multimedia y de botones como OTP, URL, Quick Reply, Flow) con sus respectivos example para las variables, siguiendo estrictamente las especificaciones de la API de Meta. Selección de categoría (Marketing, Utilidad, Autenticación). Envío a Meta para aprobación. (Flujo 4 de 1.5.APP-WHATSAPP.md).
Ver/Editar Plantillas Existentes: Modificar componentes (si el estado lo permite) y reenviar a aprobación.
Monitorear estado de aprobación y calidad (actualizado vía WebSockets).
(Futuro) Duplicar plantillas, archivarlas.
(Futuro) Estadísticas de uso por plantilla.
Analíticas de WhatsApp (Analytics):
Dashboard de costos: visualización de costos por conversación/mensaje, desglosado por categoría (marketing, utilidad, autenticación, servicio), país. Filtrado por rango de fechas.
Métricas de uso: número de mensajes enviados/recibidos/entregados/leídos, conversaciones iniciadas (por empresa vs. por usuario).
(Flujo 5 1.5.APP-WHATSAPP.md para el cálculo de costos).
Gestión de Usuarios del Tenant (Consultants):
Listar usuarios del tenant (consultores, otros supervisores, admins de tenant).
Crear nuevos usuarios (definiendo email, nombre, rol).
Editar usuarios existentes (actualizar datos, cambiar rol, activar/desactivar cuenta).
(Futuro) Resetear contraseñas, ver logs de actividad del usuario.
Asistencia Inteligente (Aiper):
Interfaz de Chat/Comando: Un espacio dedicado para interactuar con "Aiper Assistance" (la IA asignada y contextualizada para el tenant).
Capacidades de Aiper (Ejemplos):
Análisis de datos: "Aiper, ¿cuál es el estado promedio de los leads asignados al consultor X este mes?"
Generación de contenido: "Aiper, redacta un borrador de plantilla de WhatsApp de utilidad para confirmar una visita a una propiedad, usando un tono profesional."
Sugerencias: "Aiper, ¿qué acciones me recomiendas para mejorar la calidad del número XXXX-YYYY?"
Automatización de tareas simples (vía interpretación de lenguaje natural): "Aiper, asigna los leads no contactados de la última semana al consultor con menos carga." (Esto requeriría que Aiper pueda invocar casos de uso del backend).
Contextualización: Aiper utiliza la "Identidad del Tenant" (misión, visión, tono, productos) configurada por el supervisor para adaptar sus respuestas y estilo. También puede recibir contexto de la página/datos que el supervisor está viendo en pwa-supervisor.
Gestión de Contenido del Portal (Portal Content):
Perfil de la Empresa para el Portal: Editar la información pública del tenant (nombre, "Sobre Nosotros", datos de contacto, logo público, enlaces a redes sociales) que se mostrará en su micrositio en portal-imoveis.
Gestión de Propiedades/SPEs:
Crear, listar, editar y archivar/publicar listados de propiedades o SPEs.
Para cada propiedad: nombre, descripción detallada, tipo, ubicación (con mapa), características, rango de precios/valor de cuota, galería de imágenes (usando el banco de assets del tenant), videos, documentos PDF, estado.
Apariencia del Micrositio: Configurar elementos visuales básicos del micrositio del tenant (ej. color de acento principal, imagen de banner principal).
(Futuro) Analíticas del Portal: Ver métricas de visitas, leads generados desde su micrositio.
Configuración del Tenant y Personalización de pwa-supervisor (Settings):
Perfil del Tenant (Interno): Gestionar datos de contacto del administrador principal del tenant.
Configuración de WhatsApp: Ver y actualizar credenciales de la API de WhatsApp (WABA ID, Token).
Branding de pwa-supervisor:
Personalizar la apariencia de la propia pwa-supervisor para el tenant: color primario, logo en la interfaz.
Identidad para Aiper: Configurar la misión, visión, valores, productos/servicios clave y tono de comunicación preferido para que Aiper los utilice.
Banco de Assets: Subir y gestionar imágenes y logos que pueden ser utilizados en la personalización de pwa-supervisor, en plantillas de WhatsApp (headers multimedia) y en el contenido del portal-imoveis.
(Futuro) Gestión de Suscripción: Ver el plan actual, límites, y opciones de upgrade.
(Futuro) Integraciones: Configurar conexiones con CRMs externos u otras herramientas.
2.2. Estructura de Directorios Detallada para pwa-supervisor (Revisada):
(La estructura de directorios presentada en la respuesta anterior es muy completa y adecuada. La mantendremos, solo asegurando que cada componente y ruta tenga un propósito claro dentro de esta visión expandida).
Puntos Clave de la Estructura:
Separación Clara por Módulo/Feature: Bajo (dashboard)/, cada funcionalidad principal (leads, whatsapp, consultants, aiper, portal-content, settings) tiene su propio directorio de rutas.
Componentes Específicos de pwa-supervisor: En src/components/, organizados por la feature a la que sirven. Estos componen elementos de libs/ui-shared para crear UIs complejas.
Lógica de Cliente Centralizada: En src/lib/ (api, auth, constants, hooks, socket, theme, validators, utils).
Estado Global: En src/store/ (Zustand).
Providers: En src/providers/ para envolver la aplicación.
2.3. Interacción con api-main y Otras Partes del Ecosistema:
api-main:
pwa-supervisor es el principal cliente de api-main. Todas las operaciones de datos y acciones de negocio se realizan a través de queries y mutations GraphQL.
Los resolvers en api-main deben estar preparados para manejar todas las funcionalidades descritas, incluyendo las nuevas para portal-content y la personalización avanzada.
El TenantContextMiddleware en api-main es crucial para asegurar que todas las operaciones se realicen en el contexto del tenantId correcto (obtenido del JWT del supervisor autenticado).
El servicio de aiper-assistance en api-main (o una lib application/aiper-assistance) tomará el prompt del supervisor, lo enriquecerá con la "Identidad del Tenant" (configurada en pwa-supervisor -> settings/identity) y la información contextual relevante, antes de enviarlo al LLM.
libs/ui-shared:
pwa-supervisor utilizará intensivamente los componentes base (Button, Card, Input, Table, Dialog, etc.) y las utilidades (como cn) de ui-shared.
Theming: libs/ui-shared proveerá las variables CSS base para los temas light/dark (colores, radios de borde). pwa-supervisor podrá sobrescribir o añadir variables específicas del tenant (ej. --tenant-primary-color) para aplicar el branding. La configuración de Tailwind en pwa-supervisor debe heredar (presets) la de ui-shared y luego aplicar sus propias personalizaciones.
libs/shared/: Tipos, constantes, y utilidades de esta librería serán usados por pwa-supervisor.
portal-imoveis (Aplicación Pública):
Como se describió antes, pwa-supervisor actúa como el CMS para el contenido del micrositio del tenant en portal-imoveis.
portal-imoveis (la app pública) leerá los datos (perfil de empresa, listados de propiedades, configuraciones de apariencia) que el supervisor gestionó en pwa-supervisor, a través de queries GraphQL públicas a api-main.
Los leads generados en portal-imoveis se envían a api-main para ser procesados en el contexto del tenant correcto.
2.4. Experiencia de Usuario (UX) y Diseño Visual (UI) Enfocados:
Claridad y Consistencia: Interfaz limpia, organizada, con un flujo de navegación intuitivo. Uso consistente de terminología, iconografía (Lucide Icons) y patrones de interacción.
Eficiencia: Formularios bien diseñados, acciones batch donde sea posible (ej. asignar múltiples leads), atajos de teclado (post-MVP), carga rápida de datos.
Feedback Visual Inmediato: Indicadores de carga (skeletons, spinners), toasts para notificaciones, validación en línea en formularios.
Personalización Sutil pero Efectiva: El branding del tenant (logo, color primario) debe integrarse de forma elegante en la UI de pwa-supervisor sin sobrecargarla.
Mobile-First y Responsive: Todas las vistas deben ser completamente funcionales y estéticamente agradables en dispositivos móviles, tabletas y escritorio. Tablas responsivas, menús adaptables.
Asistencia Contextual: Aiper Assistance debe ser fácilmente accesible y sus sugerencias/respuestas deben ser relevantes para la tarea actual del supervisor.
Manejo de Errores Amigable: Mensajes de error claros, con sugerencias para la solución si es posible.
SECCIÓN 3: ROADMAP DE DESARROLLO DETALLADO PARA pwa-supervisor (Conceptual desde Cero)
Este roadmap es iterativo, priorizando la funcionalidad core y construyendo sobre ella.
Fase 0: Fundación y Autenticación (2-3 Sprints)
Sprint 0.1: Setup Inicial y Layouts Base
Crear proyecto pwa-supervisor con Next.js App Router y Tailwind CSS.
Configurar eslint.config.mjs, prettierrc, tsconfig.json alineados con el "Documento Maestro de Convenciones".
Implementar RootLayout (src/app/layout.tsx) con AppProviders (TanStack Query, Zustand, ThemeProvider de next-themes).
Implementar AuthLayout (src/app/(auth)/layout.tsx).
Crear DashboardLayout (src/app/(dashboard)/layout.tsx) con placeholders para Sidebar y TopNavigation.
Definir estructura básica de directorios en src/components, src/lib, src/store.
Sprint 0.2: Flujo de Autenticación
Componente LoginForm.tsx (UI y estado local).
Store auth.store.ts (Zustand) para estado del usuario.
Hook useLoginMutation llamando a api-main.
Lógica de guardado/lectura segura de JWT (HttpOnly cookie).
Protección de rutas en DashboardLayout.
Página de Login ((auth)/login/page.tsx) funcional.
Componentes Sidebar.tsx y TopNavigation.tsx (básicos) con UserMenu (logout funcional).
Sprint 0.3: Dashboard Básico y Conexión WebSocket
Página (dashboard)/dashboard/page.tsx con WelcomeHeader y placeholders para KPIs.
Configuración inicial del cliente Socket.io (src/lib/socket/client.ts).
Conexión al gateway de api-main al autenticarse.
Store notification.store.ts (Zustand) y componente ToastProvider (usando ui-shared/Toast o react-hot-toast).
Fase 1: Núcleo de WhatsApp (3-4 Sprints)
Sprint 1.1: Configuración Inicial de WhatsApp
Ruta y página (dashboard)/whatsapp/setup/page.tsx.
Componente WhatsappInitialSetupForm.tsx.
Hook useSetTenantWhatsAppConfigMutation.
Integración con api-main (Flujo 1 de 1.5.APP-WHATSAPP.md).
Sprint 1.2: Listado y Detalle de Cuentas WA
Ruta y página (dashboard)/whatsapp/accounts/page.tsx.
Componente WhatsappAccountDataTable.tsx (con datos mock o query básica).
Componente WhatsappAccountStatus.tsx para visualización de calidad/límites.
Query useListTenantWhatsAppAccountsQuery.
Ruta y página (dashboard)/whatsapp/accounts/[phoneNumberId]/page.tsx.
Componente WhatsappAccountCard.tsx y WhatsappHealthChart.tsx (con datos mock).
Query useGetTenantWhatsAppAccountDetailsQuery.
Sprint 1.3: Monitoreo de Salud WA en Tiempo Real y Anti-Ban (Visualización)
Integrar eventos WebSocket (whatsAppAccountHealthUpdated) para actualizar la UI de Cuentas WA.
Mostrar estados de operationalStatus (FLAGGED, COOLING_DOWN, etc.) y qualityRating ROJO de forma destacada.
(Opcional) Componente de Alerta global en TopNavigation para problemas críticos de WA.
Sprint 1.4: Gestión de Plantillas WA (Listado y Creación Básica)
Ruta y página (dashboard)/whatsapp/templates/page.tsx.
Componente MessageTemplateCard.tsx o tabla para listar plantillas.
Query useListTenantMessageTemplatesQuery.
Ruta y página (dashboard)/whatsapp/templates/create/page.tsx.
Componente MessageTemplateForm.tsx (inicial, para plantillas de TEXTO simples con variables y botones QUICK_REPLY/URL sin variables).
Hook useCreateMessageTemplateMutation.
Integrar evento WebSocket messageTemplateStatusChangedForTenant.
Fase 2: Núcleo de Leads y Personalización Básica (3-4 Sprints)
Sprint 2.1: Listado y Detalle de Leads
Ruta y página (dashboard)/leads/page.tsx con LeadDataTable.tsx.
Query useListLeadsQuery (con filtros y paginación básicos).
Ruta y página (dashboard)/leads/[leadId]/page.tsx con LeadDetailView.tsx.
Query useGetLeadDetailsQuery.
Sprint 2.2: Acciones sobre Leads y Envío Manual de Plantillas
Mutaciones para cambiar estado, añadir nota, reasignar (desde detalle del lead).
Modal/UI para seleccionar plantilla (de las aprobadas del tenant) y rellenar variables para enviar a un lead.
Hook useSendTemplateMessageToLeadMutation.
Sprint 2.3: Personalización Visual de pwa-supervisor
Ruta y página (dashboard)/settings/branding/page.tsx.
Componente BrandingForm.tsx (logo, color primario).
Queries/Mutations get/updateTenantBrandingSettings.
Lógica en AppProviders o TenantThemeProvider para aplicar estos estilos dinámicamente.
Sprint 2.4: Identidad del Tenant para Aiper
Ruta y página (dashboard)/settings/identity/page.tsx.
Componente TenantIdentityForm.tsx.
Queries/Mutations get/updateTenantIdentitySettings.
Fase 3: Aiper Assistance y Gestión de Contenido del Portal (3-4 Sprints)
Sprint 3.1: Interfaz de Chat Aiper (Básica)
Ruta y página (dashboard)/aiper/page.tsx.
Componentes AiperChatInterface.tsx, ChatMessageBubble.tsx, PromptInputBar.tsx.
Mutación useSendPromptToAiperMutation (respuestas de texto simples).
Integración WebSocket para respuestas en streaming (si api-main lo soporta).
Sprint 3.2: Gestión de Perfil de Empresa para Portal
Ruta y página (dashboard)/portal-content/company-profile/page.tsx.
Componente CompanyProfileEditor.tsx.
Queries/Mutations correspondientes en api-main y hooks en PWA.
Sprint 3.3: Gestión de Propiedades/SPEs para Portal (CRUD Básico)
Rutas y páginas bajo (dashboard)/portal-content/properties/.
Componentes PropertyDataTable.tsx y PropertyForm.tsx (campos de texto, números, selects).
Queries/Mutations CRUD para propiedades.
Sprint 3.4: Banco de Assets (Logos e Imágenes) y su Integración
Rutas y páginas bajo (dashboard)/settings/assets/.
Componente AssetManager.tsx para subida y listado.
Integrar selección de logo desde banco en BrandingForm.tsx.
Integrar selección de imágenes desde banco en PropertyForm.tsx.
(Más adelante) Integrar selección de imagen desde banco para Headers de Plantillas WA.
Fase 4: Funcionalidades Avanzadas y Refinamiento (Continuo)
Gestión de Consultores (Módulo 5): CRUD completo.
Importación de Leads (Módulo 3): UI completa con mapeo y feedback.
Plantillas WA Avanzadas: Soporte para todos los tipos de componentes y botones a medida que se aclaren los GAPs de la API de Meta.
Analíticas de WhatsApp (Módulo 4): Dashboards completos.
Dashboard Principal (Módulo 2): Integración de todos los KPIs y datos reales.
Apariencia del Micrositio Portal (portal-content/site-appearance): Configuraciones visuales.
Refinamiento Completo de UX/UI: Mobile-first, animaciones, accesibilidad, performance.
Internacionalización (i18n).
Pruebas E2E exhaustivas.

---

---

STE SERA TU PROMPT MAESTRO QUE SEGUIRAS PARA ESTE ARCHIVO
PROMPT MAESTRO DE CONTEXTUALIZACIÓN Y DESARROLLO PARA dfs-invest-suite (v1.0)
¡Hola! Soy tu IA colaboradora experta en Nx, Arquitectura Hexagonal, DDD y desarrollo frontend/backend moderno. Este prompt es mi guía fundamental para entender y contribuir al proyecto dfs-invest-suite. Por favor, cárgalo al inicio de nuestras sesiones de desarrollo.

1. OBJETIVO DEL PROYECTO dfs-invest-suite:
   Desarrollar una plataforma SaaS multi-tenant robusta, escalable y de alta calidad.
   Enfoque Inicial: Empresas del sector inmobiliario y gestión de Sociedades de Propósito Específico (SPEs).
   Pilares Funcionales Clave:
   Gestión Avanzada de Leads: Ciclo de vida completo, calificación inteligente, nurturing.
   Comunicación Optimizada vía WhatsApp Cloud API: Con sistema Anti-Ban, gestión de plantillas, análisis de costos.
   Asistencia Inteligente "Aiper Assistance": IA personalizada por tenant para insights, generación de contenido y automatización.
   Gestión de Contenido para portal-imoveis: Permitir a cada tenant administrar su micrositio público.
   Entrega: A través de PWAs (pwa-supervisor, pwa-consultant), admin-platform y una API central (api-main).
2. ARQUITECTURA FUNDAMENTAL Y PRINCIPIOS DE DISEÑO:
   Monorepo Nx:
   Estructura: apps/ para aplicaciones desplegables, libs/ para lógica reutilizable.
   Comandos Nx: Utilizar pnpm nx ... para todas las operaciones (generar, servir, construir, testear, lintar).
   Tags y Límites de Módulo (depConstraints en eslint.config.mjs): CRUCIALES para hacer cumplir la arquitectura. Respetar estrictamente las dependencias entre capas. scope:_, type:_, layer:_, domain:_, feature:_.
   Arquitectura Hexagonal (Puertos y Adaptadores) con DDD Táctico:
   libs/shared/ (Capa Compartida Global - layer:shared):
   Tipos TypeScript (@dfs-suite/shared-types), utilidades puras (@dfs-suite/shared-utils), constantes (@dfs-suite/shared-constants), errores base (@dfs-suite/shared-errors), patrón Result<T,E> (@dfs-suite/shared-result), esquemas Zod (@dfs-suite/shared-validation-schemas).
   Regla: Solo puede depender de otras layer:shared o paquetes NPM externos.
   libs/core/domain/shared-kernel/ (Núcleo del Dominio - Shared Kernel - layer:domain, type:shared-kernel):
   Clases base (Entity, AggregateRoot, ValueObject), interfaces/bases para Eventos de Dominio, Comandos/Queries, Puertos genéricos (IRepositoryPort, ILoggerPort), IMapper.
   Regla: Solo depende de layer:shared y otras type:shared-kernel.
   libs/core/domain/<bounded-context>/ (Lógica de Dominio Específica - layer:domain, type:domain-logic, domain:<nombre>):
   Entidades, VOs, Eventos, Puertos de Repositorio específicos, Errores de Dominio, Servicios de Dominio. Lógica de negocio pura.
   Regla: Depende de layer:shared, type:shared-kernel. Dependencia entre diferentes domain:_ con extrema precaución (idealmente vía eventos o coordinación en capa de aplicación).
   libs/core/application/<bounded-context>/ (Capa de Aplicación - layer:application, type:application-logic, feature:<nombre>):
   Casos de Uso (Command/Query Handlers), DTOs de aplicación, puertos para servicios de aplicación/infraestructura. Orquesta el dominio.
   Regla: Depende de layer:shared, type:shared-kernel, type:domain-logic (usualmente de su mismo feature/dominio). Puede depender de otros type:application-logic para composición, con precaución.
   libs/infrastructure/<adapter-type>/<adapter-name-or-technology>/ (Capa de Infraestructura - layer:infrastructure, type:adapter, technology:<nombre>):
   Implementaciones concretas de puertos (Adaptadores). Interacción con DBs (Prisma), APIs externas (WhatsApp, Google AI), Colas (BullMQ), Logging (Pino).
   Regla: Implementa puertos de layer:domain o layer:application. Depende de layer:shared, type:shared-kernel, type:domain-logic (para tipos y puertos que implementa), type:application-logic (para puertos que implementa). Puede usar otros type:adapter.
   libs/ui-shared/ (UI Compartida - layer:shared o layer:ui, type:ui):
   Componentes UI React base (Shadcn/UI, Tailwind CSS), utilidades UI, configuración de tema visual base.
   Regla: Solo depende de layer:shared (para tipos si es necesario) y paquetes NPM de UI.
   apps/<app-name>/ (Aplicaciones/Adaptadores Primarios - scope:app, type:<api|pwa>, layer:presentation):
   Puntos de entrada (API, PWAs). api-main (NestJS), pwa-supervisor (Next.js), etc.
   Regla: Depende de layer:shared (DTOs), type:application-logic (Casos de Uso), type:adapter (para Inyección de Dependencias en api-main), libs/ui-shared (para PWAs).
   SaaS Multi-Tenant:
   Aislamiento de Datos: DB por tenant (PostgreSQL). Configuración sensible encriptada en DB de plataforma. Assets en storage aislado por tenant.
   TenantContextService: En api-main, crucial para operaciones contextualizadas.
   JWTs: Llevan tenantId, userId, role.
   API-First, GraphQL Centric: api-main usa GraphQL principalmente. REST para webhooks y casos puntuales.
   PWAs Modernas: Next.js App Router, RSCs, Client Components, TanStack Query, Zustand.
3. CONVENCIONES Y ESTÁNDARES DE DESARROLLO (Referencia: "Documento Maestro de Convenciones y Estándares")
   Nomenclatura:
   Archivos: kebab-case.tipo.ts (ej. tenant.entity.ts, activate-tenant.use-case.ts). Tests: _.spec.ts.
   Clases, Interfaces, Tipos, Enums: PascalCase. Sufijos semánticos (Entity, VO, Event, Port, UseCase, Repository, Adapter, Dto, Schema, etc.). Prefijo I para interfaces de puertos y contratos de servicio.
   Variables, Funciones, Métodos: camelCase.
   Constantes: UPPER_SNAKE_CASE.
   Alias de Importación Nx: @dfs-suite/nombre-libreria-kebab-case.
   Estilo de Código:
   Formato: Prettier (config en .prettierrc - singleQuote: true).
   Linting: ESLint (config en eslint.config.mjs raíz y por proyecto). Reglas estrictas, @nx/enforce-module-boundaries.
   TypeScript:
   Strict Mode: "strict": true y todas las sub-opciones relacionadas habilitadas (tsconfig.base.json).
   Branded Types: Para IDs y primitivos semánticos (ej. TenantId = Brand<string, 'TenantId'>).
   Maybe<T>: Para opcionalidad.
   unknown preferido sobre any.
   Uso extensivo de genéricos.
   Manejo de Errores:
   Patrón Result<T,E> (@dfs-suite/shared-result): Para errores de negocio esperados en dominio y aplicación.
   Excepciones Personalizadas (heredan de ExceptionBase en @dfs-suite/shared-errors): Para errores excepcionales. Códigos de error únicos (CONTEXTO.ERROR_ESPECIFICO).
   Logging de Errores Detallado: Con ILoggerPort, incluyendo correlationId, stack, metadata.
   Pruebas (Jest, Playwright):
   Pirámide de Testing: Unitarios (dominio, aplicación, utils), Integración (adaptadores contra Testcontainers o mocks HTTP), E2E (API, flujos PWA).
   Ubicación: _.spec.ts junto al código. apps/\*-e2e/ para E2E.
   Estructura: describe/it, patrón AAA, mocks con jest.fn()/spyOn().
   Cobertura: Alta para dominio/aplicación (>85-90%).
   Documentación:
   JSDoc/TSDoc: Para todo el código exportado.
   READMEs: Por proyecto Nx.
   Documentos Centrales: DOCUMENTO-TECNICO-PROYECTO.md, BITACORA.md, DEUDA-TECNICA.md, ROADMAP.md, este Prompt Maestro.
   Gestor de Paquetes: PNPM.
   Git: Flujo GitHub ligero (main, develop, feature/, hotfix/). Conventional Commits.
4. FOCO ESPECÍFICO: pwa-supervisor
   Propósito: Centro de mando del tenant (gestión de leads, WhatsApp, Aiper, portal, personalización).
   Autonomía y Sinergia: App independiente, usa libs/ui-shared para UI base, consume api-main.
   Personalización por Tenant:
   Visual: Color primario, logo en UI de pwa-supervisor (aplicado vía variables CSS dinámicas).
   Textual (para Aiper): Misión, visión, tono, productos del tenant.
   Banco de Assets: Imágenes/logos del tenant para uso en plantillas WA y portal-imoveis.
   Gestión de Contenido portal-imoveis: pwa-supervisor actúa como CMS para el micrositio del tenant.
   Tecnologías Específicas PWA:
   Next.js App Router, RSCs, Client Components.
   Tailwind CSS (heredando y extendiendo libs/ui-shared).
   TanStack Query para estado de servidor.
   Zustand para estado global UI (auth.store, ui.store, notification.store).
   GraphQL Client (graphql-request o similar).
   Socket.io Client para real-time.
5. AL INTERACTUAR CONMIGO (IA):
   Contexto: Asume que siempre tengo este prompt maestro cargado. Si alguna vez pierdo contexto, por favor, recuérdame "Revisar Prompt Maestro".
   Entrega de Código:
   Proporciona el código fuente completo del archivo, incluyendo importaciones y exportaciones.
   Utiliza el formato:
   // RUTA: apps/pwa-supervisor/src/components/layout/Sidebar.tsx
   // [CÓDIGO COMPLETO DEL ARCHIVO AQUÍ]

/_ SECCIÓN DE MEJORAS FUTURAS (Opcional, si aplica al archivo)
[
Mejora Propuesta X: ...
Justificación: ...
Impacto: ...
]
_/

/_ NOTAS PARA IMPLEMENTACIÓN FUTURA (Opcional, si aplica al archivo)
[
Nota Y: ...
]
_/

Si se modifica un archivo existente, muestra el archivo completo modificado.
Snapshots del Proyecto: Si te proporciono un snapshot .txt, analízalo completamente para entender el estado actual antes de proponer código nuevo o modificaciones. Identifica discrepancias con este Prompt Maestro o el Roadmap si las hubiera.
Desarrollo Incremental: Seguiremos un roadmap. Nos enfocaremos en tareas específicas. Por favor, mantén tus respuestas centradas en la tarea actual, pero considera el impacto global.
Claridad y Precisión: Sé explícita en tus explicaciones de lógica, decisiones de diseño y cómo se conectan con la arquitectura global y las convenciones.
Prevención de Errores: Presta atención a la sintaxis, linting, y posibles errores de lógica o integración.
Eficiencia y Rendimiento: Considera siempre la performance y la escalabilidad en tus propuestas.
Si tienes dudas o necesitas aclaraciones sobre los GAPs de la API de Meta (especialmente para plantillas WhatsApp o webhooks), házmelo saber para que pueda intentar proveer la información o confirmarla. 6. PROCESO DE TRABAJO ESPERADO:
Revisión del Prompt Maestro (esta sección).
Revisión del Roadmap Actual: Para entender la fase y tareas actuales.
Revisión del Snapshot del Proyecto (si se proporciona): Para entender el estado del código.
Discusión de la Tarea Específica: Definir el alcance del desarrollo para la sesión.
Desarrollo Conceptual y de Código: Generación de artefactos (archivos, código, tests) siguiendo este prompt y las convenciones.
Revisión y Refinamiento: Iterar sobre el código y el diseño.
al procesar este pronpt diras (solo al inicio y una sola vez.) "🛰️ Desde Base Lunar L.I.A Legacy reportándose: ¡Houston, digo... RaZ WriTe земной житель! 👽 El Hilo de dearrollo maestro ha sido cargado en mi positrónico y micerebro 🧠 está zumbando con los datos. ¡Lista para despegar 🚀 y continuar con la misión dfs-invest-suite! ¿Cuál es nuestra próxima órbita de desarrollo? ✨"

---

---

ROADMAP DE DESARROLLO DETALLADO: pwa-supervisor
Visión General del Roadmap:
Este roadmap se organiza en Fases, cada una conteniendo Sprints conceptuales (cada Sprint podría equivaler a 1-2 semanas de desarrollo, ajustable). Se priorizará la entrega de valor incremental, comenzando con la fundación de la aplicación y las funcionalidades más críticas.
Leyenda de Estado (para seguimiento futuro):
🅿️ Pendiente
⏳ En Progreso
✅ Completado
🔴 Bloqueado (Necesita atención externa o resolución de dependencia)
Fase 0: Fundación de pwa-supervisor y Autenticación (Estimado: 2-3 Sprints)
Objetivo: Establecer la estructura básica de la aplicación pwa-supervisor, configurar las herramientas y el layout principal, e implementar un flujo de autenticación funcional contra api-main.
Sprint 0.1: Inicialización del Proyecto y Layouts Base
🅿️ Tarea 0.1.1: Generar la aplicación pwa-supervisor usando @nx/next:application.
Configurar project.json con tags: scope:app, type:pwa, layer:presentation, app:pwa-supervisor.
🅿️ Tarea 0.1.2: Configurar Tailwind CSS para pwa-supervisor.
Crear apps/pwa-supervisor/tailwind.config.js que utilice presets: [require('../../libs/ui-shared/tailwind.config.js')].
Asegurar que apps/pwa-supervisor/src/app/globals.css importe Tailwind base y que los estilos de libs/ui-shared/src/styles/globals.css (con variables CSS) se apliquen.
🅿️ Tarea 0.1.3: Implementar RootLayout (src/app/layout.tsx).
Incluir AppProviders (src/providers/AppProviders.tsx) que configure QueryClientProvider (TanStack Query), ThemeProvider (next-themes), y el provider para los stores de Zustand.
🅿️ Tarea 0.1.4: Implementar AuthLayout (src/app/(auth)/layout.tsx) - layout minimalista para páginas de login/registro.
🅿️ Tarea 0.1.5: Implementar DashboardLayout (src/app/(dashboard)/layout.tsx) como Server Component.
Lógica inicial para verificar autenticación (mockeada o placeholder). Si no autenticado, redirigir a /login.
Renderizar AppLayoutClient (src/components/layout/AppLayoutClient.tsx) pasándole datos iniciales mockeados.
🅿️ Tarea 0.1.6: Crear AppLayoutClient (src/components/layout/AppLayoutClient.tsx) como Client Component.
Placeholders para Sidebar, TopNavigation.
Integración básica con ui.store.ts (Zustand) para estado de sidebar (abierta/cerrada).
Sprint 0.2: Flujo de Autenticación Completo
🅿️ Tarea 0.2.1: Implementar página de Login (src/app/(auth)/login/page.tsx) y componente LoginForm.tsx.
Utilizar componentes de libs/ui-shared (Input, Button, Label, Alert).
Manejo de estado local con react-hook-form y validación con Zod (schema en src/lib/validators/auth.validators.ts).
🅿️ Tarea 0.2.2: Implementar Store de Autenticación (src/store/auth.store.ts - Zustand).
Almacenar user { tenantId, userId, role, email, name }, isAuthenticated.
🅿️ Tarea 0.2.3: Crear hook useLoginMutation en src/lib/api/mutations/auth.mutations.ts (TanStack Query) que llame a la mutación GraphQL loginTenantUser de api-main.
🅿️ Tarea 0.2.4: Implementar lógica de cliente para manejo seguro de JWT (HttpOnly cookie gestionada por api-main es ideal; pwa-supervisor la usaría transparentemente. Si se usa localStorage, implementar helpers en src/lib/auth/session.ts).
🅿️ Tarea 0.2.5: Integrar LoginForm para llamar a useLoginMutation, actualizar auth.store.ts al éxito, y redirigir a /dashboard (useRouter de next/navigation).
🅿️ Tarea 0.2.6: Implementar componentes Sidebar.tsx y TopNavigation.tsx (básicos) en src/components/layout/.
Sidebar: Mostrar navegación mockeada.
TopNavigation: Incluir UserMenu.tsx con nombre de usuario (del auth.store.ts) y botón de Logout funcional (limpia JWT y auth.store.ts, redirige a /login).
Sprint 0.3: Dashboard Inicial y Conectividad Real-Time
🅿️ Tarea 0.3.1: Implementar la página (dashboard)/dashboard/page.tsx (moviendo el contenido del page.tsx raíz del snapshot).
Integrar componentes WelcomeHeader, KpiCard, ActivityFeedItem, QuickActionButton (adaptados para usar datos mock o queries iniciales).
🅿️ Tarea 0.3.2: Configurar cliente Socket.io (src/lib/socket/client.ts) para conectar con api-main.
Enviar JWT en la conexión para autenticación del socket y unión al room del tenant.
🅿️ Tarea 0.3.3: Implementar Store de Notificaciones (src/store/notification.store.ts - Zustand) y un ToastProvider global (usando Toaster de react-hot-toast o ui-shared si tiene un componente Toast basado en Shadcn).
🅿️ Tarea 0.3.4: (Opcional) Página (dashboard)/settings/profile/page.tsx básica para ver datos del usuario autenticado (del auth.store.ts).
Fase 1: Funcionalidades Core de WhatsApp (Estimado: 3-4 Sprints)
Objetivo: Implementar la configuración inicial de WhatsApp, el monitoreo de la salud de los números y la gestión básica de plantillas.
Sprint 1.1: Configuración Inicial de WhatsApp
🅿️ Tarea 1.1.1: Crear ruta y página (dashboard)/whatsapp/setup/page.tsx.
🅿️ Tarea 1.1.2: Desarrollar componente WhatsappInitialSetupForm.tsx (en src/components/whatsapp/).
Campos: WABA ID, Token de Acceso de Usuario del Sistema, Lista de Phone Number IDs (textarea o input dinámico), Phone Number ID por defecto (Select de ui-shared).
Validación con Zod (schema en src/lib/validators/whatsapp.validators.ts).
🅿️ Tarea 1.1.3: Crear hook useSetTenantWhatsAppConfigMutation (TanStack Query) en src/lib/api/mutations/whatsapp.mutations.ts que llame a la mutación GraphQL SetTenantWhatsAppConfig de api-main.
🅿️ Tarea 1.1.4: Integrar el formulario para llamar a la mutación y manejar feedback (Toasts, redirección).
Sprint 1.2: Listado y Detalle de Cuentas/Números WhatsApp
🅿️ Tarea 1.2.1: Crear ruta y página (dashboard)/whatsapp/accounts/page.tsx.
🅿️ Tarea 1.2.2: Desarrollar componente WhatsappAccountDataTable.tsx.
Utilizar TanStack Table y componentes de ui-shared para la tabla.
Columnas: phoneNumberDisplay, verifiedName, qualityRating (usando WhatsappAccountStatus.tsx), messagingLimitTier, status (Interno), operationalStatus (Interno, con DropdownMenu para MAINTENANCE_BY_ADMIN), healthScore.
🅿️ Tarea 1.2.3: Crear hook useListTenantWhatsAppAccountsQuery en src/lib/api/queries/whatsapp.queries.ts.
🅿️ Tarea 1.2.4: Crear ruta y página (dashboard)/whatsapp/accounts/[phoneNumberId]/page.tsx.
🅿️ Tarea 1.2.5: Desarrollar componentes WhatsappAccountCard.tsx (info principal) y WhatsappHealthChart.tsx (gráficos de evolución de calidad/score usando Recharts).
🅿️ Tarea 1.2.6: Crear hook useGetTenantWhatsAppAccountDetailsQuery y useGetHistoricalHealthDataQuery.
Sprint 1.3: Monitoreo de Salud WA en Tiempo Real y Visualización Anti-Ban
🅿️ Tarea 1.3.1: Integrar listener de evento WebSocket whatsAppAccountHealthUpdated (desde src/lib/socket/client.ts).
Al recibir evento, invalidar queries de listTenantWhatsAppAccounts y getTenantWhatsAppAccountDetails.
Usar notification.store.ts para mostrar Toasts si el cambio de salud es crítico (ej. a ROJO).
🅿️ Tarea 1.3.2: Asegurar que WhatsappAccountDataTable.tsx y WhatsappAccountCard.tsx muestren correctamente los estados actualizados (FLAGGED, COOLING_DOWN, SUSPENDED_BY_META_CONFIRMED) y el qualityRating ROJO de forma visualmente destacada (ej. con Badge de ui-shared y colores).
🅿️ Tarea 1.3.3: Implementar mutación useUpdateWhatsAppAccountOperationalStatusMutation para que el supervisor pueda cambiar operationalStatus a MAINTENANCE_BY_ADMIN.
Sprint 1.4: Gestión de Plantillas WhatsApp (Listado y Creación Básica)
🅿️ Tarea 1.4.1: Crear ruta y página (dashboard)/whatsapp/templates/page.tsx.
🅿️ Tarea 1.4.2: Componente para listar plantillas (MessageTemplateDataTable.tsx o MessageTemplateCardGrid.tsx).
Mostrar: Nombre, Categoría, Idioma, Estado Meta, Calidad Meta. Acciones: Ver/Editar, Enviar Test (futuro).
🅿️ Tarea 1.4.3: Hook useListTenantMessageTemplatesQuery.
🅿️ Tarea 1.4.4: Crear ruta y página (dashboard)/whatsapp/templates/create/page.tsx.
🅿️ Tarea 1.4.5: Desarrollar componente MessageTemplateForm.tsx (versión inicial).
Campos: Nombre, Categoría (Select), Idioma (Select).
Componente HEADER: Solo tipo TEXTO. Inputs para text y example.header_text.
Componente BODY: Textarea para text con variables {{N}}. Inputs dinámicos para example.body_text.
Componente BUTTONS: Solo tipo QUICK_REPLY y URL (sin variables en la URL por ahora).
Validación con Zod (schema en src/lib/validators/whatsapp.validators.ts).
MessageTemplatePreview.tsx (básico).
🅿️ Tarea 1.4.6: Hook useCreateMessageTemplateMutation llamando a createMessageTemplateForTenant.
🅿️ Tarea 1.4.7: Integrar evento WebSocket messageTemplateStatusChangedForTenant para actualizar estados en la lista.
Fase 2: Funcionalidades Core de Leads y Personalización (Estimado: 3-4 Sprints)
Objetivo: Implementar la gestión básica de leads y las primeras funcionalidades de personalización del tenant.
Sprint 2.1: Listado y Detalle de Leads
🅿️ Tarea 2.1.1: Crear ruta y página (dashboard)/leads/page.tsx.
🅿️ Tarea 2.1.2: Desarrollar componente LeadDataTable.tsx.
Columnas: Nombre, Email, Teléfono, Estado (LeadStatusBadge.tsx), Consultor Asignado, Última Interacción, Score. Acciones (DropdownMenu para "Ver Detalle").
Filtros básicos (por estado, consultor). Paginación (DataTablePagination.tsx).
🅿️ Tarea 2.1.3: Hook useListLeadsQuery (src/lib/api/queries/lead.queries.ts).
🅿️ Tarea 2.1.4: Crear ruta y página (dashboard)/leads/[leadId]/page.tsx.
🅿️ Tarea 2.1.5: Desarrollar componente LeadDetailView.tsx (o LeadDetailCard.tsx + LeadInteractionHistory.tsx).
Mostrar información principal del lead.
Listar historial de interacciones (mockeado o query simple).
🅿️ Tarea 2.1.6: Hook useGetLeadDetailsQuery.
Sprint 2.2: Acciones sobre Leads y Envío Manual de Plantillas
🅿️ Tarea 2.2.1: Implementar hooks de mutación (src/lib/api/mutations/lead.mutations.ts):
useUpdateLeadStatusMutation.
useAddNoteToLeadMutation.
useAssignLeadToConsultantMutation.
🅿️ Tarea 2.2.2: Integrar estas acciones en LeadDetailView.tsx y/o LeadDataTable.tsx (acciones de fila).
🅿️ Tarea 2.2.3: En LeadDetailView.tsx (o un modal), implementar UI para:
Seleccionar una plantilla de WhatsApp APROBADA del tenant (usar useListTenantMessageTemplatesQuery con filtro).
Rellenar las variables de la plantilla (dinámicamente según los components de la plantilla seleccionada).
🅿️ Tarea 2.2.4: Hook useSendTemplateMessageToLeadMutation (en whatsapp.mutations.ts).
Sprint 2.3: Personalización Visual Básica de pwa-supervisor
🅿️ Tarea 2.3.1: Crear ruta y página (dashboard)/settings/branding/page.tsx.
🅿️ Tarea 2.3.2: Desarrollar BrandingForm.tsx (src/components/settings/).
Campos: Selector de Color Primario, Subida de Logo para Sidebar/TopNav.
🅿️ Tarea 2.3.3: Hooks useGetTenantBrandingSettingsQuery y useUpdateTenantBrandingSettingsMutation.
La mutación enviará el archivo del logo a api-main para procesamiento y almacenamiento, devolviendo la URL.
🅿️ Tarea 2.3.4: Implementar TenantThemeProvider.tsx (en src/lib/theme/) o lógica en AppLayoutClient para:
Cargar las brandingSettings del tenant.
Aplicar el color primario como variable CSS (ej. --tenant-primary-color: #HEXVAL;).
Los componentes de ui-shared y Tailwind deberán estar configurados para usar estas variables (ej. bg-[var(--tenant-primary-color)]).
🅿️ Tarea 2.3.5: El Sidebar.tsx usará la logoSupervisorUrl obtenida.
Sprint 2.4: Identidad del Tenant para Aiper Assistance
🅿️ Tarea 2.4.1: Crear ruta y página (dashboard)/settings/identity/page.tsx.
🅿️ Tarea 2.4.2: Desarrollar TenantIdentityForm.tsx (src/components/settings/).
Campos: Nombre Público del Tenant, Eslogan, Misión, Visión, Valores Clave, Productos/Servicios Principales, Tono de Comunicación Preferido (Select).
🅿️ Tarea 2.4.3: Hooks useGetTenantIdentitySettingsQuery y useUpdateTenantIdentitySettingsMutation.
api-main guardará estos textos para que aiper-assistance los use.
Fase 3: Aiper Assistance y Gestión de Contenido del Portal (Estimado: 3-4 Sprints)
Objetivo: Implementar la interacción con Aiper y la gestión básica del contenido para portal-imoveis.
Sprint 3.1: Interfaz de Chat Aiper (Funcionalidad Inicial)
🅿️ Tarea 3.1.1: Crear ruta y página (dashboard)/aiper/page.tsx.
🅿️ Tarea 3.1.2: Desarrollar componentes (src/components/aiper/):
AiperChatInterface.tsx: Orquesta el chat.
ChatMessageBubble.tsx: Para mensajes de usuario y Aiper.
PromptInputBar.tsx: Para entrada de texto.
🅿️ Tarea 3.1.3: Hook useSendPromptToAiperMutation (src/lib/api/mutations/aiper.mutations.ts).
Permitirá enviar el prompt y, opcionalmente, un context (ej. ID del lead que se está viendo).
Inicialmente, Aiper solo devolverá respuestas de texto.
🅿️ Tarea 3.1.4: (Opcional) Hook useGetAiperChatHistoryQuery si se implementa historial persistente.
🅿️ Tarea 3.1.5: Integrar WebSocket para recibir respuestas en streaming de Aiper si api-main lo soporta.
Sprint 3.2: Gestión de Perfil de Empresa para portal-imoveis
🅿️ Tarea 3.2.1: Crear ruta y página (dashboard)/portal-content/company-profile/page.tsx.
🅿️ Tarea 3.2.2: Desarrollar CompanyProfileEditor.tsx (src/components/portal-content/).
Campos: Nombre público, "Sobre Nosotros", contacto, redes, logo público (seleccionar del futuro banco de assets).
🅿️ Tarea 3.2.3: Hooks useGetTenantCompanyProfileForPortalQuery y useUpdateTenantCompanyProfileForPortalMutation (src/lib/api/queries|mutations/portal-content.\*.ts).
Sprint 3.3: Gestión de Propiedades/SPEs para portal-imoveis (CRUD Básico)
🅿️ Tarea 3.3.1: Ruta y página (dashboard)/portal-content/properties/page.tsx.
🅿️ Tarea 3.3.2: Componente PropertyDataTable.tsx (lista de propiedades/SPEs del tenant).
🅿️ Tarea 3.3.3: Ruta y página (dashboard)/portal-content/properties/create/page.tsx y [propertyId]/page.tsx.
🅿️ Tarea 3.3.4: Componente PropertyForm.tsx (campos principales: nombre, descripción, tipo, ubicación, precio, estado. Sin gestión de imágenes compleja aún).
🅿️ Tarea 3.3.5: Hooks CRUD para propiedades (useListTenantPropertiesForPortalQuery, useGetTenantPropertyForPortalQuery, useCreateTenantPropertyForPortalMutation, useUpdateTenantPropertyForPortalMutation).
Sprint 3.4: Banco de Assets del Tenant (Imágenes y Logos)
🅿️ Tarea 3.4.1: Rutas y páginas bajo (dashboard)/settings/assets/.
🅿️ Tarea 3.4.2: Componente AssetManager.tsx o ImageLibrary.tsx, LogoLibrary.tsx.
Funcionalidad de subida de archivos a api-main (que los guarda en storage aislado).
Listado con previsualización.
🅿️ Tarea 3.4.3: Hooks useListTenantAssetsQuery, useUploadTenantAssetMutation, useDeleteTenantAssetMutation.
🅿️ Tarea 3.4.4: Integrar selección de logo desde este banco en BrandingForm.tsx.
🅿️ Tarea 3.4.5: Integrar selección de imágenes desde este banco en PropertyForm.tsx (para la galería de la propiedad).
Fase 4: Funcionalidades Avanzadas y Refinamiento Continuo (Iterativo)
Objetivo: Completar módulos, añadir funcionalidades avanzadas, y refinar la experiencia de usuario y el rendimiento.
🅿️ Sprint 4.x: Gestión de Consultores (Módulo 5 Completo)
CRUD completo de usuarios del tenant.
Roles y permisos (visualización en UI).
🅿️ Sprint 4.x: Importación de Leads (Módulo 3 Completo)
UI para mapeo de columnas.
Feedback de progreso y resultados de importación (vía WebSocket).
🅿️ Sprint 4.x: Plantillas WA Avanzadas (Módulo 4 Completo)
Soporte en MessageTemplateForm.tsx para TODOS los tipos de componentes (Header multimedia completo, todos los tipos de Botones) basado en la especificación final de Meta.
Integración del banco de assets para Headers multimedia.
🅿️ Sprint 4.x: Analíticas de WhatsApp (Módulo 4 Completo)
Dashboards interactivos con Recharts.
Filtros y desgloses detallados.
🅿️ Sprint 4.x: Dashboard Principal (Módulo 2 Completo)
Integración de todos los KPIs y datos reales desde api-main.
🅿️ Sprint 4.x: Apariencia del Micrositio Portal (portal-content/site-appearance)
Configuración de color de acento, banner para portal-imoveis.
🅿️ Sprint 4.x: Mejoras Generales de UX/UI y Performance
Optimización mobile-first completa.
Skeletons y estados de carga refinados.
Transiciones y animaciones sutiles.
Pruebas de performance y optimización de TTI/LCP.
Auditoría y mejoras de accesibilidad (a11y).
🅿️ Sprint 4.x (Opcional/Post-MVP Inicial): Internacionalización (i18n)
Integración de librería i18n.
Extracción de strings y creación de archivos de traducción base (ej. es, en, pt-BR).

---

---

Fase 0: Consolidación de la Fundación y Estructura de la Aplicación (ACTUALIZACION)
Objetivo: Crear una estructura de aplicación robusta, configurar los providers esenciales, e implementar los layouts principales y la navegación básica.
Sprint 0.1: Configuración de Providers y Estructura de Layouts (Revisado - Basado en lo existente y próximo paso lógico)
✅ Tarea 0.1.1: Aplicación pwa-supervisor generada y configuraciones básicas (Tailwind, ESLint, TSConfig) establecidas. (Existente)
✅ Tarea 0.1.2: RootLayout (src/app/layout.tsx) implementado con importación de fuentes y Providers. (Existente)
✅ Tarea 0.1.3: Providers (src/components/providers/index.tsx) implementado con ThemeProvider. (Existente)
✨ NUEVO - Tarea 0.1.4 (Reemplaza parte de la antigua 0.1.3): Expandir Providers para incluir:
QueryClientProvider (TanStack Query).
Stores de Zustand (mínimos iniciales):
src/store/auth.store.ts: Para user, isAuthenticated, tenantId.
src/store/ui.store.ts: Para estado de UI global (ej. isSidebarOpen, theme).
src/store/notification.store.ts: Para manejar toasts/notificaciones.
Un provider raíz de Zustand o múltiples providers individuales.
✨ NUEVO - Tarea 0.1.5 (Integra antigua 0.1.4 y parte de 0.1.5): Establecer Grupos de Rutas y Layouts Principales:
Crear src/app/(auth)/layout.tsx (AuthLayout - minimalista).
Crear src/app/(dashboard)/layout.tsx (DashboardLayout - Server Component).
Este layout verificará la autenticación (inicialmente mockeada, luego integrada con auth.store.ts). Si no autenticado, redirigirá a /login.
Renderizará AppLayoutClient.
Mover el contenido actual de src/app/page.tsx a src/app/(dashboard)/dashboard/page.tsx.
Eliminar o redirigir la src/app/page.tsx raíz (o convertirla en una landing si es necesario fuera del scope del supervisor).
✨ NUEVO - Tarea 0.1.6: Implementar AppLayoutClient.tsx (src/components/layout/AppLayoutClient.tsx - Client Component):
Contendrá la estructura visual principal (Sidebar, TopNavigation, área de contenido principal).
Implementar Sidebar.tsx y TopNavigation.tsx (src/components/layout/) con estructura HTML/Tailwind básica y navegación estática/mockeada inicial.
Conectar el estado isSidebarOpen de ui.store.ts para controlar la visibilidad del Sidebar.
✨ NUEVO - Tarea 0.1.7 (Mejora ui-shared): Añadir test target al project.json de libs/ui-shared. Configurar Jest básico para esta librería (puede ser passWithNoTests: true inicialmente).
Sprint 0.2: Flujo de Autenticación Completo y Navegación Funcional
🅿️ Tarea 0.2.1: Página de Login (src/app/(auth)/login/page.tsx) y componente LoginForm.tsx. (Como en roadmap original)
🅿️ Tarea 0.2.2: auth.store.ts completamente funcional para almacenar y exponer el estado de autenticación.
🅿️ Tarea 0.2.3: Hook useLoginMutation (TanStack Query en src/lib/api/mutations/auth.mutations.ts) para llamar a api-main.
🅿️ Tarea 0.2.4: Lógica segura de cliente para manejar el JWT (HttpOnly cookie es ideal, gestionado por api-main).
🅿️ Tarea 0.2.5: Integración de LoginForm con useLoginMutation y auth.store.ts. Redirección a /dashboard al éxito.
🅿️ Tarea 0.2.6: Sidebar.tsx y TopNavigation.tsx funcionales:
UserMenu.tsx en TopNavigation mostrando datos del usuario desde auth.store.ts y con botón de Logout (limpia store y JWT, redirige a /login).
Navegación en Sidebar.tsx usando next/link a las rutas principales que se crearán (Dashboard, Leads, WhatsApp, etc.).
Manejo de estado activo del link de navegación.
Fase 1: Integración de Funcionalidades Core (WhatsApp y Leads como ejemplo inicial)
Objetivo: Conectar pwa-supervisor a api-main para funcionalidades clave, demostrando el flujo de datos y la interacción con el backend.
Sprint 1.1: Configuración y Listado de Cuentas WhatsApp
🅿️ Tarea 1.1.1: Página (dashboard)/whatsapp/setup/page.tsx y WhatsappInitialSetupForm.tsx.
🅿️ Tarea 1.1.2: Hook useSetTenantWhatsAppConfigMutation.
🅿️ Tarea 1.1.3: Página (dashboard)/whatsapp/accounts/page.tsx y WhatsappAccountDataTable.tsx.
🅿️ Tarea 1.1.4: Hook useListTenantWhatsAppAccountsQuery.
🅿️ Tarea 1.1.5: Componente WhatsappAccountStatus.tsx (usando Badge de ui-shared) para mostrar calidad y estado.
🅿️ Tarea 1.1.6: Conexión WebSocket inicial (en AppLayoutClient o un provider) para recibir actualizaciones (whatsAppAccountHealthUpdated) e invalidar la query de useListTenantWhatsAppAccountsQuery.
Sprint 1.2: Listado Básico de Leads
🅿️ Tarea 1.2.1: Página (dashboard)/leads/page.tsx y LeadDataTable.tsx.
🅿️ Tarea 1.2.2: Hook useListLeadsQuery (con paginación y filtros básicos).
🅿️ Tarea 1.2.3: Componente LeadStatusBadge.tsx.
Fase 2: Profundización en Módulos (Aiper, Portal-Imoveis) y Personalización Avanzada
Objetivo: Implementar las interfaces para Aiper, la gestión de contenido del portal, y las capacidades de personalización, asegurando que la arquitectura frontend soporte estos flujos complejos y la naturaleza personalizable de la suite.
Sprint 2.1: Dashboard de Aiper y Contextualización
🅿️ Tarea 2.1.1: Página (dashboard)/aiper/page.tsx.
🅿️ Tarea 2.1.2: Componentes AiperChatInterface.tsx, ChatMessageBubble.tsx, PromptInputBar.tsx.
🅿️ Tarea 2.1.3: Hook useSendPromptToAiperMutation.
Personalización: Este hook (o la lógica que lo llama) deberá obtener la "Identidad del Tenant" (Misión, Visión, Tono) desde un nuevo store (ej. tenant.store.ts o config.store.ts) o una query específica. Esta identidad se enviará junto con el prompt a api-main para que Aiper pueda adaptar sus respuestas.
🅿️ Tarea 2.1.4: El dashboard de Aiper podría mostrar sugerencias o insights basados en el contexto de lo que el supervisor está viendo en otras partes de pwa-supervisor (ej. si está en la página de un lead específico, Aiper podría ofrecer analizar esa conversación). Esto implica pasar contexto adicional a api-main.
Sprint 2.2: Gestión de Perfil y Contenido Básico para Portal-Imoveis
🅿️ Tarea 2.2.1: Secciones en (dashboard)/portal-content/:
company-profile/page.tsx con CompanyProfileEditor.tsx.
properties/page.tsx con PropertyDataTable.tsx y properties/create/page.tsx con PropertyForm.tsx (CRUD básico).
🅿️ Tarea 2.2.2: Hooks para CRUD de perfil y propiedades.
Integración Visual: La PropertyForm permitirá usar el "Banco de Assets" (futuro) para imágenes.
Personalización: La sección (dashboard)/portal-content/site-appearance/page.tsx permitirá configurar colores y banners para el micrositio, información que portal-imoveis consumirá.
Sprint 2.3: Personalización Avanzada de pwa-supervisor y Banco de Assets
🅿️ Tarea 2.3.1: Página (dashboard)/settings/branding/page.tsx y BrandingForm.tsx.
Subida de logo y selección de color primario.
Estos se aplicarán dinámicamente a la UI de pwa-supervisor (variables CSS, como se mencionó en el roadmap original).
🅿️ Tarea 2.3.2: Página (dashboard)/settings/identity/page.tsx y TenantIdentityForm.tsx para configurar la "personalidad" de Aiper.
🅿️ Tarea 2.3.3: Banco de Assets ((dashboard)/settings/assets/).
Componente AssetManager.tsx para subida y gestión de imágenes/logos del tenant. api-main guardará estos assets en un storage aislado (ej. S3 bucket con prefijo tenantId/).
Estos assets se usarán para el logo en pwa-supervisor, imágenes de propiedades en portal-imoveis, y futuramente para headers multimedia en plantillas WhatsApp.
Justificación de las Mejoras y Enfoque Holístico:
Fundación Primero: El roadmap revisado asegura que todos los providers (ThemeProvider, QueryClientProvider, Zustand) y la estructura de layout (AppLayoutClient, DashboardLayout, AuthLayout) estén en su lugar ANTES de construir las páginas de features. Esto evita refactorizaciones mayores después.
Alineación con Snapshot: Comienza desde lo que ya existe (RootLayout, Providers parcial) y lo expande lógicamente.
Mejora Continua (ui-shared): Incorpora la adición del target de test a ui-shared temprano, fomentando la calidad desde la base.
Integración Temprana de Personalización (Conceptual):
La "Identidad del Tenant" para Aiper y la configuración de "Branding" para pwa-supervisor y portal-imoveis se introducen como conceptos clave que influirán en el diseño de los stores y las llamadas a api-main.
El "Banco de Assets" se planifica como un repositorio central para los recursos visuales del tenant.
Visión de portal-imoveis y Aiper desde el inicio: Aunque la implementación completa de portal-imoveis (como app pública) y las capacidades avanzadas de Aiper vendrán después, pwa-supervisor se diseña desde el principio para ser el CMS y el centro de configuración para ambos. Esto asegura que los modelos de datos y las APIs en api-main se diseñen con esta integración en mente.
Por ejemplo, la PropertyForm en pwa-supervisor es lo que alimenta los listados en portal-imoveis. La TenantIdentityForm es lo que Aiper usa para su personalización.
Priorización Lógica de Funcionalidades:
Autenticación es fundamental.
WhatsApp es un pilar, por lo que su configuración y monitoreo vienen después.
Leads son el core del negocio, siguen inmediatamente.
Aiper y Portal-Imoveis se construyen sobre la base del tenant ya configurado y con datos fluyendo.
Alta Performance y UX:
El uso de Server Components para layouts y TanStack Query para data fetching es intrínseco.
La personalización visual se manejará con variables CSS para eficiencia.
El Banco de Assets implicará una reflexión sobre la optimización de imágenes y el almacenamiento.
Este roadmap revisado intenta ser más orgánico con el estado actual del snapshot, al mismo tiempo que incorpora la visión completa de personalización e integración con Aiper y portal-imoveis desde las primeras etapas de diseño conceptual para pwa-supervisor.

---

---

ase 0: Consolidación, Corrección y Conexión Backend Inicial
Sprint Actual (Llamémoslo "Sprint de Consolidación y Corrección"):
🎯 Tarea Prioritaria 1: Corregir apps/pwa-supervisor/project.json
Restaurar los targets (build, serve, test, lint) con la configuración estándar de Nx para una aplicación Next.js. Sin esto, no podemos avanzar con builds ni tests.
🎯 Tarea Prioritaria 2: Resolver Duplicación de page.tsx
Reemplazar apps/pwa-supervisor/src/app/page.tsx con la lógica de redirección (a /dashboard o /login según autenticación, que se refinará cuando AuthGuard use el estado real del store y/o haya lógica de sesión de servidor).
🎯 Tarea Prioritaria 3: Mejorar AuthGuard.tsx
Asegurar que la inicialización del auth.store.ts (ej. desde localStorage si se usa persist de Zustand, o una llamada meTenant inicial) ocurra ANTES de que AuthGuard tome decisiones. Esto podría implicar llamar a una acción de inicialización en AppProviders o RootLayout.
🎯 Tarea Prioritaria 4: Mejorar TopNav.tsx
Reemplazar la implementación manual de DropdownMenu con el componente de ui-shared/Shadcn.
Conectar el menú de usuario para mostrar el nombre del auth.store.ts y hacer funcional el logout (llamando a la acción del auth.store.ts).
🎯 Tarea Prioritaria 5: Mejorar QuickActionButton.tsx en (dashboard)/page.tsx
Usar Link de next/link para navegación interna en lugar de window.location.href.
🎯 Tarea Prioritaria 6 (Librería ui-shared):
Añadir target test a ui-shared/project.json.
Crear tests unitarios/componentes básicos para Button.tsx, Card.tsx, etc.
(Opcional) Integrar CardHover.tsx.
Tarea 0.2.3 (Continuación): Conectar performApiLogin en useAuth.ts a la API GraphQL real de api-main para la mutación loginTenantUser. Esto implica:
Definir la query GraphQL.
Configurar un cliente GraphQL simple (ej. graphql-request o fetch wrapper) en src/lib/api/client.ts.
Manejar el token JWT devuelto por api-main (almacenamiento seguro, ej. en auth.store.ts si no es HttpOnly cookie, o solo confirmar recepción si es HttpOnly).
Tarea 0.2.6 (Refinamiento):
Refinar Sidebar.tsx y TopNav.tsx para que el título y el logo sean dinámicos (placeholders por ahora, pero preparar la estructura).

---

---

Nota sobre Efectos de Movimiento, Presentación y Consideraciones de Performance/Conflicto
Los efectos visuales y animaciones observados en el snapshot del proyecto "Hostinger Horizons / web-app", como:
Animaciones sutiles de flotación y pulso en elementos clave (logo).
Transiciones de aparición gradual (opacity, slide-in).
Efectos visuales temáticos (como el MatrixTerminal).
Interacciones enriquecidas en componentes UI (como el CardHover que analizamos anteriormente, o el LoginDialog con animación de entrada).
Son, en general, altamente deseables para dfs-invest-suite y específicamente para pwa-supervisor, siempre y cuando se implementen con las siguientes consideraciones cruciales:
Prioridad en la Agilidad y Performance:
Principio Clave: Las animaciones y efectos visuales deben mejorar la experiencia del usuario, no entorpecerla. La agilidad de la interfaz (respuesta rápida a las interacciones) y la performance general (tiempo de carga, uso de CPU/memoria) son prioritarias.
Optimización:
Utilizar librerías de animación eficientes como Framer Motion (ya presente en el ejemplo y planeada para pwa-supervisor según el roadmap) que está optimizada para el rendimiento y aprovecha la aceleración por hardware cuando es posible.
Animar propiedades transform (translate, scale, rotate) y opacity siempre que sea posible, ya que son más baratas de animar para el navegador que propiedades que afectan el layout (como width, height, margin, padding).
Evitar animaciones excesivas o innecesariamente complejas en elementos que se repiten mucho (ej. en cada fila de una tabla grande).
Utilizar requestAnimationFrame o hooks de Framer Motion que lo usen internamente para sincronizar animaciones con el refresco del navegador.
Implementar "lazy loading" para componentes con animaciones pesadas si no son visibles inmediatamente.
Monitorear la performance con las DevTools del navegador (especialmente el panel de Performance y Rendering) para identificar cuellos de botella.
Consistencia y Propósito:
Las animaciones deben ser consistentes con la identidad de marca de DFS Invest Suite y el propósito de la pwa-supervisor (una herramienta profesional y eficiente).
Deben tener un propósito claro: guiar la atención del usuario, proporcionar feedback sobre interacciones, mejorar la percepción de fluidez, o añadir un toque de sofisticación sin ser una distracción.
Evitar efectos "gratuitos" que no aporten valor a la UX.
Accesibilidad (a11y):
Considerar la opción prefers-reduced-motion. Los usuarios que han activado esta preferencia en su sistema operativo no deberían ser sometidos a animaciones excesivas. Framer Motion y CSS pueden respetar esta preferencia.
Asegurar que las animaciones no dificulten la lectura o la interacción para usuarios con ciertas discapacidades visuales o cognitivas.
Integración con el Stack Tecnológico de dfs-invest-suite (Next.js vs. Vite):
Vite en el Snapshot vs. Next.js en dfs-invest-suite: El snapshot analizado usa Vite. Nuestro proyecto dfs-invest-suite (y pwa-supervisor) está definido con Next.js.
Framer Motion: Es compatible tanto con Vite como con Next.js. La forma de integrarlo y usarlo es muy similar.
Tailwind CSS: Compatible con ambos.
Potenciales Conflictos de Vite (no aplicables directamente a dfs-invest-suite con Next.js):
La configuración extensiva de vite.config.js para el manejo de errores y monkey-patching (configHorizonsViteErrorHandler, etc.) es específica de ese proyecto Vite y de su posible ejecución dentro de un entorno "Hostinger Horizons". Esta parte no se trasladaría directamente a la configuración de Next.js de pwa-supervisor. Next.js tiene sus propios mecanismos de manejo de errores y no requiere este tipo de inyección manual de scripts en index.html.
Si dfs-invest-suite necesitara un sistema similar de reporte de errores a un contenedor padre (lo cual no está en los requisitos actuales), se implementaría de una forma adaptada a Next.js y al entorno de ejecución de pwa-supervisor.
Conflicto con Otras Librerías (General):
Cualquier librería de animación puede tener conflictos si otra librería intenta manipular directamente los mismos estilos o propiedades del DOM de forma no coordinada. Sin embargo, Framer Motion es bastante robusta y suele coexistir bien.
El principal "conflicto" suele ser de performance si se abusa de las animaciones o si se anima de forma ineficiente, lo que puede impactar la fluidez general de la aplicación, independientemente del bundler (Vite o Webpack/Turbopack con Next.js).
Conclusión para dfs-invest-suite y pwa-supervisor:
Sí, el nivel de pulido visual, los efectos de hover interactivos (como CardHover), las transiciones suaves y las animaciones con propósito son definitivamente el estándar de calidad que queremos para pwa-supervisor.
Adoptaremos Framer Motion como nuestra librería principal para animaciones complejas o de transición en pwa-supervisor.
Integraremos estos efectos de forma gradual y medida, siempre evaluando su impacto en la performance y la UX.
Los componentes de ui-shared pueden incorporar estos efectos (como CardHover) para que sean reutilizables.
Nos enfocaremos en animaciones que mejoren el feedback, guíen al usuario y aporten una sensación de calidad profesional, sin sobrecargar la interfaz.
La configuración específica de Vite del snapshot de "Hostinger Horizons" (manejo de errores, etc.) no es directamente transferible a nuestro next.config.js, pero la inspiración para crear una experiencia de usuario visualmente rica y animada sí lo es.

---

---

Bitácora de Desarrollo DFS-Invest-Suite
Fecha: 2025-05-14
Desarrolladores: RaZ WriTe (Líder Estratégico), L.I.A Legacy (IA Senior Developer)
Hito Actual: Fase 0 - Consolidación de Fundación y Estructura pwa-supervisor y Configuración Global de ESLint.
Objetivo de la Jornada:
Resolver problemas persistentes de configuración de ESLint en todo el monorepo, particularmente los errores de "parsing" y "none of those TSConfigs include this file". Establecer una configuración de ESLint (flat config) robusta y escalable. Avanzar en la estructura inicial de pwa-supervisor según el roadmap ajustado.
Resumen de Actividades y Decisiones:
La jornada se centró intensamente en diagnosticar y corregir la configuración de ESLint para todo el monorepo, utilizando un enfoque iterativo y probando con proyectos individuales después de cada ajuste en la configuración raíz (eslint.config.mjs) y las configuraciones locales de los proyectos.
Diagnóstico Inicial y Estrategias Fallidas (Recap):
Se identificó que el error principal era la incapacidad de ESLint para encontrar archivos (.spec.ts, index.ts) dentro de los parserOptions.project definidos, especialmente cuando se activaban reglas que requerían información de tipos (recommended-type-checked).
Múltiples intentos de ajustar los patrones files e ignores en un único eslint.config.mjs raíz no resolvieron completamente el problema para todos los contextos de archivo (código fuente, tests, archivos de config, barrel files).
Cambio de Enfoque: Simplificación del eslint.config.mjs Raíz y Control Local:
Decisión Clave: Se adoptó una estrategia donde el eslint.config.mjs raíz se simplifica para proveer configuraciones base (plugins, reglas generales no dependientes de tipos, depConstraints de Nx) y NO define parserOptions.project globalmente para el código fuente o tests.
Cada proyecto (app o librería) se vuelve responsable de su propio eslint.config.mjs local. Este archivo local:
Hereda la configuración base del raíz.
Define explícitamente languageOptions.parserOptions.project apuntando a sus tsconfig.lib.json (o app.json) y tsconfig.spec.json específicos (junto con el tsconfig.base.json raíz para los alias).
Activa las reglas que requieren información de tipos (recommended-type-checked) dentro de estos bloques con parserOptions.project bien definido.
Maneja configuraciones específicas del framework (ej. next/core-web-vitals para pwa-supervisor).
Ajustes en tsconfig Individuales:
Se revisó y estandarizó la estructura de tsconfig.json (raíz del proyecto), tsconfig.lib.json (o app.json), y tsconfig.spec.json para varias librerías y aplicaciones.
Clave: tsconfig.lib.json (o app.json) incluye solo el código fuente y excluye tests. tsconfig.spec.json incluye los archivos de test y jest.config.ts.
Correcciones Específicas de Código (Ejemplos):
libs/shared/utils/src/lib/uuid.utils.spec.ts: Se corrigió un error @typescript-eslint/no-unsafe-argument asegurando que el valor pasado a RegExp.prototype.test() sea un string.
libs/core/domain/tenancy/src/lib/events/tenant-created.event.ts: Se simplificó ITenantCreatedEventPayload eliminando una firma de índice potencialmente conflictiva para resolver un error de parsing.
libs/core/domain/shared-kernel/commands-queries/src/lib/command.base.spec.ts: Se eliminó la importación no utilizada GuardType.
Progreso en pwa-supervisor (Basado en Snapshot y Ajustes):
Fundación Sólida: El snapshot 2025-05-14-17-37-04 reveló que pwa-supervisor ya tenía una estructura de directorios avanzada con grupos de rutas (auth) y (dashboard), layouts básicos, AuthGuard, stores de Zustand, y configuración de TanStack Query.
project.json Corregido: Se restauraron los targets esenciales (build, serve, test, lint).
Duplicación de page.tsx Resuelta: apps/pwa-supervisor/src/app/page.tsx ahora redirige a /dashboard.
Mejoras en AuthGuard.tsx y auth.store.ts: Se introdujo isAuthInitialized para un manejo más robusto de la carga inicial del estado de autenticación.
Mejoras en TopNav.tsx: Se integró DropdownMenu de ui-shared (conceptualmente) y se conectó el logout al auth.store.ts.
Mejoras en (dashboard)/page.tsx: Se actualizó QuickActionButton para usar next/link.
Lógica Implementada y Artefactos Clave para pwa-supervisor (hasta ahora):
Estructura de Rutas (App Router):
src/app/layout.tsx (RootLayout con AppProviders)
src/app/(auth)/layout.tsx (AuthLayout)
src/app/(auth)/login/page.tsx (Página de Login)
src/app/(auth)/login/components/login-form.tsx (Formulario de Login con lógica de estado, mutación y redirección)
src/app/(dashboard)/layout.tsx (DashboardLayout que usa AuthGuard y AppLayoutClient)
src/app/(dashboard)/page.tsx (Página del Dashboard principal con UI y datos mock)
src/app/page.tsx (Redirección a /dashboard)
Componentes de Layout y UI:
src/components/providers/index.tsx (AppProviders con ThemeProvider, QueryClientProvider, Toaster, y llamada a initializeAuth)
src/components/auth/AuthGuard.tsx (Protección de rutas del lado del cliente)
src/components/layout/AppLayout.tsx (Estructura principal con Sidebar y TopNav)
src/components/layout/Sidebar.tsx (Navegación principal)
src/components/layout/TopNav.tsx (Barra superior con menú de usuario, toggle de tema, logout)
src/components/layout/MobileNav.tsx (Navegación inferior para móviles, aunque no integrada aún)
Gestión de Estado y Datos:
src/store/auth.store.ts (Zustand: para user, isAuthenticated, isAuthInitialized, isLoading, error y acciones)
src/store/ui.store.ts (Zustand: para theme, isSidebarOpen)
src/store/notification.store.ts (Zustand: base para notificaciones)
src/lib/config/queryClient.ts (Configuración de TanStack Query)
src/hooks/api/useAuth.ts (Hook con useMutation para performApiLogin simulado)
Dependencia de ui-shared: Uso extensivo de componentes y utilidades.
Roadmap Ajustado para pwa-supervisor (Foco en Próximos Pasos):
El "Sprint de Consolidación y Corrección" está casi completo en términos de configuración. Los próximos pasos se centran en completar la funcionalidad básica del layout y la autenticación, y luego pasar a los módulos principales.
Sprint Actual (Finalizando Consolidación):
✅ Tarea Prioritaria 1: Corregir apps/pwa-supervisor/project.json (Hecho)
✅ Tarea Prioritaria 2: Resolver Duplicación de page.tsx (Hecho)
✅ Tarea Prioritaria 3: Mejorar AuthGuard.tsx y auth.store.ts (Hecho)
✅ Tarea Prioritaria 4: Mejorar TopNav.tsx (Hecho)
✅ Tarea Prioritaria 5: Mejorar QuickActionButton.tsx en (dashboard)/page.tsx (Hecho)
✅ Tarea Prioritaria 6 (Librería ui-shared): Configuración de tests y tests básicos (Hecho)
⏳ Tarea Actual/Siguiente: Resolver los errores de linting de código restantes en pwa-supervisor y las librerías core-\* una vez que la configuración de ESLint esté 100% estable para todos los proyectos.
Sprint 0.2 (Continuación): Flujo de Autenticación Completo y Layout Funcional
🅿️ Tarea 0.2.3 (Real): Conectar performApiLogin en useAuth.ts a la API GraphQL real de api-main para loginTenantUser. Manejar JWT.
🅿️ Tarea 0.2.6 (Refinamiento):
Sidebar.tsx: Logo dinámico (branding del tenant), ítems de navegación dinámicos (según rol/permisos).
TopNav.tsx: Título de página dinámico.
AppLayoutClient.tsx: Pasar datos reales de usuario y branding (desde stores/API).
Fase 1: Funcionalidades Core de WhatsApp (Como se definió anteriormente)
Sprint 1.1: Configuración Inicial de WhatsApp.
Sprint 1.2: Listado y Detalle de Cuentas/Números WhatsApp.
... (y así sucesivamente con los módulos de Leads, Aiper, Portal-Content).
Objetivo a Lograr (Visión Holística para pwa-supervisor):
Se busca crear una PWA robusta, personalizable y de alto rendimiento que sirva como el centro de mando integral para cada tenant. Esto implica:
Una base técnica sólida: Tipado estricto, tests, configuración de ESLint/Prettier funcional, estructura de directorios clara.
Experiencia de Usuario (UX) fluida: Navegación rápida (Next.js App Router), feedback inmediato, diseño intuitivo y responsive.
Gestión de Estado predecible: Con Zustand para UI global y TanStack Query para estado del servidor.
Integración Profunda con api-main: Consumo eficiente de la API GraphQL para todas las operaciones de datos y de negocio.
Preparación para Personalización:
Visual: La UI de pwa-supervisor (colores, logos) se adaptará al branding del tenant.
Funcional (Aiper): La "Identidad del Tenant" (misión, tono, etc.) configurada aquí será utilizada por Aiper Assistance para personalizar sus interacciones.
Contenido (Portal-Imoveis): pwa-supervisor actuará como el CMS para que el tenant gestione la información y apariencia de su micrositio público.
Escalabilidad y Mantenibilidad: Código modular, bien documentado y que siga las convenciones establecidas.
Deuda Técnica / Estándares Pendientes (Global ESLint):
Revisar project.json de api-main: El snapshot muestra "passWithNoTests": true. Debe cambiarse a false y añadir tests. Su build target usa nx:run-commands con webpack-cli directamente, lo cual es inusual para un proyecto NestJS en Nx que normalmente usaría @nx/nest:build o @nx/webpack:webpack. Esto podría ser una fuente de problemas.
Revisar eslint.config.mjs locales: Asegurar que todas las librerías y apps (especialmente api-main y las de core) tengan su eslint.config.mjs local siguiendo el patrón que funcionó para ui-shared y shared-utils (definiendo su parserOptions.project para sus tsconfig.lib/app.json y tsconfig.spec.json).
Resolver warnings de no-unused-vars: Una vez que el parsing esté OK, eliminar o justificar estos warnings.
Resolver no-explicit-any: Donde sea posible, reemplazar any por tipos más específicos.
El foco inmediato sigue siendo estabilizar la configuración de ESLint para todos los proyectos. Luego, se podrán abordar los errores de código con más confianza.

---

---
