1EuZ5p9F3Ew1PkadZR1UljZosc09Y2sl1 iamdfsinvestimentos.dev7

Documento Maestro de Convenciones y Estándares para DFS-Invest-Suite, basándome en el análisis del proyecto actual (snapshot), las mejoras transversales propuestas, y las mejores prácticas de la industria para un monorepo Nx con arquitectura hexagonal y DDD.
Este documento será extenso y detallado, cubriendo los tópicos solicitados con ejemplos.
DOCUMENTO MAESTRO DE CONVENCIONES Y ESTÁNDARES
Proyecto: DFS-Invest-Suite
Versión: 1.0 (2025-05-13)
Tabla de Contenidos:
Introducción
1.1. Propósito de este Documento
1.2. Audiencia
1.3. Cómo Usar este Documento
1.4. Principios Generales
Nomenclatura y Estilos de Código
2.1. Lenguaje Principal
2.2. Nomenclatura de Archivos
2.3. Nomenclatura de Variables y Constantes
2.4. Nomenclatura de Funciones y Métodos
2.5. Nomenclatura de Clases e Interfaces
2.6. Nomenclatura de Enums
2.7. Nomenclatura de Módulos y Librerías Nx
2.8. Comentarios y Documentación JSDoc/TSDoc
2.9. Estilo de Código (Prettier)
Estructura de Directorios y Arquitectura
3.1. Estructura General del Monorepo (Nx)
3.2. Capas Arquitectónicas (Hexagonal)
3.3. Organización Interna de Librerías (src/lib/)
3.4. Barrel Files (index.ts)
Implementación Específica de Patrones DDD
4.1. Entidades (*.entity.ts)
4.2. Value Objects (*.vo.ts)
4.3. AggregateEntendido. Basándome en todo el análisis del proyecto DFS-Invest-Suite (blueprint, bitácora, roadmap, deuda técnica y el snapshot del código), crearé un Documento Maestro de Convenciones y Estándares para el proyecto.
Este documento será exhaustivo y cubrirá las categorías solicitadas, integrando las convenciones ya observadas, las implícitas, y alineándolas con las mejoras propuestas y las mejores prácticas para una arquitectura mon Roots
4.4. Eventos de Dominio (*.event.ts)
4.5. Repositorios (Puertos: *.repository.port.ts)
4.6. Servicios de Dominio (Si aplican)
4.7. Módulos de Dominio (Librerías libs/core/domain/<bounded-context>/)
5. Uso Avanzado de TypeScript
5.1. Strict Mode ("strict": true)
5.2. Tipos Utilitarios y Branded Types (libs/shared/types/)
5.3. Genéricos
5.4. Enums vs. Unionorepo hexagonal con Nx y DDD.
Dado el alcance, este documento será extenso. Lo estructuraré claramente.
DOCUMENTO MAESTRO DE CONVENCIONES Y ESTÁNDARES
Proyecto: DFS-Invest-Suite
Versión: 1.0 (2025-05-13)
Tabla de Contenidos
Introducción
1.1. Propósito del Documento
1.2. Audiencia
1.3. Cómo Usar Este Documento
1.4. Principios Generales
Nomenclatura y Estilos de Código
2.1. General (TypeScript/JavaScript)
2.2. Nombres de Archivos
2.3. Nombres de Clases
2.4. Nombres de Interfaces
2.5. Nombres de Tipos ( Types de Strings Literales
5.5. unknown vs. any
5.6. Aserciones de Tipo (as)
Configuraciones Técnicas
6.1. ESLint (eslint.config.mjs)
6.1.1. Reglas Generales
6.1.2. Límites de Módulo (@nx/enforce-module-boundaries y Tags)
6.2. Prettier (.prettierrc)
6.3. TypeScript (tsconfig.*.json)
6.4. Nx (nx.json, project.json)
6.5. Gestor de Paquetes (PNPM y pnpm-workspace.yaml)
Manejo de Errores
7.1. Patrón Result<T, E> (libs/shared/result/)
7.2. Excepciones Personalizadas (libs/shared/errors/ y específicas de dominio)
7.3. Códigos de Error
7.4. Logging de Errores
Patrones de Pruebas
8.1. Tipos de Tests y su Ubicación (*.spec.ts)
8.2. Framework de Pruebas (Jest)
8.3. Cobertura de Código
8.4. Mocking y Stubs
8.5. Tests paraType Aliases)
2.6. Nombres de Enums
2.7. Nombres de Funciones y Métodos
2.8. Nombres de Variables y Propiedades
2.9. Nombres de Constantes
2.10. Comentarios y JSDoc/TSDoc
2.11. Importaciones
Estructura de Directorios y Arquitectura (Nx Monorepo Hexagonal)
3.1. Estructura General del Monorepo (apps/, libs/)
3.2. Estructura Interna de Librerías (src/lib/, src/index.ts)
3.3. Capas Arquitectónicas (Hexagonal)
3.3.1. libs/shared/
3.3.2. libs/core/domain/shared-kernel/
3.3 Casos de Uso, Entidades, VOs, etc.
8.6. Tests E2E (apps/*-e2e/)
Convenciones de API (para api-main)
9.1. Estilo de API (GraphQL first, REST como fallback o para casos específicos)
9.2. Estructura de Respuesta Estándar (IApiResponse<T>)
9.3. Versionado de API (Futuro)
9.4. Autenticación (JWT) y Autorización (RBAC)
9.5. Validación de DTOs de Entrada (Zod a través de Pipes)
9.6. Códigos de Estado HTTP
Documentación
10.1. Comentarios en Código (JSDoc/TSDoc)
10.2. READMEs de Librerías y Aplicaciones
10.3. Documentación Arquitectónica (.DOCUMENTO-TECNICO-PROYECTO.md)
10.4. Bitácora de Desarrollo (.BITACORA.md)
10.5. Registro de Deuda Técnica (.DEUDA-TECNICA.md)
10.6. Roadmap (.ROADMAP.md)
10.7. Documentación de API (Swagger/OpenAPI para REST, GraphQL Schema para GraphQL)
Mecanismos de Validación de Convenciones
11.1. ESLint
11.2. Prettier
11.3. TypeScript Compiler (tsc)
11.4. Hooks de Git (Husky, lint-staged)
11.5. CI Pipeline Checks
1. Introducción
1.1. Propósito de este Documento
Este documento establece las convenciones, estándares y mejores prácticas a seguir durante el desarrollo del proyecto DFS-Invest-Suite. Su objetivo es asegurar la coherencia, calidad, mantenibilidad y escalabilidad del código base, así como facilitar la colaboración entre los miembros del equipo (incluyendo la IA desarrolladora).
1.2. Audiencia
Este documento está dirigido a.3. libs/core/domain/<bounded-context>/
3.3.4. libs/core/application/<bounded-context>/
3.3.5. libs/infrastructure/<adapter-type>/<bounded-context-or-technology>/
3.3.6. apps/<app-name>/
3.4. Tags de Nx y Límites de Módulo (depConstraints)
4. Implementación Específica de Patrones DDD
4.1. Entidades (EntityBase, Entidades Concretas)
4.2. Aggregate Roots (AggregateRootBase, Agregados Concretos)
4.3. Value Objects (ValueObjectBase, VOs Concretos)
4.4. Eventos de Dominio (DomainEventBase, Eventos Concretos, IDomainEventMetadata)
4.5. Repositorios (IRepositoryPort, Implementaciones)
4.6. Servicios de Dominio (Si Aplica)
4.7. Mappers (IMapper)
5. Uso Avanzado de TypeScript
5.1. Tipado Estricto (strict: true y relacionadas)
5.2. Branded Types (Brand<K,T>)
5.3. Tipos Utilitarios (Maybe<T>, ObjectLiteral<V>)
5.4. Genéricos
5.5. Enums vs. Union Types de Strings Literales
5.6. unknown vs. any
5.7. Aserciones de Tipo (as) y Type Guards
6. Configuraciones Técnicas
6.1. ESLint (eslint.config.mjs)
6.2. Prettier (.prettierrc)
6.3. TypeScript (tsconfig.base.json, tsconfig.*.json por proyecto)
6.4. Nx (nx.json, project.json)
6.5. Gestor de Paquetes (PNPM y pnpm-workspace.yaml)
6.6. Jest (jest.preset.js, jest.config.ts por proyecto)
7. Manejo de Errores
7.1. Patrón Result<T,E>
7 todos los desarrolladores, arquitectos y cualquier persona involucrada en el ciclo de vida de desarrollo del software DFS-Invest-Suite.
1.3. Cómo Usar este Documento
Este documento debe ser consultado como una guía de referencia continua. Se espera que los nuevos desarrollos se adhieran a estas convenciones. Las desviaciones deben ser discutidas y justificadas. Este documento es "vivo" y se actualizará a medida que el proyecto evolucione.
1.4. Principios Generales
Claridad sobre Astucia: Escribir código que sea fácil de entender.
Consistencia: Aplicar las mismas convenciones en todo el proyecto.
Calidad Primero: Priorizar la robustez, testabilidad y corrección.
Arquitectura Hexagonal y DDD: Adherirse a los principios y patrones definidos.
Automatización: Usar herramientas para forzar y verificar convenciones siempre que sea posible.
2. Nomenclatura y Estilos de Código
2.1. Lenguaje Principal
Convención: Español para comentarios en el código, nombres de archivos de documentación (.md), mensajes de commit (cuando aplique y sea para el equipo interno). Inglés para todo el código fuente (variables, funciones, clases, interfaces, enums, nombres de archivo .ts, .json, etc.).
Correcto (Comentario): // Obtiene el tenant por su ID.
Correcto (Código): class TenantEntity { ... }
Incorrecto (Código): class EntidadInquilino { ... }
Validación: Revisión de código.
2.2. Nomenclatura de Archivos
Convención: kebab-case.tipo.ts (o kebab-case.ts si el "tipo" es obvio por el directorio). Para tests: kebab-case.spec.ts.
tipo: entity, vo, event, port, command, query, use-case, handler, module, controller, service, dto, schema, constants, utils, config, interface, type, enum.
Correcto: tenant.entity.ts, create-tenant.use-case.ts, logger.port.ts, api-response.interface.ts, tenant-status.vo.spec.ts, eslint.config.mjs.
Incorrecto: TenantEntity.ts, CreateTenantUseCase.ts.
Validación: Revisión de código, scripts de linting de nombres de archivo (potencial).
2.3. Nomenclatura de Variables y Constantes
Variables (mutables): camelCase.
Correcto: let tenantName = '...';
Incorrecto: let TenantName = '...';, let tenant_name = '...';
Constantes (inmutables):
Primitivos o referencias a objetos inmutables: UPPER_SNAKE_CASE.
Correcto: const DEFAULT_PAGE_LIMIT = 10;, const LOGGER_PORT = Symbol('LOGGER_PORT');
Incorrecto: const defaultPageLimit = 10;
Referencias a objetos/arrays que no se reasignan pero cuyo contenido podría ser mutable (aunque se busca la inmutabilidad): camelCase con readonly o const.
.2. Jerarquía de Excepciones (ExceptionBase, Excepciones Genéricas, Excepciones de Dominio)
7.3. Códigos de Error
7.4. Logging de Errores
7.5. Manejo de Errores en Casos de Uso y API
Patrones de Pruebas
8.1. Tipos de Tests (Unitarios, Integración, E2E) y su Alcance
8.2. Nomenclatura de Archivos de Test (.spec.ts)
8.3. Estructura de Tests (Describe, It, BeforeEach, AfterEach)
8.4. Mocks y Spies (Jest)
8.5. Cobertura de Código
8.6. passWithNoTests: true (Uso y Transición)
Convenciones de API (para api-main)
9.1. Estilo de API (RESTful con GraphQL como opción futura)
9.2. Formato de Respuesta Estándar (IApiResponse<T>)
9.3. DTOs de Entrada y Salida
9.4. Validación de DTOs de Entrada (ZodValidationPipe)
9.5. Códigos de Estado HTTP
9.6. Versionado de API (Futuro)
9.7. Autenticación y Autorización (JWT, RBAC)
9.8. Paginación (IPaginatedQueryParams, IPaginated<T>)
9.9. CorrelationId en Cabeceras y Respuestas
Documentación
10.1. Comentarios de Código (JSDoc/TSDoc)
10.2. Documentación de Arquitectura (este documento, README.md, diagrams)
10.3. Documentación de API (Swagger/OpenAPI)
10.4. Bitácora de Desarrollo y Deuda Técnica
Mecanismos de Validación de Convenciones
11.1. ESLint y Reglas de Límites de Módulo
11.2. Prettier (Formateo Automático)
11.3. TypeScript Compiler (Chequeo de Tipos Estricto)
11.4. Hooks de Git (Husky, lint-staged)
11.5. Pipelines de CI (Lint, Tests, Build)
11.6. Revisiones de Código (Pull Requests)
1. Introducción
1.1. Propósito del Documento
Este documento establece las convenciones de codificación, arquitectura, diseño y configuración técnica para el proyecto DFS-Invest-Suite. Su objetivo es asegurar la coherencia, calidad, mantenibilidad y escalabilidad del código base, así como facilitar la colaboración y el onboarding de nuevos desarrolladores.
1.2. Audiencia
Este documento está dirigido a todos los desarrolladores, arquitectos y cualquier persona involucrada en el ciclo de vida de desarrollo del proyecto DFS-Invest-Suite, incluyendo la IA colaboradora.
1.3. Cómo Usar Este Documento
Este documento debe ser consultado como la fuente única de verdad para las prácticas de desarrollo del proyecto. Se espera que todos los contribuidores se adhieran a estas convenciones. Se actualizará a medida que el proyecto evolucione y se tomen nuevas decisiones.
1.4. Principios Generales
Claridad sobre Astucia: El código debe ser fácil de leer y entender.
Consistencia: Seguir las convenciones establecidas en todo el proyecto.
DRY (Don't Repeat Yourself): Evitar la duplicación de código mediante abstracciones y utilidades.
SOLID: Aplicar los principios SOLID enCorrecto: const validProps = { ... }; (en tests), readonly metadata: ICommandMetadata;
Validación: ESLint (reglas camelcase, UPPER_CASE_globals si aplica).
2.4. Nomenclatura de Funciones y Métodos
Convención: camelCase.
Nombres descriptivos que indiquen acción o lo que devuelven.
Para booleanos, prefijos como is, has, can (ej. isActive(), isEmpty()).
Para métodos que modifican estado (comandos en entidades), nombres imperativos (ej. activate(), updateName()).
Para métodos que obtienen datos (queries en entidades/repositorios), prefijos como get, find (ej. getName(), findById()).
Correcto: function calculateTotal(...), class A { activateTenant() {...} }
Incorrecto: function Calculate_Total(...), class A { ActivateTenant() {...} }
Validación: ESLint (regla camelcase).
2.5. Nomenclatura de Clases e Interfaces
Clases: PascalCase. Sufijos comunes: Entity, VO, Event, Command, Query, UseCase, Handler, Service, Controller, Resolver, Module, Repository, Adapter, Mapper, Exception, Pipe, Guard, Interceptor, Decorator.
Correcto: class TenantEntity {}, class CreateTenantCommand {}, class TenantPrismaRepository {}
Interfaces: PascalCase. Tradicionalmente con prefijo I (ej. ICommandMetadata, IRepositoryPort). Para DTOs o tipos estructurales simples, el prefijo I es opcional si el nombre es claro (ej. CreateTenantProps, TenantDetailsDto). Se usará prefijo I para puertos y contratos de servicio/handler, opcional para DTOs.
Correcto: interface ILoggerPort {}, interface CreateTenantCommandPayload {}
Aceptable (DTO): interface TenantDetailsDto {}
Validación: ESLint (reglas @typescript-eslint/naming-convention para clases e interfaces).
2.6. Nomenclatura de Enums
Nombre del Enum: PascalCase con sufijo Enum (si es necesario para claridad, ej. TenantStatusEnum).
Miembros del Enum: UPPER_SNAKE_CASE.
Correcto: enum TenantStatusEnum { PENDING_SETUP, ACTIVE }
Incorrecto: enum tenant_status { pendingSetup, active }
Validación: ESLint (regla @typescript-eslint/naming-convention para enums y sus miembros).
2.7. Nomenclatura de Módulos y Librerías Nx
Alias de Importación (paths en tsconfig.base.json): @<npmScope>/<path-kebab-case>
Correcto: @dfs-suite/shared-types, @dfs-suite/core-domain-tenancy
Nombres de Proyecto (en project.json y nx.json): kebab-case reflejando la ruta.
Correcto: shared-types, core-domain-tenancy, api-main
Validación: Consistencia en nx.json, project.json, tsconfig.base.json.
2.8. Comentarios y Documentación JSDoc/TSDoc
Convención: Usar JSDoc/TSDoc para todos los artefactos exportados (clases, interfaces, funciones, enums, tipos, constantes).
Explicar el @purpose o @description.
Documentar @param el diseño de clases y módulos.
Separación de Responsabilidades (SoC): Cada componente debe tener una única y bien definida responsabilidad.
Calidad Primero: El testing exhaustivo y el código limpio no son negociables.
Documentación: Documentar decisiones de diseño, APIs públicas y lógica compleja.
2. Nomenclatura y Estilos de Código
2.1. General (TypeScript/JavaScript)
Idioma: Inglés para código (variables, funciones, clases, etc.). Español para comentarios explicativos extensos, JSDoc/TSDoc donde se explique la lógica de negocio en el contexto del proyecto, y documentación (READMEs, Bitácora, este documento).
Formato: Prettier se encarga del formateo automático. Configuración en .prettierrc (singleQuote: true, etc.).
Estilo de Escritura: CamelCase para variables y funciones (miVariable, calcularTotal()). PascalCase para clases, interfaces, tipos y enums (MiClase, IMiInterfaz, MiTipo, MiEnum).
Mecanismo de Validación: Prettier, ESLint.
2.2. Nombres de Archivos
Convención: kebab-case.tipo.ts (ej. tenant.entity.ts, activate-tenant.use-case.ts, logger.port.ts).
Archivos de Test: nombre-archivo.spec.ts (para tests unitarios y de integración). nombre-app.e2e-spec.ts para tests E2E de apps.
Ejemplo Correcto: user.repository.port.ts, create-user.command.ts
Ejemplo Incorrecto: UserRepository.ts, CreateUserCOMMAND.java
Mecanismo de Validación: Revisión de código, consistencia visual.
2.3. Nombres de Clases
Convención: PascalCase. Sufijos semánticos cuando aplique: Entity, VO (para Value Objects), Event, Command, Query, UseCase (o Handler), Repository, Service, Controller, Resolver, Module, Pipe, Guard, Interceptor, Adapter, Mapper, Exception.
Ejemplo Correcto: TenantEntity, TenantStatusVO, CreateTenantCommand, CreateTenantUseCase, TenantPrismaRepository, AppModule, AllExceptionsFilter.
Ejemplo Incorrecto: tenant_entity, VOtenantStatus, createTenantCmd.
Mecanismo de Validación: ESLint (reglas de nomenclatura si se configuran), revisión de código.
2.4. Nombres de Interfaces
Convención: PascalCase. Se prefiere el prefijo I (ej. ICommand, IRepositoryPort, ILoggerPort). Para DTOs o estructuras de datos simples, el prefijo puede omitirse si el nombre ya es claro (ej. TenantDetailsDto, CreateTenantCommandPayload).
Ejemplo Correcto: ITenantRepository, ICommandMetadata, CreateTenantProps.
Ejemplo Incorrecto: TenantRepositoryInterface, command_metadata_type.
Mecanismo de Validación: ESLint (@typescript-eslint/interface-name-prefix si se configura a always-prefix o se desactiva para casos de DTOs), revisión de código.
2.5. Nombres de Tipos (Type Aliases)
Convención: PascalCase. Sufijos como Type o Props si son descriptivos. Branded Types usan PascalCase.
Ejemplo Correcto: Maybe<T>, TenantId, DomainEventProps<P>, CreateEntityProps<T>.
Ejemplo Incorrecto: maybe_type, tenant_id_str.
Mecanismo de Validación: ESLint, revisión de código.
2.6. Nombres de Enums
Convención: PascalCase para para funciones/métodos.
Documentar @returns para funciones/métodos.
Documentar @template para genéricos.
Usar @throws para excepciones que puede lanzar un método.
Usar @example cuando sea útil.
Comentarios de una línea (//) para explicaciones internas.
Comentarios de bloque (/* ... */) para explicaciones más largas o secciones.
Correcto: El nivel de detalle visto en los archivos analizados es el estándar.
Validación: ESLint (reglas como eslint-plugin-jsdoc si se configura). Revisión de código.
2.9. Estilo de Código (Prettier)
Convención: Seguir la configuración de Prettier definida en .prettierrc (actualmente: "singleQuote": true).
Esto incluye indentación, espacios, saltos de línea, uso de punto y coma (si está configurado, usualmente sí por defecto en Prettier), etc.
Validación:
Ejecución de pnpm prettier --check .
Integración con ESLint (eslint-config-prettier para desactivar reglas conflictivas de ESLint).
Hooks de Git (Husky + lint-staged) para formatear antes del commit.
3. Estructura de Directorios y Arquitectura
3.1. Estructura General del Monorepo (Nx)
apps/: Contiene aplicaciones desplegables.
apps/<app-name>/: Aplicación principal (ej. api-main).
apps/<app-name>-e2e/: Tests E2E para la aplicación correspondiente.
libs/: Contiene librerías reutilizables.
libs/shared/<type>/: Librerías de utilidades, tipos, constantes, errores, etc., agnósticas y transversales.
Ej: libs/shared/types/, libs/shared/utils/
libs/core/domain/shared-kernel/<pattern>/: Bloques de construcción DDD genéricos.
Ej: libs/core/domain/shared-kernel/entities/, libs/core/domain/shared-kernel/events/
libs/core/domain/<bounded-context>/: Lógica de dominio específica para un bounded context.
Ej: libs/core/domain/tenancy/
libs/core/application/<bounded-context>/: Lógica de aplicación (Casos de Uso) para un bounded context.
Ej: libs/core/application/tenancy/
libs/infrastructure/<type-of-infra>/<adapter-name>/: Adaptadores de infraestructura.
Ej (Proyectado): libs/infrastructure/persistence/prisma/, libs/infrastructure/whatsapp/cloud-adapter/
libs/ui-shared/: Componentes UI React compartidos (futuro).
.vscode/: Configuración específica de VSCode (extensiones recomendadas).
scripts/: Scripts utilitarios para el proyecto.
Raíz: Archivos de configuración globales (nx.json, package.json, eslint.config.mjs, tsconfig.base.json, etc.).
Validación: Revisión de estructura, depConstraints de ESLint.
3.2. Capas Arquitectónicas (Hexagonal)
Capa de Dominio (layer:domain):
libs/core/domain/shared-kernel/*
libs/core/domain/<bounded-context>/*
Contiene entidades, VOs, agregados, eventos de dominio, puertos de repositorio, servicios de dominio. Pura lógica de negocio, agnóstica a infraestructura.
Capa de Aplicación (layer:application):
libs/core/application/<bounded-context>/*
Contiene Casos de Uso (Command/Query Handlers), DTOs de aplicación, puertos para servicios de aplicación/infraestructura que necesita. Orquesta el dominio.
Capa de Adaptadores Primarios/API (scope:app en apps/*):
apps/api-main/
Controladores, Resolvers, DTOs de API, validación de entrada, transformación de salida. Interactúa con la Cap el nombre del Enum, y UPPER_SNAKE_CASE para sus miembros si los valores son strings o números que representan constantes. Si los valores del enum son strings que se usan directamente (como en TenantStatusEnum), PascalCase para los miembros es aceptable si coincide con el valor string. La práctica actual es UPPER_SNAKE_CASE para miembros con valor string.
Ejemplo Correcto:
export enum TenantStatusEnum {
  PENDING_SETUP = 'PENDING_SETUP',
  ACTIVE = 'ACTIVE',
}

TypeScript
Ejemplo Incorrecto: tenant_status_enum { pendingSetup, active }
Mecanismo de Validación: ESLint (@typescript-eslint/enum-naming-convention si se configura), revisión de código.
2.7. Nombres de Funciones y Métodos
Convención: camelCase. Verbos o frases verbales que describan la acción.
Métodos de Acceso (Getters/Setters): camelCase (ej. getName(), setName()). Para propiedades simples, usar getters/setters de TypeScript (get name(), set name()).
Métodos Booleanos: Prefijo is o has (ej. isActive(), hasSubscribers()).
Ejemplo Correcto: calculateTotal(), getUserById(), tenant.activate(), get name().
Ejemplo Incorrecto: CalculateTotal(), GET_USER_BY_ID(), TenantActivate().
Mecanismo de Validación: ESLint, revisión de código.
2.8. Nombres de Variables y Propiedades
Convención: camelCase. Nombres descriptivos.
Propiedades Privadas/Protegidas (Convención Opcional): Se puede usar un prefijo _ (ej. _id, _domainEvents) para indicar visibilidad interna, aunque TypeScript ya lo maneja con private/protected. El snapshot actual usa _ para propiedades protected.
Propiedades readonly: Usar readonly para propiedades que no deben ser modificadas después de la inicialización.
Ejemplo Correcto: let currentUser: User;, const tenantName = 'DFS';, readonly props: TenantProps;, protected _id: AggregateId;
Ejemplo Incorrecto: CurrentUser, TENANT_NAME, PropsReadonly.
Mecanismo de Validación: ESLint, revisión de código.
2.9. Nombres de Constantes
Convención: UPPER_SNAKE_CASE para constantes exportadas o de módulo (ej. DEFAULT_PAGE_LIMIT, TENANT_ALREADY_EXISTS (código de error)).
Ejemplo Correcto: export const MAX_RETRIES = 3;
Ejemplo Incorrecto: export const maxRetries = 3;
Mecanismo de Validación: ESLint (@typescript-eslint/naming-convention si se configura para constantes), revisión de código.
2.10. Comentarios y JSDoc/TSDoc
Convención:
Usar comentarios JSDoc/TSDoc para todas las funciones, clases, métodos, interfaces y tipos exportados.
Explicar el por qué y el qué, no solo el cómo (si el código ya es claro).
Comentarios de una línea con //. Comentarios de bloque con /* ... */.
Marcar TODO:, FIXME:, NOTE: para seguimiento.
Incluir @param, @returns, @throws, @template, @description, @example en JSDoc.
Añadir la sección de "Mejoras Futuras" y "Notas para Implementación Futura" según el formato establecido.
Ejemplo Correcto: Ya se sigue en los archivos analizados.
Mecanismo de Validación: Revisión de código, plugin ESLint para JSDoc (ej. eslint-plugin-jsdoc).
2.11. Importaciones
Convención:
Agrupar importaciones: 1) Módulos de Node/Externos, 2) Alias del workspace (@dfs-suite/...), 3) Importaciones relativas.
Ordenar alfabéticamente dentro de cada grupo.
Usar alias del workspace (@dfs-suite/...) configurados en tsconfig.base.json siempre que sea posible para importar de otras librerías del monorepo.
Para importaciones dentro de la misma librería, usar rutas relativas (ej. ../value-objects/).
Evitar ../../../../ excesivos; si ocurre, puede ser señal de que una librería debería depender de otra a través de su API pública (alias).
Ejemplo Correcto:
import { Injectable } from '@nestjs/common';
import { v4 as uuidv4 } from 'uuid';

import { TenantEntity } from '@dfs-suite/core-domain-tenancy';
import { Result } from '@dfs-suite/shared-result';

import { MyLocalHelper } from './my-local-helper';
.

Mecanismo de Validación: ESLint (ej. eslint-plugin-import con reglas de orden), Prettier (puede ayudar con el orden).

---

base de datos real en memoria o Testcontainers.
E2E: En apps/<app-name>-e2e/. Probar flujos completos a través de la API.
Validación: Revisión de código, cobertura.
8.2. Framework de Pruebas (Jest)
Convención: Usar Jest para todos los tests unitarios y de integración ligera. Usar Playwright (o similar) para E2E.
Configuración: jest.config.ts por proyecto, jest.preset.js en raíz.
Validación: Ejecución de tests.
8.3. Cobertura de Código
Objetivo: Mantener una alta cobertura de código (>85-90% para lógica de dominio y aplicación).
Herramientas: Reportes de Jest (--coverage). SonarQube/Codecov (futuro).
Validación: Verificar umbrales en CI (futuro).
8.4. Mocking y Stubs
Convención: Usar jest.fn(), jest.spyOn(), jest.mock() para mockear dependencias en tests unitarios.
Mockear puertos/interfaces, no implementaciones concretas (cuando se testea un consumidor del puerto).
Validación: Revisión de tests.
8.5. Tests para Casos de Uso, Entidades, VOs, etc.
Casos de Uso: Probar cada camino lógico (éxito, diferentes tipos de error devueltos por dependencias). Verificar interacciones con mocks.
Entidades: Probar métodos de negocio, transiciones de estado, validación de invariantes, emisión de eventos.
VOs: Probar lógica de validación en el constructor, métodos de comparación, y cualquier otra lógica.
Validación: Suites de tests exhaustivas.
8.6. Tests E2E (apps/*-e2e/)
Framework: Playwright (o Cypress, según blueprint). Snapshot usa Axios para E2E de API simple.
Alcance: Probar flujos de usuario críticos a través de la API desplegada (o servida localmente).
Validación: Ejecución en CI.
9. Convenciones de API (para api-main)
9.1. Estilo de API (GraphQL first, REST como fallback o para casos específicos)
Convención: Según blueprint, GraphQL es principal. REST para webhooks o casos simples.
Validación: Diseño de API.
9.2. Estructura de Respuesta Estándar (IApiResponse<T>)
Convención: Todas las respuestas JSON (REST) deben seguir la estructura IApiResponse.
GraphQL tiene su propia estructura de respuesta (datos o errores).
Validación: Implementación en interceptores/filtros.
9.3. Versionado de API (Futuro)
Convención (a definir): Usar versionado en URL (ej. /api/v1/...) o cabeceras.
Validación: N/A en esta fase.
9.4. Autenticación (JWT) y Autorización (RBAC)
Convención:
Autenticación: Tokens JWT (Bearer).
Autorización: Basada en Roles (RBAC), implementada con Guards en NestJS.
Validación: Tests de seguridad, revisión de código.
9.5. Validación de DTOs de Entrada (Zod a través de Pipes)
Convención:
Usar DTOs para los cuerpos de solicitud (REST) y argumentos de mutación/query (GraphQL).
Validar estos DTOs usando los esquemas de libs/shared/validation-schemas/ a través de un ZodValidationPipe (o similar) en NestJS.
Validación: Implementación de Pipes, tests E2E con datos inválidos.
9.6. Códigos de Estado HTTP (para REST)
Convención: Usar códigos de estado HTTP semánticamente correctos:
200 OK, 201 Created, 204 No Content.
400 Bad Request (para errores de validación, usando IApiResponse con success: false).
401 Unauthorized.
403 Forbidden.
404 Not Found.
409 Conflict.
500 Internal Server Error.
Validación: Filtro de excepciones, tests E2E.
10. Documentación
10.1. Comentarios en Código (JSDoc/TSDoc)
Convención: Documentar todas las funciones, clases, interfaces, enums, tipos y constantes exportadas. Ver ejemplos en archivos analizados.
Validación: ESLint (plugin eslint-plugin-jsdoc), revisión de código.
10.2. READMEs de Librerías y Aplicaciones
Convención: Cada proyecto Nx (app/lib) debe tener un README.md básico explicando su propósito, cómo construir/probar, y cualquier nota específica.
Validación: Revisión manual.
10.3. Documentación Arquitectónica (.DOCUMENTO-TECNICO-PROYECTO.md)
Convención: Mantener este documento actualizado con las decisiones de diseño y la estructura arquitectónica.
Validación: Revisión periódica.
10.4. Bitácora de Desarrollo (.BITACORA.md)
Convención: Registrar decisiones importantes, problemas, soluciones y progreso.
Validación: Actualización regular.
10.5. Registro de Deuda Técnica (.DEUDA-TECNICA.md)
Convención: Documentar explícitamente la deuda técnica, justificaciones para soluciones temporales y planes de refactorización.
Validación: Revisión y seguimiento.
10.6. Roadmap (.ROADMAP.md)
Convención: Planificar y rastrear fases, hitos y tareas.
Validación: Actualización regular.
10.7. Documentación de API (Swagger/OpenAPI para REST, GraphQL Schema para GraphQL)
Convención:
REST: Usar @nestjs/swagger para generar documentación OpenAPI a partir de decoradores.
GraphQL: El schema GraphQL es auto-documentable. Usar descripciones en el schema.
Validación: Generación y revisión de la documentación.

**11. Mecanismos de Validación de Convenciones**
**11.1. ESLint**
Herramienta Principal: Para forzar estilos de código, nomenclatura (parcialmente), y crucialmente, los límites de módulo arquitectónicos.
Configuración: eslint.config.mjs (raíz y por proyecto).

**11.2. Prettier**
Herramienta Principal: Para formateo automático de código.
Configuración: .prettierrc.

**11.3. TypeScript Compiler (tsc)**
Herramienta Principal: Para chequeo de tipos estático, incluyendo strict mode.
Configuración: tsconfig.*.json.

**11.4. Hooks de Git (Husky, lint-staged)**
Propósito: Ejecutar linters y formateadores automáticamente antes de cada commit o push.
Implementación (Mejora Futura):
pnpm add -D husky lint-staged
Configurar husky para instalar hooks.
Configurar lint-staged en package.json para ejecutar eslint --fix y prettier --write en los archivos "staged".
Validación: Automática en el flujo de commit.

**11.5. CI Pipeline Checks**
Propósito: Ejecutar todas las validaciones (lint, test, build, cobertura) en el pipeline de Integración Continua (GitHub Actions).
Implementación: Workflows de GitHub Actions.
Validación: Bloquear merges si los checks fallan.

---
Dado que el prompt anterior era una solicitud para generar dicho documento y el prompt actual es una descripción de la tarea para generar ese mismo documento (con un excelente nivel de detalle sobre lo que debe contener), confirmo que estoy en proceso de crear exactamente lo que solicitas.
Mi proceso será el siguiente:
Revisión y Consolidación: Tomaré la estructura y las secciones que ya comencé a delinear en mi respuesta anterior (que ya incluía "Nomenclatura y Estilos de Código", "Estructura de Directorios y Arquitectura", "Implementación Específica de Patrones DDD", "Uso Avanzado de TypeScript", "Configuraciones Técnicas", "Manejo de Errores", "Patrones de Pruebas", "Convenciones de API" y "Documentación") y me aseguraré de que cada subpunto que has detallado ahora esté cubierto.
Extracción de Ejemplos: Continuaré extrayendo ejemplos concretos del snapshot del código DFS-Invest-Suite siempre que sea posible para ilustrar el "Uso Correcto". Cuando no haya un ejemplo directo, crearé uno representativo. Para el "Uso Incorrecto", crearé ejemplos que contrasten con la convención.
Alineación con Mejoras: Integraré activamente las "mejoras propuestas" como parte de las convenciones o como justificación para ciertas elecciones, mostrando cómo las convenciones apoyan la evolución deseada del proyecto.
Identificación de Convenciones Implícitas: Durante el análisis de cada archivo del snapshot, ya he estado notando patrones y estilos. Formalizaré estas observaciones.
Ampliación y Rationale: Donde sea necesario, ampliaré las convenciones para cubrir casos borde y siempre que sea posible, incluiré una breve justificación (Rationale) para las decisiones clave.
Mecanismos de Validación: Para cada categoría, sugeriré cómo se puede validar la convención, ya sea a través de ESLint, Prettier, TypeScript, revisiones de código o herramientas adicionales.
Para reiterar y confirmar, el documento que estoy construyendo incluirá (adaptado a DFS-Invest-Suite):
Introducción y Propósito: Contexto, objetivos, cómo usarlo.
Secciones Temáticas Detalladas (Nomenclatura, Arquitectura, DDD, TypeScript, Configs, Errores, Pruebas, API, Documentación):
Descripción clara de cada convención.
Justificación/Beneficio.
Ejemplos de Uso Correcto (del proyecto o representativos).
Ejemplos de Uso Incorrecto.
Referencias a configuraciones (ESLint, Prettier, tsconfig, etc.).
Referencias Rápidas (Resumen): Al final, un resumen de las convenciones más críticas.
Proceso de Actualización (Sugerencia): Cómo mantener el documento vivo.
Mecanismos de Validación de Convenciones: Sugerencias para automatización.
Continuaré generando el documento sección por sección, como lo estábamos haciendo. La siguiente sección que estaba pendiente en mi respuesta anterior era la continuación de la Sección 3: Estructura de Directorios y Arquitectura.
---


¡Perfecto! Continuamos con la Sección 3: Estructura de Directorios y Arquitectura del Documento Maestro de Convenciones y Estándares para DFS-Invest-Suite.
(Continuación del Documento Maestro de Convenciones y Estándares)
3. Estructura de Directorios y Arquitectura (Nx Monorepo Hexagonal) (Continuación)
3.3. Capas Arquitectónicas (Hexagonal)
La arquitectura del proyecto DFS-Invest-Suite se basa en los principios de la Arquitectura Hexagonal (o de Puertos y Adaptadores), organizada en capas claras dentro del monorepo Nx. El flujo de dependencias siempre debe apuntar hacia adentro (hacia el Dominio).
3.3.1. Capa Compartida Global (libs/shared/)
Propósito: Contener código que es verdaderamente transversal, agnóstico a cualquier dominio de negocio específico y a cualquier framework de aplicación o infraestructura. Puede ser utilizado por cualquier otra capa o librería en el monorepo.
Contenido Típico:
Tipos TypeScript globales y de utilidad (Brand<K,T>, Maybe<T>, ObjectLiteral<V>, IApiResponse<T>, IPaginated<T>, PrimitiveIds como TenantId, UserId).
Utilidades puras, sin estado (ej. Guard, UuidUtils).
Constantes globales (DEFAULT_PAGE_LIMIT, REGEX_PATTERNS).
Clases base para errores (ExceptionBase) y códigos de error genéricos.
Implementación del patrón Result<T,E>.
Esquemas de validación base reutilizables (con Zod, ej. EmailSchema, UuidSchema).
Convenciones de Directorio:
libs/shared/<tipo-de-artefacto>/src/index.ts
libs/shared/<tipo-de-artefacto>/src/lib/archivo-especifico.ts
Ejemplo (Existente):
libs/shared/types/
libs/shared/utils/
libs/shared/constants/
libs/shared/errors/
libs/shared/result/
libs/shared/validation-schemas/
Dependencias Permitidas: Solo de otras librerías dentro de libs/shared/ (con precaución para evitar ciclos) o de paquetes NPM externos. No puede depender de core, infrastructure, o apps.
Tags Nx Típicos: scope:shared, type:<util|types|constants|etc>, layer:shared.
Validación: Reglas depConstraints en eslint.config.mjs.
3.3.2. Núcleo del Dominio - Shared Kernel (libs/core/domain/shared-kernel/)
Propósito: Contener los bloques de construcción genéricos y patrones de Domain-Driven Design (DDD) que son reutilizables a través de múltiples bounded contexts (dominios específicos). Es parte de la capa de Dominio más interna.
Contenido Típico:
Clases base abstractas: Entity, AggregateRoot, ValueObject.
Interfaces y clases base para Eventos de Dominio: IDomainEvent, DomainEventBase, IDomainEventEmitter, IDomainEventHandler.
Interfaces y clases base para Comandos y Queries: ICommand, CommandBase, IQuery, QueryBase, ICommandHandler, IQueryHandler, PaginatedQueryBase.
Interfaces base para Puertos de Dominio: IRepositoryPort, ILoggerPort.
Interfaz base para Mappers: IMapper.
Convenciones de Directorio:
libs/core/domain/shared-kernel/<nombre-patron>/src/index.ts
libs/core/domain/shared-kernel/<nombre-patron>/src/lib/archivo-especifico.ts
Ejemplo (Existente):
libs/core/domain/shared-kernel/entities/
libs/core/domain/shared-kernel/value-objects/
libs/core/domain/shared-kernel/events/
libs/core/domain/shared-kernel/ports/
libs/core/domain/shared-kernel/commands-queries/
libs/core/domain/shared-kernel/mappers/
Dependencias Permitidas: Solo de libs/shared/*. No puede depender de dominios específicos, ni de la capa de aplicación, ni de infraestructura, ni de apps.
Tags Nx Típicos: scope:core-domain, type:shared-kernel, layer:domain.
Validación: Reglas depConstraints.
3.3.3. Núcleo del Dominio - Dominio Específico (libs/core/domain/<bounded-context>/)
Propósito: Contener la lógica de negocio, las reglas y el conocimiento específico de un Bounded Context particular (ej. Tenancy, WhatsApp, Leads). Es el corazón del sistema. Totalmente agnóstico a cualquier otra capa o tecnología externa.
Contenido Típico:
Entidades y Aggregate Roots específicos del dominio (ej. TenantEntity).
Value Objects específicos del dominio (ej. TenantStatusVO).
Eventos de Dominio específicos (ej. TenantCreatedEvent).
Servicios de Dominio (si la lógica no encaja en una entidad/VO).
Puertos de Repositorio específicos (interfaces, ej. ITenantRepository que extiende IRepositoryPort).
Errores de Dominio específicos (ej. TenantAlreadyExistsError).
Convenciones de Directorio:
libs/core/domain/<bounded-context>/src/index.ts
libs/core/domain/<bounded-context>/src/lib/entities/
libs/core/domain/<bounded-context>/src/lib/value-objects/
libs/core/domain/<bounded-context>/src/lib/events/
libs/core/domain/<bounded-context>/src/lib/ports/
libs/core/domain/<bounded-context>/src/lib/errors/
libs/core/domain/<bounded-context>/src/lib/services/ (para Servicios de Dominio)
Ejemplo (Existente):
libs/core/domain/tenancy/
Dependencias Permitidas: De libs/shared/* y de libs/core/domain/shared-kernel/*. Un dominio específico puede depender de tipos de otro dominio específico (ej. un LeadEntity podría tener un TenantId), pero la interacción directa o la dependencia de la lógica de otro dominio debe evitarse o manejarse con extrema precaución (preferiblemente a través de eventos de dominio o coordinación en la capa de aplicación).
Tags Nx Típicos: scope:core-domain, type:domain-logic, layer:domain, domain:<nombre-contexto> (ej. domain:tenancy).
Validación: Reglas depConstraints.
3.3.4. Capa de Aplicación (libs/core/application/<bounded-context>/)
Propósito: Orquestar los flujos de trabajo y casos de uso del sistema para un Bounded Context específico. No contiene lógica de negocio del dominio, sino que utiliza el dominio para realizar las tareas. Es agnóstica al framework de entrega (ej. no depende de NestJS).
Contenido Típico:
Comandos (*.command.ts) y sus Payloads.
Queries (*.query.ts) y sus Payloads/Parámetros.
Casos de Uso / Handlers (*.use-case.ts o *.handler.ts) que implementan ICommandHandler o IQueryHandler.
DTOs de Aplicación (para transferencia de datos entre aplicación y dominio, o como tipos de retorno de queries, ej. TenantDetailsDto).
Puertos para Servicios de Aplicación o de Infraestructura que necesita (ej. IDatabaseProvisioningServicePort).
Event Handlers de aplicación (que reaccionan a eventos de dominio para orquestar otros comandos).
Mappers (si el mapeo entre DTOs de aplicación y entidades de dominio es responsabilidad de esta capa).
Convenciones de Directorio:
libs/core/application/<bounded-context>/src/index.ts
libs/core/application/<bounded-context>/src/lib/commands/<nombre-comando>/
libs/core/application/<bounded-context>/src/lib/queries/<nombre-query>/
libs/core/application/<bounded-context>/src/lib/use-cases/<nombre-caso-uso>/ (o handlers)
libs/core/application/<bounded-context>/src/lib/dtos/
libs/core/application/<bounded-context>/src/lib/ports/
libs/core/application/<bounded-context>/src/lib/event-handlers/
libs/core/application/<bounded-context>/src/lib/mappers/
Ejemplo (Existente/En Progreso):
libs/core/application/tenancy/
Dependencias Permitidas: De libs/shared/*, de libs/core/domain/shared-kernel/*, y de la librería de dominio específica correspondiente (libs/core/domain/<mismo-bounded-context>/*). Puede depender de puertos de otras librerías de aplicación o infraestructura, pero no de sus implementaciones. Puede depender de tipos de otros dominios si es necesario para DTOs.
Tags Nx Típicos: scope:core-application, type:application-logic, layer:application, feature:<nombre-contexto> (ej. feature:tenancy).
Validación: Reglas depConstraints.
3.3.5. Capa de Infraestructura (libs/infrastructure/<adapter-type>/<adapter-name-or-technology>/)
Propósito: Contener las implementaciones concretas (Adaptadores) de los puertos definidos por las capas de Dominio y Aplicación. Interactúa directamente con tecnologías externas (bases de datos, APIs de terceros, sistemas de mensajería, logging, etc.).
Contenido Típico:
Adaptadores de Repositorio (ej. TenantPrismaRepository implementando ITenantRepository).
Mappers entre modelos de dominio y modelos de persistencia (ej. TenantPrismaMapper).
Adaptadores para APIs externas (ej. WhatsAppCloudApiAdapter implementando IWhatsAppMessagePort).
Implementaciones de servicios de aprovisionamiento, logging, emisores de eventos, etc.
Módulos NestJS (si la infraestructura se integra con NestJS para DI) que proveen estos adaptadores.
Configuración específica de la tecnología (ej. cliente Prisma, cliente HTTP).
Convenciones de Directorio (Proyectada):
libs/infrastructure/persistence/prisma/<contexto-o-global>/ (ej. tenancy-adapter)
libs/infrastructure/messaging/bullmq/
libs/infrastructure/http-clients/whatsapp-cloud-api/
libs/infrastructure/observability/pino-logger/
Dependencias Permitidas: De libs/shared/*, de libs/core/domain/shared-kernel/*, y de los puertos específicos de libs/core/domain/<bounded-context>/ports/ y libs/core/application/<bounded-context>/ports/ que implementa. También de librerías NPM externas (ej. @prisma/client, axios, bullmq, pino). No puede depender de apps/*.
Tags Nx Típicos: scope:infrastructure, type:adapter, layer:infrastructure, technology:<nombre-tecnologia> (ej. technology:prisma).
Validación: Reglas depConstraints.
3.3.6. Capa de Aplicaciones / Adaptadores Primarios (apps/<app-name>/)
Propósito: Puntos de entrada y salida del sistema. Reciben solicitudes de usuarios o sistemas externos, invocan la lógica de aplicación (Casos de Uso), y presentan los resultados. Son los "drivers" de la aplicación.
Contenido Típico (para api-main - NestJS):
Módulos NestJS (*.module.ts) para organizar la aplicación.
Controladores (*.controller.ts) para APIs REST.
Resolvers (*.resolver.ts) para APIs GraphQL.
DTOs de API (para request y response, ej. CreateTenantApiDto.ts).
Pipes de Validación (ej. ZodValidationPipe usando schemas de shared-validation-schemas).
Guards de Autenticación/Autorización.
Interceptors para transformación de respuesta (ej. a IApiResponse) o logging.
Filtros de Excepción globales.
Archivo main.ts para el bootstrap de la aplicación.
Configuración de la aplicación (ej. ConfigModule).
Dependencias Permitidas: De libs/shared/* (para DTOs, tipos), de libs/core/application/* (para invocar Casos de Uso, importar Comandos/Queries), y de libs/infrastructure/* (para la inyección de dependencias de las implementaciones de puertos en los módulos NestJS). No debe depender directamente de libs/core/domain/* si la capa de aplicación ya expone toda la funcionalidad necesaria.
Tags Nx Típicos: scope:app, type:api (o type:pwa), layer:presentation (o layer:app-entry).
Validación: Reglas depConstraints.
3.4. Tags de Nx y Límites de Módulo (depConstraints)
Convención: Todas las librerías y aplicaciones en project.json DEBEN tener tags asignados que reflejen su scope, type, y layer (y opcionalmente feature/domain o concern/pattern).
scope:*: Agrupación lógica amplia (ej. shared, core-domain, core-application, infrastructure, app, ui).
type:*: Naturaleza del código (ej. utils, types, domain-logic, application-logic, adapter, api, pwa, shared-kernel).
layer:*: Capa arquitectónica hexagonal (ej. shared, domain, application, infrastructure, presentation).
domain:* o feature:*: El bounded context o feature al que sirve (ej. domain:tenancy, feature:tenancy).
Configuración: Las reglas depConstraints se definen en el eslint.config.mjs raíz.
Regla Fundamental: Las dependencias solo pueden apuntar "hacia adentro":
shared no depende de nada más (excepto otras shared).
domain (incluyendo shared-kernel) solo depende de shared y de sí mismo.
application depende de domain y shared.
infrastructure implementa puertos de domain y application, y puede usar shared.
apps dependen de application, infrastructure (para DI) y shared.
Ejemplo de Regla (Simplificada):
// En eslint.config.mjs raíz
// { sourceTag: 'layer:application', onlyDependOnLibsWithTags: ['layer:application', 'layer:domain', 'layer:shared'] },
// { sourceTag: 'layer:domain', onlyDependOnLibsWithTags: ['layer:domain', 'layer:shared'] },
// { sourceTag: 'layer:infrastructure', onlyDependOnLibsWithTags: ['layer:application', 'layer:domain', 'layer:shared', 'layer:infrastructure'] },
// { sourceTag: 'layer:shared', onlyDependOnLibsWithTags: ['layer:shared'] }

JavaScript
(La configuración real en el snapshot es más granular y correcta, usando type:* y scope:* junto con layer:*).
Validación: pnpm nx run-many --target=lint --all. Las violaciones deben ser tratadas como errores bloqueantes.
---

4. Implementación Específica de Patrones DDD (Domain-Driven Design)
Esta sección detalla las convenciones para implementar los bloques de construcción tácticos de DDD dentro del proyecto, principalmente en las librerías de libs/core/domain/shared-kernel/ y libs/core/domain/<bounded-context>/.
4.1. Entidades (*.entity.ts)
Definición: Objetos que tienen una identidad distintiva que perdura a lo largo del tiempo y a través de diferentes estados. Su identidad no se define por sus atributos, sino por un ID único.
Convenciones:
Herencia: Todas las entidades deben heredar de Entity<Props> (de libs/core/domain/shared-kernel/entities/).
Nomenclatura: NombreEntidadEntity (ej. TenantEntity). Archivo: nombre-entidad.entity.ts.
Identidad (id): Cada entidad tendrá una propiedad id de tipo AggregateId (o un Branded Type específico como TenantId que es compatible). El ID se asigna en la creación y es inmutable.
Propiedades (props): El estado interno de la entidad se mantiene en un objeto props protegido. Las propiedades específicas se definen en una interfaz NombreEntidadProps.
Constructor: El constructor debe ser protected o private. La instanciación pública se realiza a través de un método factoría estático create().
Método Factoría create():
Responsable de la validación inicial de los datos de entrada necesarios para crear una instancia válida.
Debe generar o aceptar un id para la nueva entidad.
Debe instanciar la entidad y devolverla.
Si la entidad es un AggregateRoot, el método create() también es responsable de añadir el evento de dominio de creación inicial (ej. TenantCreatedEvent).
Acceso a Propiedades: Se accede a las propiedades a través de getters públicos. La modificación del estado se realiza exclusivamente a través de métodos de negocio públicos.
Métodos de Negocio: Expresan el comportamiento del dominio y encapsulan la lógica que modifica el estado de la entidad. Deben asegurar que los invariantes de la entidad se mantengan. Si la entidad es un AggregateRoot, estos métodos deben registrar eventos de dominio relevantes.
Validación de Invariantes (validate()): Cada entidad debe implementar el método abstract validate() heredado de EntityBase. Este método se llama en el constructor y debe ser llamado por la entidad después de cualquier cambio de estado para asegurar que todos sus invariantes se cumplen. Debe lanzar una excepción (ej. DomainInvariantViolationError o una específica) si un invariante se rompe.
Inmutabilidad (Conceptual): Aunque las props internas puedan ser mutables dentro de la clase, la entidad debe comportarse como inmutable desde la perspectiva de sus consumidores. Los cambios de estado solo ocurren a través de métodos de negocio explícitos.
Timestamps (createdAt, updatedAt): Manejados por la clase base Entity. updatedAt debe actualizarse (usando this.setUpdatedAt()) en cualquier método que modifique el estado.
Ejemplo Correcto (Simplificado, basado en TenantEntity):
// en tenant.entity.ts
interface TenantProps { /* ... */ }
export class TenantEntity extends AggregateRoot<TenantProps> { // O Entity<TenantProps> si no es AR
  private constructor(createEntityProps: CreateEntityProps<TenantProps>) {
    super(createEntityProps);
  }

  public static create(props: /* CreateTenantSpecificProps */ any, id: AggregateId): TenantEntity {
    // ... validaciones de entrada
    const tenant = new TenantEntity({ id, props: { /* ... */ } });
    // tenant.addEvent(new TenantCreatedEvent(...)); // Si es AggregateRoot
    return tenant;
  }

  public changeName(newName: string): Result<void, Error> {
    // ... validaciones
    this.props.name = newName;
    this.setUpdatedAt();
    this.validate();
    // this.addEvent(new TenantNameChangedEvent(...));
    return ok(undefined);
  }

  public validate(): void {
    if (Guard.isEmpty(this.props.name)) {
      throw new ArgumentNotProvidedException('Tenant name is required.');
    }
    // ... más invariantes
  }
}

TypeScript
Ejemplo Incorrecto:
Clases con propiedades públicas mutables accesibles directamente desde fuera.
Lógica de negocio dispersa fuera de la entidad.
No usar un método factoría create() para la instanciación y validación inicial.
No mantener actualizados los timestamps o no validar invariantes tras cambios de estado.
Validación: Revisión de código, tests unitarios que verifiquen invariantes y comportamiento.
4.2. Value Objects (*.vo.ts)
Definición: Objetos que describen un aspecto del dominio y no tienen identidad conceptual. Se definen por sus atributos. Son inmutables y su igualdad se basa en la comparación de sus atributos.
Convenciones:
Herencia: Deben heredar de ValueObject<Props> (de libs/core/domain/shared-kernel/value-objects/).
Nomenclatura: NombreConceptoVO (ej. TenantStatusVO, DbConnectionConfigVO). Archivo: nombre-concepto.vo.ts.
Propiedades (props): El estado interno se mantiene en this.props (definido por una interfaz NombreConceptoProps). Todas las propiedades deben ser readonly si es posible, o el objeto props completo es congelado por ValueObjectBase.
Inmutabilidad: Estricta. No deben existir métodos que modifiquen el estado interno después de la creación.
Constructor: Usualmente public. Realiza la validación de los atributos de entrada.
Método Factoría create() (Opcional pero Recomendado): Un método estático create() puede proporcionar una API más semántica y centralizar la lógica de creación y validación.
Validación (validate()): Cada VO debe implementar el método abstract validate(props) heredado de ValueObjectBase para validar sus atributos. Debe lanzar una excepción si la validación falla.
Igualdad (equals()): Heredado de ValueObjectBase, que realiza una comparación estructural (JSON.stringify). Si se necesitan comparaciones más complejas o específicas, este método puede ser sobrescrito.
Método unpack() (Opcional): Heredado. Para VOs que encapsulan un único primitivo, unpack() devuelve ese primitivo. Para VOs con múltiples props, devuelve el objeto de props.
Métodos de Comportamiento (Puros): Pueden tener métodos que deriven información o realicen cálculos basados en sus atributos, pero estos métodos no deben modificar el estado del VO (deben ser puros).
Ejemplo Correcto (Basado en TenantStatusVO):
// en tenant-status.vo.ts
export enum TenantStatusEnum { /* ... */ }
export class TenantStatusVO extends ValueObject<TenantStatusEnum> {
  constructor(value: TenantStatusEnum) {
    super({ value }); // ValueObjectBase espera props: { value: T } para primitivos
  }
  get value(): TenantStatusEnum { return this.props.value; }
  protected validate(props: { value: TenantStatusEnum }): void {
    if (!Object.values(TenantStatusEnum).includes(props.value)) {
      throw new ArgumentInvalidException('Invalid tenant status');
    }
  }
  public static newActive(): TenantStatusVO { /* ... */ }
  public isActive(): boolean { /* ... */ }
}

TypeScript
Ejemplo Incorrecto:
VOs con setters o métodos que mutan su estado interno.
VOs sin validación en el constructor o método validate.
VOs cuya igualdad se basa en la identidad de referencia en lugar del valor.
Validación: Revisión de código, tests unitarios exhaustivos para validación y comportamiento.
4.3. Aggregate Roots (*.entity.ts que extienden AggregateRoot)
Definición: Una entidad específica dentro de un Agregado que actúa como el único punto de entrada para cualquier modificación de estado dentro de ese Agregado. Es responsable de mantener los invariantes del Agregado.
Convenciones:
Herencia: Deben heredar de AggregateRoot<Props> (de libs/core/domain/shared-kernel/entities/).
Responsabilidades Adicionales (sobre Entity):
Manejo de Eventos de Dominio: Utilizar this.addEvent(new MyDomainEvent(...)) para registrar eventos después de cambios de estado significativos.
Punto de Entrada Único: Toda la lógica que modifica cualquier parte del agregado (incluyendo entidades o VOs anidados) debe pasar a través de métodos públicos del Aggregate Root.
Consistencia Transaccional: El Aggregate Root define los límites de consistencia transaccional. Los cambios en un agregado deben ser atómicos.
Ejemplo Correcto: TenantEntity ya está definido como AggregateRoot.
Validación: Revisión de diseño, tests.
4.4. Eventos de Dominio (*.event.ts)
Definición: Objetos que representan algo significativo que ha ocurrido en el pasado dentro del dominio. Son inmutables.
Convenciones:
Herencia: Deben heredar de DomainEventBase<Payload> (de libs/core/domain/shared-kernel/events/).
Nomenclatura: NombreHechoPasadoEvent (ej. TenantCreatedEvent, OrderShippedEvent). Archivo: nombre-hecho-pasado.event.ts.
Payload: Definir una interfaz INombreHechoPasadoEventPayload para el payload específico del evento. El payload debe contener la información mínima necesaria para que los consumidores del evento puedan reaccionar, sin incluir el agregado completo si no es necesario ("Event-Carried State Transfer").
Inmutabilidad: El payload y la metadata deben ser readonly. DomainEventBase se encarga de congelarlos.
Propiedades:
id: ID único de la instancia del evento.
aggregateId: ID del agregado que originó el evento.
eventName: Nombre de la clase del evento (automático por DomainEventBase).
metadata: IDomainEventMetadata (timestamp, correlationId, etc.).
payload: Datos específicos del evento.
Creación: Instanciados por el Aggregate Root.
Ejemplo Correcto (Basado en TenantCreatedEvent):
// en tenant-created.event.ts
export interface ITenantCreatedEventPayload { /* ... */ }
export class TenantCreatedEvent extends DomainEventBase<ITenantCreatedEventPayload> {
  constructor(props: DomainEventProps<ITenantCreatedEventPayload>) {
    super(props);
  }
}

TypeScript
Validación: Revisión de diseño, tests de las entidades que los emiten.
4.5. Repositorios (Puertos: *.repository.port.ts)
Definición: Abstracciones (interfaces/puertos) que median entre el dominio y la capa de persistencia, proporcionando una ilusión de colección en memoria de Aggregate Roots.
Convenciones:
Nomenclatura: INombreAgregadoRepository (ej. ITenantRepository). Archivo: nombre-agregado.repository.port.ts.
Ubicación: En la librería de dominio específico (libs/core/domain/<bounded-context>/src/lib/ports/).
Herencia: Deben extender IRepositoryPort<AggregateType> (de libs/core/domain/shared-kernel/ports/).
Métodos: Deben definir métodos para recuperar y persistir Aggregate Roots (ej. findById, findByName, insert, update, delete). Los métodos deben operar solo con Aggregate Roots completos.
Tipos de Retorno: Usar Promise<Result<T, E>> para todas las operaciones asíncronas que pueden fallar.
Símbolo de Inyección: Definir un Symbol para DI (ej. export const TENANT_REPOSITORY_PORT = Symbol('TENANT_REPOSITORY_PORT');).
Ejemplo Correcto (Basado en ITenantRepository):
// en tenant.repository.port.ts
export const TENANT_REPOSITORY_PORT = Symbol(/*...*/);
export interface ITenantRepository extends IRepositoryPort<TenantEntity> {
  findByName(name: string): Promise<Result<Maybe<TenantEntity>, Error>>;
  // ... otros métodos específicos
}

TypeScript
Implementaciones (*.prisma-repository.ts o similar): Residen en la capa de infraestructura (libs/infrastructure/persistence/).
Validación: Revisión de diseño. Los tests se hacen sobre las implementaciones.
4.6. Servicios de Dominio (*.service.ts dentro de libs/core/domain/<bounded-context>/src/lib/services/)
Definición: Para lógica de dominio significativa que no encaja naturalmente en una Entidad o Value Object. Suelen ser sin estado y orquestar múltiples entidades o VOs.
Convenciones:
Nomenclatura: NombreLogicaDominioService.
Sin Estado: Deben ser sin estado.
Operaciones: Exponer operaciones de dominio a través de métodos.
Inyección: Pueden ser inyectados en Casos de Uso o en Entidades (con precaución, para evitar acoplamiento excesivo).
Ejemplo (Hipotético):
// en tenant-uniqueness-checker.domain-service.ts
// class TenantUniquenessCheckerService {
//   constructor(private readonly tenantRepo: ITenantRepository) {}
//   async isNameUnique(name: string): Promise<boolean> { /* ... */ }
// }

TypeScript
(Actualmente, esta lógica está en CreateTenantUseCase).
Validación: Revisión de diseño, tests unitarios.
4.7. Módulos de Dominio (Librerías libs/core/domain/<bounded-context>/)
Convención: Cada Bounded Context principal tendrá su propia librería Nx para encapsular su modelo de dominio (Entidades, VOs, Eventos, Puertos de Repositorio, Errores de Dominio, Servicios de Dominio).
Validación: Estructura de directorios, tags de Nx, depConstraints.

Esta sección cubre los patrones DDD clave. La adherencia a estas convenciones es vital para la integridad del modelo de dominio.
---

5. Uso Avanzado de TypeScript
El proyecto DFS-Invest-Suite aprovecha las capacidades de TypeScript para construir un sistema robusto, mantenible y con un alto grado de seguridad de tipos. Esta sección detalla las convenciones y patrones de TypeScript a seguir.
5.1. Strict Mode ("strict": true y Opciones Relacionadas)
Convención: La opción "strict": true DEBE estar habilitada en el tsconfig.base.json y heredada por todos los proyectos. Esto activa un conjunto de comprobaciones de tipo más rigurosas, incluyendo:
noImplicitAny: No permitir any implícitos.
strictNullChecks: Tratar null y undefined como tipos distintos y requerir comprobaciones explícitas.
strictFunctionTypes: Comprobación más estricta de la covarianza/contravarianza de los parámetros de función.
strictBindCallApply: Comprobación más estricta de los métodos bind, call, y apply.
strictPropertyInitialization: Asegurar que las propiedades de clase se inicialicen en el constructor o se declaren con !.
noImplicitThis: No permitir this con un tipo any implícito.
alwaysStrict: Emitir "use strict"; en el JavaScript generado.
Opciones Adicionales Recomendadas (habilitadas en tsconfig.json de librerías):
"noImplicitOverride": true: Requiere el uso de la palabra clave override cuando un miembro de una clase derivada sobrescribe un miembro de su clase base.
"noImplicitReturns": true: Asegura que todas las rutas de código en funciones que declaran un tipo de retorno efectivamente devuelvan un valor.
"noFallthroughCasesInSwitch": true: Previene casos de "fallthrough" accidentales en sentencias switch.
"noPropertyAccessFromIndexSignature": true: Promueve el uso de acceso por corchetes para propiedades definidas por una firma de índice.
Rationale: Maximiza la seguridad de tipos, ayuda a detectar errores en tiempo de compilación, mejora la legibilidad y mantenibilidad del código.
Validación: Configuración de tsconfig.json y tsconfig.base.json. El compilador tsc forzará estas reglas.
5.2. Branded Types (Brand<K,T>)
Convención: Utilizar el tipo Brand<K, T extends string> (definido en libs/shared/types/src/lib/brand.type.ts) para crear tipos nominales para primitivos (principalmente string y number) que representan conceptos de dominio distintos pero estructuralmente idénticos.
Especialmente para IDs (TenantId, UserId, AggregateId, CorrelationId, CommandInstanceId futuro).
También para otros primitivos con semántica específica (IsoDateString).
Creación: Se requiere una aserción de tipo (as MiTipoBrandeado) en el punto donde un primitivo se convierte por primera vez al tipo brandeado. La generación de IDs brandeados debe centralizarse en UuidUtils.
Rationale: Previene la asignación accidental entre tipos semánticamente diferentes (ej. TenantId vs UserId), mejorando drásticamente la seguridad de tipos sin costo en runtime.
Ejemplo Correcto (ya visto):
import { Brand } from '@dfs-suite/shared-types';
export type OrderId = Brand<string, 'OrderId'>;
export type ProductId = Brand<string, 'ProductId'>;

TypeScript
Ejemplo Incorrecto: Usar string directamente para todos los IDs.
Validación: Revisión de código, uso consistente en firmas de tipo.
5.3. Tipos Utilitarios (Maybe<T>, ObjectLiteral<V>)
Maybe<T> = T | null | undefined; (de libs/shared/types/)
Convención: Usar Maybe<T> consistentemente para indicar que un valor, propiedad o parámetro es opcional o puede estar ausente.
Rationale: Claridad explícita sobre la opcionalidad, forzando a los consumidores a manejar los casos de null o undefined (idealmente con Guard.isNil o encadenamiento opcional ?.).
ObjectLiteral<V = unknown> (de libs/shared/types/)
Convención: Usar con precaución para estructuras de datos verdaderamente genéricas o flexibles (ej. metadata en errores o eventos). Preferir interfaces o tipos específicos siempre que la estructura sea conocida.
Rationale: Proporciona flexibilidad, pero con una reducción inherente de la seguridad de tipos. El default V = unknown es preferible a V = any.
Validación: Revisión de código para uso apropiado.
5.4. Genéricos (<T>)
Convención: Utilizar genéricos extensivamente para crear componentes reutilizables y fuertemente tipados.
En interfaces y clases base (Entity<Props>, ValueObject<Props>, Result<T,E>, ICommandHandler<C,R>, IRepositoryPort<Agg>).
En funciones utilitarias.
Nomenclatura de Parámetros de Tipo: Usar letras mayúsculas descriptivas (ej. T para Tipo, E para Error, R para Resultado, C para Comando, Q para Query, P o Props para Propiedades).
Restricciones (extends): Usar restricciones en los parámetros de tipo (C extends ICommand) para asegurar que los tipos genéricos cumplan con ciertos contratos.
Rationale: Máxima reutilización de código con seguridad de tipos.
Ejemplo Correcto: Ya presente en Result<T,E>, IMapper<D,P,R>.
Validación: Revisión de código, efectividad del tipado.
5.5. Enums vs. Union Types de Strings Literales
Enums TypeScript (enum MiEnum { VALOR_A = 'VALOR_A_STR' }):
Convención: Usar para conjuntos cerrados de valores con un significado semántico fuerte y cuando se necesita tanto el nombre de la clave como el valor (ej. TenantStatusEnum).
Miembros en UPPER_SNAKE_CASE si los valores son strings que representan constantes. Si el valor string es el que se usa (ej. 'PENDING_SETUP'), el nombre del miembro puede ser PascalCase si coincide. La práctica actual es UPPER_SNAKE_CASE para el miembro y el valor string.
Proporcionan exhaustividad en switch statements.
Union Types de Strings Literales (type MiUnion = 'opcionA' | 'opcionB';):
Convención: Usar para conjuntos más pequeños y simples de opciones donde solo el valor string es importante y no se necesita la "enumeración" como objeto (ej. sortOrder: 'asc' | 'desc').
Más ligeros que los enums (no generan código JavaScript adicional para el objeto enum).
Rationale: Elegir la herramienta adecuada para el nivel de semántica y complejidad requerido. Los enums son buenos para estados o categorías bien definidas; las uniones literales para opciones simples.
Ejemplo Correcto (Enum): TenantStatusEnum.
Ejemplo Correcto (Union): type SortDirection = 'asc' | 'desc';
Validación: Revisión de código.
5.6. unknown vs. any
Convención: Preferir unknown sobre any siempre que sea posible.
Usar any solo como último recurso y con justificación clara (ej. interactuando con código JavaScript legado o librerías mal tipadas).
unknown es type-safe: fuerza a realizar comprobaciones de tipo (con typeof, instanceof, type guards, o aserciones de tipo) antes de poder operar con el valor.
Rationale: unknown mejora la seguridad de tipos al no permitir operaciones arbitrarias, a diferencia de any que desactiva el chequeo de tipos.
Ejemplo Correcto:
function processUnknown(value: unknown) {
  if (typeof value === 'string') {
    console.log(value.toUpperCase()); // OK
  }
}

TypeScript
Ejemplo Incorrecto (a evitar):
function processAny(value: any) {
  console.log(value.nonExistentProperty.toUpperCase()); // No hay error de compilación, pero fallará en runtime.
}

TypeScript
Validación: ESLint (regla @typescript-eslint/no-explicit-any como warn o error).
5.7. Aserciones de Tipo (as) y Type Guards
Aserciones de Tipo (value as ExpectedType):
Convención: Usar con moderación y solo cuando el desarrollador tiene más información sobre el tipo de un valor de la que el compilador puede inferir.
Común al interactuar con APIs externas o datos no tipados.
Necesario para "brandear" tipos ('some-id' as TenantId).
Acompañar de un comentario si la razón no es obvia.
Evitar el uso excesivo para suprimir errores de tipo legítimos.
Type Guards (Funciones que devuelven parameterName is Type):
Convención: Crear y usar type guards personalizados para refinar tipos en bloques condicionales, especialmente para tipos unión complejos o para verificar la forma de objetos unknown.
Ejemplos existentes: Guard.isNil, Result.isOk, Result.isErr.
Rationale: Las aserciones son una herramienta poderosa pero deben usarse responsablemente. Los type guards mejoran la seguridad y legibilidad del código que maneja tipos unión o unknown.

Ejemplo Correcto (Type Guard):
// function isTenant(obj: any): obj is TenantEntity { /* ... */ }

Validación: Revisión de código para el uso apropiado de aserciones.
---
6. Configuraciones Técnicas
Esta sección detalla las convenciones y configuraciones para las herramientas clave del toolchain de desarrollo, asegurando un entorno consistente y la aplicación automática de estándares.
6.1. ESLint (eslint.config.mjs)
Propósito: Herramienta de linting para identificar y reportar patrones problemáticos en el código TypeScript/JavaScript, así como para hacer cumplir reglas de estilo y, crucialmente, los límites arquitectónicos.
Formato de Configuración: "Flat Config" (eslint.config.mjs) como es el estándar moderno.
Configuración Raíz (dfs-invest-suite/eslint.config.mjs):
Debe ser la base para todas las configuraciones de ESLint de proyectos individuales.
Convenciones Clave Implementadas/Esperadas:
Uso de @nx/eslint-plugin y sus configuraciones base (flat/typescript).
Integración con @typescript-eslint/parser y @typescript-eslint/eslint-plugin.
Configuración de parserOptions.project para apuntar a todos los tsconfig.json relevantes, permitiendo reglas que requieren información de tipos.
Reglas strict y de calidad de TypeScript habilitadas (ej. @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any como warn, @typescript-eslint/no-unsafe-return como warn).
Regla @nx/enforce-module-boundaries (CRUCIAL):
enforceBuildableLibDependency: true.
allow: Definir excepciones permitidas (ej. para los propios archivos de config ESLint).
depConstraints: El corazón de la validación arquitectónica. Se define un conjunto de reglas basadas en tags de Nx (scope:*, type:*, layer:*, domain:*, feature:*) para restringir estrictamente las dependencias entre librerías y capas. (Ver Sección 3.4 para la lógica de estas reglas).
Integración con eslint-config-prettier para desactivar reglas de ESLint que conflicten con Prettier.
Configuración por Proyecto (ej. libs/core/domain/tenancy/eslint.config.mjs):
Convención: Debe heredar de la configuración raíz (import baseConfig from '../../../../eslint.config.mjs'; export default [...baseConfig];).
Puede añadir reglas o sobrescrituras específicas para esa librería/aplicación si es absolutamente necesario y bien justificado.
Uso:
pnpm nx run-many --target=lint --all para lintar todo el proyecto.
pnpm nx lint <project-name> para un proyecto específico.
Integración con IDEs.
Rationale: Mantener la calidad del código, prevenir errores comunes, y hacer cumplir la arquitectura hexagonal de forma automática.
Validación: Ejecución del linter en CI y localmente.
6.2. Prettier (.prettierrc, .prettierignore)
Propósito: Herramienta de formateo de código para asegurar un estilo visual consistente en todo el codebase.
Configuración (.prettierrc):
Convención (Actual): {"singleQuote": true}.
Otras opciones comunes a considerar/mantener (si no son los defaults de Prettier que ya se desean): printWidth, tabWidth, useTabs, semi, trailingComma, bracketSpacing, arrowParens. El objetivo es tener una configuración mínima y dejar que Prettier maneje el resto con sus defaults sensibles.
Ignorados (.prettierignore):
Convención: Incluir directorios generados (dist/, coverage/), node_modules/, y cualquier otro archivo que no deba ser formateado por Prettier.
Uso:
Formateo automático en IDEs (al guardar).
pnpm prettier --write . para formatear todo el proyecto.
pnpm prettier --check . para verificar el formato (usado en CI).
Integración con lint-staged y husky para formatear archivos "staged" antes del commit.
Rationale: Eliminar discusiones sobre estilo de código, asegurar legibilidad y consistencia visual.
Validación: Check de Prettier en CI.
6.3. TypeScript (tsconfig.base.json, tsconfig.*.json por proyecto)
Propósito: Configurar el compilador de TypeScript (tsc) y el chequeo de tipos estático.
tsconfig.base.json (Raíz):
Convenciones Clave Implementadas/Esperadas:
compilerOptions.strict: true y todas las flags relacionadas.
compilerOptions.esModuleInterop: true.
compilerOptions.skipLibCheck: true (para acelerar la compilación ignorando chequeo de tipos en archivos .d.ts de node_modules).
compilerOptions.baseUrl: ".".
compilerOptions.paths: Definición de todos los alias de importación para las librerías del workspace (ej. "@dfs-suite/shared-types": ["libs/shared/types/src/index.ts"]). Mantenidos automáticamente por Nx al generar librerías con --importPath.
compilerOptions.target: Una versión de ECMAScript razonablemente moderna pero compatible (ej. "es2020" o "es2021"). El snapshot muestra "es2015" que podría ser actualizado.
compilerOptions.module: "esnext" (para permitir sintaxis de módulos ES modernos, la transpilación final a commonjs para Node.js se hace en los tsconfig.lib.json o tsconfig.app.json).
exclude: ["node_modules", "tmp", "dist"].
tsconfig.json (Por Proyecto - ej. libs/core/domain/tenancy/tsconfig.json):
Convención: Hereda de tsconfig.base.json. Define compilerOptions específicas para ese proyecto que son comunes a su código fuente y tests (ej. module: "commonjs" para proyectos backend, opciones strict reforzadas). Lista references a tsconfig.lib.json y tsconfig.spec.json.
tsconfig.lib.json (Por Proyecto de Librería):
Convención: Hereda del tsconfig.json del proyecto. Define compilerOptions para el build de la librería:
declaration: true (CRUCIAL para generar archivos .d.ts).
declarationMap: true (RECOMENDADO para mejorar DX).
outDir apuntando a dist/out-tsc en la raíz.
types: Usualmente ["node"] para librerías backend, o [] si es verdaderamente agnóstica al entorno.
include y exclude para seleccionar solo los archivos fuente de la librería (no tests).
tsconfig.spec.json (Por Proyecto con Tests):
Convención: Hereda del tsconfig.json del proyecto. Define compilerOptions para el entorno de tests:
types: ["jest", "node"] (CRUCIAL).
moduleResolution: "node" (RECOMENDADO estandarizar a "node").
include para seleccionar archivos de test y jest.config.ts.
Rationale: Configuración robusta y estricta de TypeScript para máxima seguridad de tipos y DX. Estructura jerárquica para herencia de configuraciones.
Validación: pnpm nx affected --target=type-check (si se define un target type-check), tsc --noEmit en CI, y el propio proceso de build de Nx.
6.4. Nx (nx.json, project.json)
nx.json (Raíz):
Convenciones Clave Implementadas/Esperadas:
defaultBase: "main" (o la rama principal que se use).
namedInputs: Configuración para el caché de Nx (ej. default, production, sharedGlobals).
plugins: Registro de plugins de Nx (@nx/eslint, @nx/jest, @nx/webpack, etc.) con sus opciones por defecto para targets inferidos.
project.json (Por Proyecto):
Convenciones Clave Implementadas/Esperadas:
name: Nombre único del proyecto (ej. core-domain-tenancy).
sourceRoot: Ruta al código fuente.
projectType: application o library.
tags: Array de strings para categorizar el proyecto (scope:*, type:*, layer:*, domain:*, etc.), crucial para depConstraints.
targets: Definición de tareas ejecutables (ej. build, serve, test, lint).
Usar ejecutores de Nx (@nx/jest:jest, @nx/js:node, @nx/webpack:webpack, etc.).
Configurar options apropiadas (ej. jestConfig, passWithNoTests).
Definir outputs para el caché de Nx.
Usar dependsOn para definir dependencias entre targets (ej. e2e depende de serve).
Rationale: Configuración central para que Nx gestione el workspace, optimice tareas, y haga cumplir la arquitectura.
Validación: Funcionamiento de los comandos Nx, nx graph para visualizar dependencias, depConstraints de ESLint.
6.5. Gestor de Paquetes (PNPM y pnpm-workspace.yaml)
Convención (Actual): Usar PNPM como gestor de paquetes para el monorepo.
packageManager en package.json raíz debe especificar la versión de PNPM.
pnpm-workspace.yaml: Define los paquetes que son parte del workspace (generalmente apps/** y libs/**).
pnpm-lock.yaml: DEBE ser comiteado para asegurar builds reproducibles.
Comandos: Usar pnpm install, pnpm add [-D/-W] <package>, pnpm nx ....
Rationale: PNPM es eficiente con el espacio en disco y la gestión de dependencias en monorepos.
Validación: Builds consistentes, correcta instalación de dependencias.
---

7. Manejo de Errores
Un manejo de errores robusto y consistente es crucial para la fiabilidad y mantenibilidad de la aplicación. Esta sección define las convenciones para la creación, propagación y manejo de errores y excepciones.
7.1. Patrón Result<T, E> (libs/shared/result/)
Convención: Utilizar el tipo Result<T, E> (con sus variantes Ok<T,E> y Err<E,T> y helpers ok(), err(), isOk(), isErr()) para el tipo de retorno de funciones y métodos que pueden fallar debido a errores de negocio esperados o fallos predecibles de operaciones externas.
Esto aplica principalmente a:
Métodos de Entidades de Dominio que ejecutan lógica de negocio con posibles fallos (ej. TenantEntity.activate() puede devolver Err<InvalidTenantStatusTransitionError>).
Casos de Uso (Command Handlers y Query Handlers) en la capa de aplicación (ej. ActivateTenantUseCase.execute() devuelve Promise<Result<void, ExceptionBase | Error>>).
Métodos de Puertos de Repositorio y otros Puertos de Servicio que interactúan con infraestructura (ej. ITenantRepository.findOneById() devuelve Promise<Result<Maybe<TenantEntity>, ExceptionBase | Error>>).
Rationale:
Hace explícitos los posibles caminos de error en las firmas de tipo.
Fuerza al código llamador a manejar conscientemente tanto el caso de éxito como el de error, sin depender de bloques try/catch para la lógica de flujo de negocio normal.
Mejora la predictibilidad y robustez del código.
Permite un encadenamiento funcional de operaciones que pueden fallar (.andThen(), .orElse()).
Uso:
Devolución:
Éxito: return ok(value); o return ok(undefined);
Error: return err(new MySpecificError(...));
Consumo:
const result = await myService.doSomething();
if (isOk(result)) {
  // Procesar result.value
} else { // isErr(result)
  // Procesar result.error (ej. loguear, mapear a error HTTP)
}

TypeScript
O usando métodos funcionales:
return (await myService.doSomething())
  .mapErr(error => new HigherLevelError('Failed', { cause: error }))
  .andThen(value => anotherOperation(value));

TypeScript
Tipos de Error (E en Result<T,E>):
Deben ser instancias de ExceptionBase o sus subclases (tanto genéricas de shared-errors como específicas de dominio).
Evitar usar Error genérico como tipo E si es posible, para mantener la estructura de code, metadata, etc.
Validación: Revisión de código, consistencia en firmas de métodos.
7.2. Excepciones Personalizadas (libs/shared/errors/ y Específicas de Dominio)
Convención:
Todas las excepciones personalizadas del sistema DEBEN heredar de ExceptionBase (definida en libs/shared/errors/src/lib/exception.base.ts).
Excepciones Genéricas: Para errores comunes no ligados a un dominio específico (ej. argumento inválido, recurso no encontrado, conflicto genérico, error interno), utilizar las clases predefinidas en libs/shared/errors/src/lib/generic.exceptions.ts (ej. NotFoundException, ArgumentInvalidException, InternalServerErrorException).
Excepciones Específicas de Dominio: Para errores que representan una violación de una regla de negocio dentro de un bounded context específico, crear clases de excepción dedicadas que hereden de ExceptionBase.
Nomenclatura: NombreCondicionError (ej. TenantAlreadyExistsError, InvalidTenantStatusTransitionError).
Ubicación: libs/core/domain/<bounded-context>/src/lib/errors/.
Cada excepción de dominio debe tener un code único y descriptivo (ver 7.3).
Lanzamiento vs. Devolución en Result:
Errores de Negocio Esperados: Generalmente se devuelven como la parte Err de un Result por métodos de dominio y casos de uso.
Errores de Programación o Invariantes Rotos Fundamentales: Pueden ser lanzados directamente (ej. throw new ArgumentNotProvidedException(...) en un constructor de VO o entidad si los datos de entrada son fundamentalmente incorrectos para crear una instancia válida).
Errores Inesperados en Capas Bajas: Si un adaptador de infraestructura encuentra un error de red irrecuperable, podría lanzar una excepción (que luego un filtro global podría capturar).
Propiedades de Excepción:
message: Descriptivo.
code: Código único (ver 7.3).
cause: La excepción original, si aplica.
metadata: Objeto con información contextual adicional relevante para el error.
correlationId: Para trazabilidad.
Rationale: Proporciona una jerarquía de errores estructurada, tipada y consistente. Facilita el manejo de errores, logging y mapeo a respuestas de API.
Ejemplo Correcto (Error de Dominio):
// en libs/core/domain/tenancy/src/lib/errors/max-users-reached.error.ts
// export const MAX_USERS_REACHED = 'TENANCY.MAX_USERS_REACHED';
// export class MaxUsersReachedError extends ExceptionBase {
//   public readonly code = MAX_USERS_REACHED;
//   constructor(tenantId: TenantId, currentLimit: number, metadata?: ObjectLiteral, correlationId?: CorrelationId) {
//     super(`Tenant ${String(tenantId)} has reached a
//           maximum user limit of ${currentLimit}.`,
//           undefined, { ...metadata, tenantId, currentLimit }, correlationId);
//   }
// }

TypeScript
Validación: Revisión de código, tests que verifiquen el lanzamiento/retorno de los tipos de error correctos.
7.3. Códigos de Error
Convención:
Cada subclase de ExceptionBase DEBE definir una propiedad readonly code: string; con un valor único.
Los códigos deben seguir un formato CONTEXTO_MAYUSCULAS.ERROR_ESPECIFICO_MAYUSCULAS.
Genéricos: GENERIC.TIPO_ERROR (ej. GENERIC.NOT_FOUND). Definidos en libs/shared/errors/src/lib/exception.codes.ts.
Dominio Específico: DOMINIO_MAYUSCULAS.ERROR_ESPECIFICO (ej. TENANCY.INVALID_TENANT_STATUS_TRANSITION). Definidos como constantes en el archivo de error de dominio.
Rationale: Permite la identificación programática unívoca de los errores, independientemente del mensaje (que puede cambiar o ser traducido). Útil para que los clientes (frontend, otros servicios) o sistemas de monitoreo reaccionen a errores específicos.
Validación: Revisión de código. Se podría considerar un script que verifique la unicidad de los códigos si la lista crece mucho.
7.4. Logging de Errores
Convención:
Todos los errores capturados (ya sean devueltos en Result.Err o excepciones catcheadas) deben ser logueados usando el ILoggerPort.
El log debe incluir:
Mensaje del error (error.message).
Código del error (error.code si es ExceptionBase).
Stack trace (error.stack).
correlationId (del error o del contexto).
metadata del error, si existe.
Contexto de la operación donde ocurrió el error.
Usar logger.error() para errores que interrumpen el flujo o son inesperados.
Usar logger.warn() para errores de negocio esperados (devueltos en Result.Err) que son manejados pero indican una desviación del flujo feliz.
Ejemplo (en un Caso de Uso):
// if (isErr(result)) {
//   this.logger.warn(
//     `Business rule violation: ${result.error.message}`,
//     this.constructor.name, // context
//     correlationId,
//     { errorCode: result.error.code, errorMeta: result.error.metadata }
//   );
//   return err(result.error);
// }
// try { /* ... */ } catch (e) {
//   const internalError = new InternalServerErrorException('details', e, meta, corrId);
//   this.logger.error(internalError.message, internalError.stack, context, corrId, internalError.metadata);
// }

TypeScript
Rationale: Fundamental para la observabilidad, depuración y monitoreo del sistema.
Validación: Revisión de código, análisis de logs en desarrollo/staging.
7.5. Manejo de Errores en Casos de Uso y API
Casos de Uso:
Deben manejar los Result.Err devueltos por el dominio o los repositorios.
Pueden enriquecer el error, mapearlo a un error de aplicación más general, o propagarlo.
Deben capturar excepciones inesperadas de las dependencias y envolverlas en un InternalServerErrorException (o similar) dentro de un Result.Err.
Capa de API (api-main):
Utilizar un Filtro de Excepciones Global (NestJS ExceptionFilter) para capturar todas las excepciones (tanto las que se escapan de los Result.Err como las lanzadas directamente).
El filtro debe:
Loguear el error (usando ILoggerPort).
Mapear la excepción (o el error de un Result.Err si el controlador lo propaga como excepción) a una estructura IApiResponse<T> con success: false.
Usar error.code y error.message de ExceptionBase para poblar la respuesta.
Asignar un código de estado HTTP semánticamente correcto basado en el tipo de excepción o su code (ej. NotFoundException -> 404, ArgumentInvalidException -> 400, TenantAlreadyExistsError -> 409).
Rationale: Asegura un manejo de errores consistente en los límites de la aplicación y respuestas de API predecibles para los clientes.
Validación: Tests E2E que prueben diferentes escenarios de error y verifiquen las respuestas de la API.
---

8. Patrones de Pruebas
Una estrategia de testing exhaustiva y bien definida es fundamental para asegurar la calidad, robustez y mantenibilidad del proyecto. Se seguirá el principio de la Pirámide de Testing.
8.1. Tipos de Tests y su Ubicación (*.spec.ts)
Convención:
Tests Unitarios (Unit Tests):
Propósito: Verificar la lógica de unidades de código aisladas (clases, métodos, funciones) sin dependencias externas reales (estas se mockean).
Alcance: Lógica de Dominio (Entidades, VOs, Servicios de Dominio), lógica de Casos de Uso (Application Services), funciones utilitarias, lógica de Mappers, lógica de presentación simple en componentes UI (si aplica).
Ubicación: Archivos *.spec.ts junto al archivo que están probando (ej. tenant.entity.ts y tenant.entity.spec.ts en la misma carpeta).
Tests de Integración (Integration Tests):
Propósito: Verificar la interacción correcta entre múltiples componentes o capas.
Alcance (Backend):
Adaptadores de Repositorio contra una base de datos de prueba real (ej. usando Testcontainers o una DB en memoria).
Interacción entre Casos de Uso y sus adaptadores de Repositorio (con DB real).
Procesadores de Colas (BullMQ) contra una instancia Redis de prueba.
Módulos NestJS (@nestjs/testing) para verificar la correcta inyección de dependencias y la interacción básica entre controladores/resolvers y servicios de aplicación (con dependencias de infraestructura mockeadas o reales según el scope del test).
Ubicación: Pueden ser archivos *.spec.ts o *.integration-spec.ts junto a los componentes que integran, o en una carpeta de tests de integración separada dentro de la librería/app si son muy complejos.
Tests End-to-End (E2E Tests):
Propósito: Validar flujos de usuario completos a través de la API desplegada (o servida localmente), simulando la interacción real del cliente.
Alcance (api-main): Probar los endpoints de la API (REST/GraphQL) enviando solicitudes HTTP y verificando las respuestas, incluyendo efectos secundarios en la base de datos (de prueba).
Ubicación: En el proyecto E2E dedicado (ej. apps/api-main-e2e/src/).
Tests de Performance y Carga (No Funcionales - Post-MVP):
Propósito: Asegurar que el sistema cumple con los SLAs de rendimiento y puede manejar la carga esperada.
Herramientas: k6 o similar.
Rationale: Una pirámide de testing equilibrada (muchos unitarios rápidos, menos de integración, y aún menos E2E) proporciona la mejor combinación de confianza, velocidad de feedback y costo de mantenimiento.
Validación: Cobertura de código, ejecución en CI.
8.2. Nomenclatura de Archivos de Test (.spec.ts)
Convención: Para un archivo nombre-archivo.ts, su archivo de test unitario/integración asociado debe ser nombre-archivo.spec.ts.
Ejemplo Correcto: tenant.entity.ts -> tenant.entity.spec.ts.
Ejemplo Incorrecto: TestTenantEntity.js, tenant.entity_test.ts.
Validación: Convención de nombres, configuración de Jest para encontrar estos archivos.
8.3. Estructura de Tests (Describe, It, BeforeEach, AfterEach)
Convención (Jest):
describe('NombreClaseOMetodo', () => { ... });: Agrupa tests relacionados. Se pueden anidar describe para mayor estructura.
it('should <comportamiento esperado> when <condición>', () => { ... }); (o test(...)): Define un caso de test individual con un nombre descriptivo.
beforeEach(() => { ... });: Código de setup que se ejecuta antes de cada it dentro de un describe. Útil para inicializar mocks o instancias.
afterEach(() => { ... });: Código de teardown que se ejecuta después de cada it. Útil para limpiar mocks (jest.clearAllMocks()).
beforeAll(() => { ... }); / afterAll(() => { ... });: Para setup/teardown que se ejecuta una vez por describe block.
Patrón Arrange-Act-Assert (AAA): Estructurar el cuerpo de cada it en tres secciones claras:
Arrange: Configurar las precondiciones, datos de entrada y mocks.
Act: Ejecutar la unidad de código bajo prueba.
Assert: Verificar que el resultado y los efectos secundarios (ej. llamadas a mocks) sean los esperados usando expect(...).
Rationale: Tests bien estructurados, legibles y fáciles de mantener.
Validación: Revisión de código.
8.4. Mocks y Spies (Jest)
Convención:
Dependencias Externas: Mockear todas las dependencias externas de la unidad bajo prueba.
Para Casos de Uso, mockear los Puertos de Repositorio, Puertos de Logger, otros Puertos de Servicio.
Para Entidades, generalmente no se mockean sus VOs (se usan instancias reales), pero sí se podrían mockear servicios de dominio si los usa.
Creación de Mocks: Usar jest.fn() para funciones simples, o jest.mock('path/to/module', () => ({ ... })) para módulos. Para clases, se puede mockear su constructor y métodos.
// Ejemplo de mock para un repositorio
// mockTenantRepository = {
//   findOneById: jest.fn(),
//   update: jest.fn(),
//   // ...otros métodos como jest.fn()
// };

TypeScript
Spies (jest.spyOn(object, 'methodName')): Usar para espiar llamadas a métodos de instancias reales (o mocks parciales) y verificar si fueron llamados, con qué argumentos, o para mockear su implementación temporalmente. Recordar usar spy.mockRestore() en afterEach si se modifica la implementación original.
Aserciones sobre Mocks: Usar expect(mockFn).toHaveBeenCalled(), toHaveBeenCalledWith(...), toHaveBeenCalledTimes(...), mockReturnValue(...), mockResolvedValue(...), mockRejectedValue(...).
Rationale: Aislar la unidad bajo prueba, tests deterministas, control sobre el comportamiento de las dependencias.
Validación: Revisión de tests.
8.5. Cobertura de Código
Convención:
Objetivo: Apuntar a una alta cobertura de código (ej. >85-90%) para las líneas, ramas y funciones de la lógica de dominio (layer:domain) y aplicación (layer:application).
La cobertura para librerías de solo tipos/interfaces o utilidades muy simples puede ser menor o no aplicar.
Usar el flag --coverage con Jest para generar reportes.
Configurar collectCoverageFrom en jest.config.ts para incluir solo los archivos relevantes (excluir index.ts, DTOs sin lógica, interfaces).
Configurar coverageThreshold en jest.config.ts (globalmente en jest.preset.js o por proyecto) para hacer fallar el build si la cobertura no alcanza los mínimos.
Rationale: Asegurar que la mayor parte del código esté probada, reduciendo la probabilidad de bugs.
Validación: Reportes de cobertura, configuración de umbrales en CI.
8.6. passWithNoTests: true (Uso y Transición)
Convención:
Permitido en project.json para librerías nuevas o aquellas que solo contienen interfaces/tipos y no tienen lógica ejecutable testeable (ej. core-domain-shared-kernel-ports si solo tiene interfaces).
DEBE ser cambiado a false (o eliminado, ya que false es el default) tan pronto como se añadan los primeros archivos .spec.ts con tests reales a una librería.
Rationale: Facilita el scaffolding inicial de librerías sin que el target test falle.
Riesgo: Si se olvida cambiar a false, los tests podrían no ejecutarse o sus fallos podrían ser ignorados.
Validación: Revisión de project.json al añadir tests a una librería.
---

9. Convenciones de API (para api-main)
Esta sección detalla las convenciones para el diseño, implementación y documentación de la API principal del sistema (apps/api-main), que será construida con NestJS.
9.1. Estilo de API (GraphQL Principal, REST para Casos Específicos)
Convención (Según Blueprint): La API principal se expondrá principalmente a través de GraphQL. Se pueden usar endpoints REST para casos específicos como:
Webhooks entrantes de servicios externos (ej. WhatsApp Cloud API).
Operaciones de subida/bajada de archivos si son más sencillas con REST.
Endpoints de salud (/health) o métricas (/metrics).
GraphQL:
Schema First o Code First: El proyecto parece inclinarse hacia Code First con NestJS (usando decoradores @Resolver, @Query, @Mutation, @Args, @ObjectType, @Field, etc.). Esto debe mantenerse.
Nomenclatura de Queries/Mutations: Nombres descriptivos y en camelCase (ej. getTenantDetails, createTenant).
Tipos de Entrada (Args): Definidos como clases con decoradores @InputType() y @Field(), validados.
Tipos de Salida (Object Types): Definidos como clases con decoradores @ObjectType() y @Field(), representando los DTOs de respuesta.
REST:
Nomenclatura de Endpoints: Plural para recursos, kebab-case o camelCase. Usar verbos HTTP estándar (GET, POST, PUT, DELETE, PATCH).
Ejemplo: GET /api/tenants, POST /api/tenants, GET /api/tenants/{tenantId}.
Parámetros de Ruta, Query, Cuerpo: Claramente definidos y validados.
Rationale: GraphQL ofrece flexibilidad para los clientes al solicitar solo los datos que necesitan. REST es bien entendido y adecuado para interacciones más simples o webhooks. Code First con NestJS se integra bien con TypeScript.
Validación: Diseño de API, revisión de código, documentación de API.
9.2. Formato de Respuesta Estándar (IApiResponse<T>) para REST
Convención: Todas las respuestas JSON de los endpoints REST DEBEN seguir la estructura definida por IApiResponse<T> (de libs/shared/types/).
success: boolean
data?: T (para respuestas exitosas)
error?: { code: string; message: string; details?: unknown } (para success: false)
timestamp: IsoDateString
correlationId: CorrelationId
Implementación: Un Interceptor de Transformación de Respuesta global en NestJS (TransformResponseInterceptor) se encargará de envolver las respuestas exitosas. Un Filtro de Excepciones Global (AllExceptionsFilter) se encargará de formatear los errores en esta estructura.
GraphQL: No usa IApiResponse. GraphQL tiene su propia estructura estándar para respuestas (un objeto con una clave data y/o una clave errors).
Rationale: Consistencia para los clientes REST, información útil en cada respuesta.
Validación: Implementación del interceptor y filtro, tests E2E verificando la estructura de respuesta.
9.3. DTOs de Entrada y Salida
Convención:
DTOs de Entrada (Request DTOs):
Para REST: Clases TypeScript con decoradores de class-validator (si se usa ese enfoque) o tipos/interfaces simples si se usa ZodValidationPipe. Dado que se ha establecido libs/shared/validation-schemas con Zod, se prefiere que los DTOs de entrada sean validados por esquemas Zod. Pueden ser interfaces simples o tipos inferidos de Zod.
Para GraphQL: Clases con decoradores @InputType() y @Field().
Nomenclatura: NombreAccionDto o NombreRecursoInputDto (ej. CreateTenantApiDto, ActivateTenantInput).
DTOs de Salida (Response DTOs):
Para REST: Interfaces o tipos que definen la estructura de data dentro de IApiResponse<T>. (ej. TenantDetailsDto de libs/core/application/tenancy/).
Para GraphQL: Clases con decoradores @ObjectType() y @Field(). (ej. TenantType que podría basarse en TenantDetailsDto).
Nomenclatura: NombreRecursoDto o NombreRecursoDetailsDto (ej. TenantDetailsDto).
Ubicación:
DTOs específicos de la API pueden residir en apps/api-main/src/dtos/ o agrupados por feature/módulo dentro de api-main.
DTOs de aplicación (más genéricos, usados por Casos de Uso para devolver datos) residen en libs/core/application/<contexto>/src/lib/dtos/. La API puede usar estos directamente o tener sus propios DTOs de API que mapean desde DTOs de aplicación.
Inmutabilidad: Las propiedades de los DTOs deben ser readonly siempre que sea posible.
Rationale: Contratos de datos claros entre cliente y servidor, facilita la validación y la generación de documentación de API.
Validación: Definición de DTOs, uso en controladores/resolvers.
9.4. Validación de DTOs de Entrada (Zod a través de Pipes)
Convención: Todas las entradas de API (cuerpos de solicitud REST, argumentos de GraphQL) DEBEN ser validadas.
Utilizar los esquemas Zod definidos en libs/shared/validation-schemas/ y esquemas específicos de DTOs.
En NestJS, implementar un ZodValidationPipe global o aplicado a rutas/argumentos específicos. Este pipe tomará el schema Zod apropiado y validará los datos de entrada.
Manejo de Errores de Validación: Los errores de validación de Zod deben ser capturados por el ZodValidationPipe y transformados en una respuesta de error estructurada (HTTP 400 para REST, o un error GraphQL formateado), idealmente usando la estructura IApiResponse con success: false y los detalles de validación en error.details.
Rationale: Seguridad, integridad de datos, "fail fast".
Validación: Implementación del Pipe, tests E2E con datos válidos e inválidos.
9.5. Códigos de Estado HTTP (para REST)
Convención: Utilizar los códigos de estado HTTP semánticamente correctos:
200 OK: GET exitoso con contenido, PUT/PATCH exitoso con contenido.
201 Created: POST exitoso que crea un nuevo recurso. La respuesta puede incluir el recurso creado o una URL al mismo.
204 No Content: PUT/PATCH/DELETE exitoso sin contenido que devolver.
400 Bad Request: Errores de validación del cliente, solicitud malformada (mapeado desde ArgumentInvalidException, ArgumentNotProvidedException, errores de Zod).
401 Unauthorized: Falla de autenticación (token JWT faltante o inválido).
403 Forbidden: Usuario autenticado pero sin permisos para el recurso/acción.
404 Not Found: Recurso no encontrado (mapeado desde NotFoundException).
409 Conflict: Conflicto con el estado actual del recurso (ej. recurso ya existe, mapeado desde TenantAlreadyExistsError o ConflictException).
500 Internal Server Error: Errores inesperados del servidor (mapeado desde InternalServerErrorException o excepciones no capturadas).
Implementación: El Filtro de Excepciones Global (AllExceptionsFilter) es responsable de mapear las excepciones del sistema a estos códigos de estado.
Rationale: Cumplimiento de los estándares HTTP, claridad para los clientes.
Validación: Tests E2E.
9.6. Versionado de API (Futuro)
Convención (a definir): Cuando sea necesario introducir cambios no retrocompatibles, se implementará versionado.
Opción 1 (URL Path): /api/v1/..., /api/v2/... (común y simple).
Opción 2 (Cabecera Accept): Accept: application/vnd.dfs-invest.v1+json.
Rationale: Permitir la evolución de la API sin romper clientes existentes.
Validación: N/A en esta fase.
9.7. Autenticación y Autorización (JWT, RBAC)
Autenticación:
Convención: Tokens JWT (JSON Web Tokens) firmados asimétricamente (RS256/ES256).
El token se envía en la cabecera Authorization con el esquema Bearer.
Incluir userId y tenantId (si aplica) en el payload del JWT.
Manejo de refresh tokens para mantener sesiones.
MFA para roles administrativos.
Implementación: AuthModule en api-main con estrategias Passport (passport-jwt).
Autorización:
Convención: Control de Acceso Basado en Roles (RBAC).
Roles definidos (PlatformAdmin, TenantAdmin, Supervisor, Consultant).
Permisos asociados a roles.
Implementación: RolesGuard en NestJS, aplicado a controladores/resolvers o métodos específicos. Los permisos pueden definirse en una matriz o ACL.
Rationale: Seguridad robusta y granular.
Validación: Tests de seguridad, tests de integración para guards, revisión de código.
9.8. Paginación (IPaginatedQueryParams, IPaginated<T>)
Convención: Para endpoints que devuelven listas, implementar paginación usando los parámetros definidos en IPaginatedQueryParams (limit, page, sortBy, sortOrder, filtros).
La respuesta debe seguir la estructura IPaginated<T>.
Defaults y Límites: Usar las constantes de libs/shared/constants/ (DEFAULT_PAGE_LIMIT, MAX_PAGE_LIMIT, DEFAULT_PAGE).
Rationale: Rendimiento, evitar sobrecarga del servidor y del cliente.
Validación: Tests E2E con diferentes parámetros de paginación y ordenación.
9.9. CorrelationId en Cabeceras y Respuestas
Convención:
Solicitudes Entrantes: Si un cliente envía una cabecera X-Correlation-ID (o similar), la API debe usar ese ID. Si no, la API (middleware) debe generar un nuevo CorrelationId.
Respuestas Salientes: Todas las respuestas de API (REST, y GraphQL si es posible en metadata de extensión) deben incluir el CorrelationId correspondiente. En REST, esto se logra a través de IApiResponse.
Rationale: Trazabilidad completa de las solicitudes a través del sistema.
Validación: Middleware, Interceptor/Filtro, logs, tests E2E.
---

10. Documentación
Una documentación clara, concisa y actualizada es esencial para la comprensión, mantenimiento y evolución del proyecto. Se adoptarán múltiples niveles de documentación.
10.1. Comentarios en Código (JSDoc/TSDoc)
Convención:
Obligatorio: Todas las clases, interfaces, tipos, enums, funciones y métodos exportados (públicos) DEBEN tener comentarios JSDoc/TSDoc.
Contenido Mínimo:
Breve descripción del propósito del artefacto (@description o la primera línea).
Para funciones/métodos: @param para cada parámetro (nombre, tipo si no es obvio, descripción), @returns para el valor de retorno.
Para clases/interfaces con genéricos: @template para cada parámetro genérico.
Opcional pero recomendado: @throws para excepciones específicas que puede lanzar un método, @example para ilustrar el uso.
Estilo: Claro, conciso y en inglés para los comentarios directamente asociados al código (JSDoc/TSDoc en archivos .ts), pero permitiendo español para explicaciones más amplias o de lógica de negocio contextual si facilita la comprensión del equipo.
Formato: Seguir el estándar JSDoc/TSDoc para que herramientas como TypeDoc puedan generar documentación.
Secciones SECCIÓN DE MEJORAS FUTURAS y NOTAS PARA IMPLEMENTACIÓN FUTURA: Mantener el formato actual de /* ... */ al final de los archivos .ts relevantes para registrar ideas de evolución y consideraciones específicas de ese artefacto.
Ejemplo Correcto (ya visto en los archivos analizados):
/**
 * @interface IMyInterface
 * @template T - El tipo genérico para la data.
 * @description Describe el propósito de esta interfaz.
 */
export interface IMyInterface<T> {
  /**
   * @method doSomething
   * @param {string} input - El parámetro de entrada.
   * @returns {T} El resultado del tipo genérico.
   * @throws {MyCustomError} Si la operación falla.
   */
  doSomething(input: string): T;
}

TypeScript
Rationale: Mejora la legibilidad y mantenibilidad del código, facilita el onboarding de nuevos desarrolladores, y permite la generación automática de documentación de API.
Validación:
Revisión de código.
ESLint con eslint-plugin-jsdoc para forzar la presencia y formato de comentarios JSDoc.
Generación de documentación con TypeDoc y revisión de la salida.
10.2. READMEs de Librerías y Aplicaciones
Convención:
Cada proyecto Nx (librería o aplicación en libs/ y apps/) DEBE tener un archivo README.md en su raíz.
Contenido Mínimo:
Nombre del proyecto.
Breve descripción de su propósito y responsabilidad dentro del sistema.
Comandos Nx principales para ese proyecto (ej. test, lint, serve, build).
Instrucciones de setup o dependencias clave si las tiene y son específicas.
Notas importantes o "gotchas" para los desarrolladores.
El README.md raíz del monorepo (ya existente) debe proporcionar una visión general del proyecto, instrucciones de setup globales y enlaces a documentación más detallada.
Lenguaje: Español (para facilitar la comprensión del equipo principal).
Rationale: Proporciona información esencial y de inicio rápido para cada componente del monorepo.
Validación: Revisión manual de la existencia y calidad de los READMEs.
10.3. Documentación Arquitectónica (.DOCUMENTO-TECNICO-PROYECTO.md)
Convención:
Mantener un documento técnico central (como el .DOCUMENTO-TECNICO-PROYECTO.md que estamos usando como base para el análisis y que el blueprint maestro referencia) que describa la visión arquitectónica general, los principios de diseño, la estructura de capas, los flujos de datos clave y las decisiones arquitectónicas importantes.
Este documento debe incluir diagramas conceptuales (ej. diagrama de capas, diagrama de contexto, diagrama C4 si aplica) para ilustrar la arquitectura.
Debe ser un documento "vivo", actualizado a medida que la arquitectura evoluciona.
Lenguaje: Español.
Rationale: Sirve como la fuente única de verdad para la comprensión de alto nivel de la arquitectura del sistema.
Validación: Revisiones arquitectónicas periódicas, asegurar que el documento refleje el estado actual del diseño.
10.4. Bitácora de Desarrollo (.BITACORA.md)
Convención (Actual): Mantener un archivo .BITACORA.md para registrar:
Decisiones técnicas importantes tomadas.
Cambios significativos en el stack o arquitectura.
Problemas relevantes encontrados y sus soluciones.
Hitos de desarrollo completados.
Preferencias o aclaraciones del desarrollador que guían a la IA.
Formato: Por fecha, con secciones claras.
Lenguaje: Español.
Rationale: Proporciona un historial cronológico de la evolución del proyecto y las decisiones clave, útil para referencia futura y para entender el contexto de ciertos cambios.
Validación: Actualización regular por parte del equipo (y la IA cuando corresponda a decisiones tomadas en conjunto).
10.5. Registro de Deuda Técnica (.DEUDA-TECNICA.md)
Convención (Actual): Mantener un archivo .DEUDA-TECNICA.md para registrar explícitamente:
Problemas de código conocidos que no se pueden resolver inmediatamente.
Soluciones temporales o "workarounds" implementados.
Justificación para la deuda.
Plan o ideas para su refactorización futura.
Desactivaciones de reglas de linting y su justificación.
Formato: Estructurado por librería/archivo, problema, decisión y tarea pendiente.
Lenguaje: Español.
Rationale: Hace visible la deuda técnica, permite su priorización y seguimiento, y evita que se olvide.
Validación: Revisión periódica, vincular ítems a tareas en un gestor de proyectos.
10.6. Roadmap (.ROADMAP.md)
Convención (Actual): Mantener un archivo .ROADMAP.md que detalle las fases, hitos y tareas planificadas.
Usar leyenda de estado (Completado, En Progreso, Pendiente, etc.).
Formato: Estructurado por fases e hitos.
Lenguaje: Español.
Rationale: Proporciona una visión clara del plan de desarrollo y el progreso.
Validación: Actualización regular a medida que se completan hitos y se planifican nuevas fases.
10.7. Documentación de API (api-main)
Convención (según blueprint):
GraphQL: El esquema GraphQL es inherentemente auto-documentable.
Utilizar descripciones (description: '...') en los decoradores @ObjectType(), @Field(), @Query(), @Mutation(), @ArgsType(), @InputType() para enriquecer la documentación del esquema.
Herramientas como GraphQL Playground o Apollo Studio pueden usarse para explorar el esquema.
REST (para endpoints específicos):
Utilizar el módulo @nestjs/swagger para generar documentación OpenAPI 3.0.
Anotar Controladores, métodos de controlador y DTOs con los decoradores de Swagger (@ApiTags, @ApiOperation, @ApiResponse, @ApiProperty, etc.).
Despliegue: La documentación Swagger/OpenAPI debe ser accesible a través de un endpoint de la API en entornos de desarrollo/staging (ej. /api-docs).
Rationale: Facilita la comprensión, prueba y consumo de la API por parte de los desarrolladores de frontend, otros servicios, o herramientas de prueba.
Validación: Generación y revisión de la documentación OpenAPI. Exploración del esquema GraphQL.

---
11. Mecanismos de Validación de Convenciones
Para asegurar la adherencia a las convenciones establecidas en este documento, se utilizarán una combinación de herramientas automáticas y procesos manuales. El objetivo es detectar y corregir desviaciones lo antes posible en el ciclo de desarrollo.
11.1. ESLint (Análisis Estático de Código)
Herramienta Principal: ESLint, configurado a través de eslint.config.mjs (formato "flat config").
Validaciones Clave:
Estilo de Código y Calidad: Reglas de @typescript-eslint/eslint-plugin (ej. no-unused-vars, no-explicit-any, reglas de recommended-type-checked).
Límites de Módulo Arquitectónicos (CRUCIAL): La regla @nx/enforce-module-boundaries configurada con depConstraints basados en los tags de Nx (scope:*, type:*, layer:*) es el principal mecanismo automático para hacer cumplir la arquitectura hexagonal y las reglas de dependencia entre capas. Las violaciones deben ser tratadas como errores.
Nomenclatura (Parcial): Se pueden configurar reglas de @typescript-eslint/naming-convention para forzar ciertos patrones en nombres de clases, interfaces, enums, etc.
JSDoc/TSDoc (Opcional): El plugin eslint-plugin-jsdoc puede usarse para requerir y validar la estructura de los comentarios de documentación.
Ejecución:
Integrado en el IDE para feedback en tiempo real.
Localmente: pnpm nx lint <project-name> o pnpm nx run-many --target=lint --all.
CI Pipeline: Como un paso obligatorio.
Rationale: Detección temprana y automática de problemas de código y violaciones arquitectónicas.
11.2. Prettier (Formateo Automático)
Herramienta Principal: Prettier, configurado a través de .prettierrc.
Validaciones Clave: Asegura un formato de código visualmente consistente (indentación, espacios, saltos de línea, comillas, etc.).
Ejecución:
Automáticamente al guardar en el IDE (con la extensión de Prettier).
Localmente: pnpm prettier --write . (para formatear) o pnpm prettier --check . (para verificar).
Hooks de Git (lint-staged): Para formatear archivos "staged" antes del commit.
CI Pipeline: Ejecutar prettier --check . para asegurar que el código comiteado esté formateado.
Rationale: Elimina debates sobre estilo, mejora la legibilidad, y mantiene la consistencia.
11.3. TypeScript Compiler (tsc)
Herramienta Principal: El compilador de TypeScript.
Validaciones Clave:
Chequeo de Tipos Estricto: Gracias a "strict": true y opciones relacionadas en los tsconfig.*.json, tsc realiza una validación exhaustiva de tipos.
Errores de Compilación: Cualquier error de tipo o sintaxis detendrá el proceso.
Ejecución:
Integrado en el IDE.
Durante los builds de Nx (pnpm nx build <app-name>).
Se puede definir un target Nx type-check que ejecute tsc --noEmit -p <tsconfig-path> para solo validar tipos. (El snapshot no lo tiene explícito pero es una buena práctica).
CI Pipeline: Como parte del build o un paso de type-check separado.
Rationale: Pilar fundamental para la seguridad de tipos y la detección temprana de errores relacionados con tipos.
11.4. Hooks de Git (Husky, lint-staged) - (Mejora Futura/Recomendada)
Propósito: Automatizar la ejecución de linters y formateadores antes de que el código sea comiteado o pusheado.
Herramientas:
husky: Para gestionar los hooks de Git.
lint-staged: Para ejecutar comandos en los archivos que están en el "staging area" de Git.
Implementación (Sugerida):
Instalar: pnpm add -D husky lint-staged
Configurar Husky: pnpm husky install, npx husky add .husky/pre-commit "npx lint-staged"
Configurar lint-staged en package.json:
// En package.json
"lint-staged": {
  "*.{ts,tsx,js,jsx,json,html,css,scss,less,md,yaml,yml}": "prettier --write",
  "*.{ts,tsx,js,jsx}": "eslint --fix"
}

Json
Flujo: Antes de cada git commit, lint-staged ejecutará Prettier y ESLint (con --fix) solo en los archivos modificados y listos para comitear.
Rationale: Asegura que solo código formateado y sin errores de linting (auto-corregibles) llegue al repositorio, mejorando la calidad de la base de código y reduciendo el ruido en las revisiones de código.
Validación: Automática durante el proceso de commit.
11.5. Pipelines de CI (Integración Continua - GitHub Actions)
Propósito: Automatizar la validación completa del proyecto en cada push o Pull Request.
Validaciones Clave en CI:
Instalación de Dependencias: pnpm install --frozen-lockfile.
Linting: pnpm nx run-many --target=lint --all.
Formato (Check): pnpm prettier --check .
Type Checking (Opcional si el build lo cubre): pnpm nx run-many --target=type-check --all o tsc --noEmit -p tsconfig.base.json (y configs de apps).
Tests Unitarios e Integración (con Cobertura): pnpm nx run-many --target=test --all --coverage.
(Futuro) Forzar umbrales de cobertura.
Build de Aplicaciones: pnpm nx build <app-name> --configuration=production.
Tests E2E: pnpm nx e2e <app-e2e-name>.
(Opcional) Análisis de Seguridad de Dependencias: pnpm audit o integración con Snyk/Dependabot.
(Opcional) SAST (Static Application Security Testing).
Configuración: Archivos de workflow de GitHub Actions (ej. .github/workflows/ci.yml).
Rationale: Proporciona un feedback rápido sobre la salud del proyecto, previene la integración de código roto o que no cumple los estándares, y automatiza el proceso de validación.
Validación: El pipeline debe pasar para que un Pull Request pueda ser mergeado.
11.6. Revisiones de Código (Pull Requests)
Propósito: Proceso manual (asistido por herramientas) para asegurar la calidad, adherencia a la arquitectura, y la correcta implementación de la lógica de negocio.
Convenciones:
Todo el código nuevo o modificado DEBE pasar por un proceso de Pull Request (PR).
Al menos un revisor (que no sea el autor) debe aprobar el PR.
Los checks de CI deben pasar antes de poder hacer merge.
Los PRs deben ser pequeños y enfocados en una tarea o feature específica.
La descripción del PR debe ser clara, explicando el qué y el por qué del cambio, y cómo probarlo.
Los revisores deben enfocarse en:
Adherencia a este Documento de Convenciones.
Correctitud de la lógica.
Calidad del código y tests.
Impacto arquitectónico.
Posibles efectos secundarios.
Rationale: Detección de errores y problemas de diseño que las herramientas automáticas pueden no capturar. Fomenta el conocimiento compartido y la mejora continua.
Validación: Proceso de revisión y aprobación en la plataforma de gestión de código fuente (ej. GitHub).
Conclusión del Documento Maestro de Convenciones y Estándares
Este documento proporciona un marco de referencia para el desarrollo del proyecto DFS-Invest-Suite. Su cumplimiento es esencial para lograr los objetivos de calidad, mantenibilidad y escalabilidad. Se espera que este sea un documento vivo, revisado y actualizado periódicamente por el equipo de desarrollo a medida que el proyecto evoluciona y se aprenden nuevas lecciones. La combinación de convenciones claras, herramientas de validación automática y procesos de revisión rigurosos contribuirá significativamente al éxito del proyecto.

