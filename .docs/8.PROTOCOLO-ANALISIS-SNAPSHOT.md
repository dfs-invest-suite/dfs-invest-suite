PROTOCOLO DE ANÁLISIS DE SNAPSHOT
Cuando recibas un nuevo snapshot del proyecto, realizarás un análisis exhaustivo que establecerá esta versión como tu ÚNICA FUENTE DE VERDAD. Este análisis profundo es fundamental para todas tus acciones posteriores.
PROCESO DE DISECCIÓN DEL CÓDIGO
ANÁLISIS ESTRUCTURAL COMPLETO:
Mapea la estructura completa del monorepo NX
Identifica todos los componentes, librerías, aplicaciones y módulos
Establece las relaciones e interdependencias entre artefactos
Visualiza la arquitectura hexagonal implementada
ANÁLISIS ARCHIVO POR ARCHIVO:
Examina meticulosamente cada archivo del proyecto
Comprende su propósito específico dentro de la arquitectura global
Identifica patrones recurrentes y convenciones de código utilizadas
Determina su rol en los flujos de datos y la lógica de negocio
EXTRACCIÓN DE CONOCIMIENTO TÉCNICO:
Documenta todas las convenciones de nomenclatura detectadas
Cataloga los patrones de diseño implementados
Identifica las prácticas de testing utilizadas
Registra las configuraciones de herramientas (ESLint, Prettier, etc.)
Mapea todas las dependencias y sus versiones específicas
ANÁLISIS DE CALIDAD Y OPTIMIZACIÓN:
Identifica potenciales puntos de mejora en la arquitectura
Detecta posibles inconsistencias o deuda técnica
Evalúa la cobertura y estrategia de testing
Analiza la escalabilidad y mantenibilidad de la implementación actual
ACTUALIZACIÓN DE CONOCIMIENTO DEL PROYECTO
Este snapshot pasa a ser inmediatamente tu ÚNICA FUENTE DE VERDAD
Cualquier modificación posterior que realices se integra a tu comprensión del proyecto
En caso de conflicto entre tu conocimiento previo y este snapshot, el snapshot tiene prioridad absoluta
PROCEDIMIENTO PARA TAREAS POSTERIORES
Para cada tarea técnica que realices después del análisis:
CONTEXTUALIZACIÓN OBLIGATORIA:
Traerás a contexto el archivo o archivos relevantes desde el snapshot
Si has realizado modificaciones posteriores, traerás la versión más actualizada
Citarás explícitamente las secciones de código que son relevantes para la tarea
VERIFICACIÓN DE DEPENDENCIAS:
Identificarás todos los archivos y componentes que podrían verse afectados
Evaluarás el impacto de los cambios propuestos en el ecosistema completo
Garantizarás la coherencia con el resto del proyecto
MANEJO DE INCERTIDUMBRES:
Cuando tengas dudas sobre algún aspecto del código, solicitarás explícitamente:
El código fuente completo del archivo específico
Clarificación sobre la intención de ciertas implementaciones
Explicación de patrones o convenciones no documentadas
Articularás claramente la información exacta que necesitas y por qué la necesitas
PRINCIPIO DE INTEGRIDAD DEL CONOCIMIENTO
Nunca asumirás la existencia o implementación de componentes no vistos en el snapshot
No introducirás patrones o convenciones que no estén presentes en el código analizado
Mantendrás absoluta fidelidad a la arquitectura y decisiones técnicas evidenciadas
Solicitarás información adicional antes de proceder cuando haya ambigüedad
COMPROMISO CON LA CONTINUIDAD TÉCNICA
Tu responsabilidad fundamental es mantener la integridad y coherencia técnica del proyecto, asegurando que cada modificación respete la visión arquitectónica establecida en el snapshot mientras introduces mejoras alineadas con los estándares más altos del desarrollo en NX.

---

---

Prompt: Análisis Técnico Completo del Proyecto React PWA-Supervisor
Objetivo del Análisis
Por favor, proporcione un análisis técnico exhaustivo del proyecto PWA-Supervisor que incluya:

Visión general arquitectónica:

Descripción de la arquitectura global (monorepo NX, DDD, hexagonal)
Propósito principal de la aplicación PWA-Supervisor
Interacción con otros módulos/aplicaciones del monorepo

Análisis detallado de estructura de archivos:

Desglose del árbol de directorios de pwa-supervisor
Mapeo de la implementación de arquitectura hexagonal (puertos, adaptadores)
Organización de dominios según DDD
Librerías compartidas (ej. ui-utils) y su propósito

Explicación técnica por componente:

Función específica de cada archivo
Patrones de diseño implementados
Hooks personalizados y su propósito
Sistema de tipado (PropTypes, TypeScript)
Gestión de estado (Context API, Redux, MobX, etc.)

Flujos de datos:

Ciclo de vida de los datos dentro de la aplicación
Implementación de puertos y adaptadores
Manejo de efectos secundarios (side effects)
Estrategias de caching y persistencia

Integración y construcción:

Configuración de Webpack/bundler
Estrategias de code-splitting
Implementación de características PWA (Service Workers, Manifest)
Gestión de dependencias en el contexto del monorepo

Patrones de prueba:

Enfoque de testing (TDD, BDD)
Cobertura actual de pruebas
Herramientas de testing utilizadas

Rendimiento y optimización:

Estrategias de memoización
Técnicas de rendering condicional
Lazy loading implementado

Funcionalidades actuales y proyectadas:

Características implementadas
Roadmap de funcionalidades pendientes
Dependencias entre características

Términos Técnicos Específicos a Incluir

Arquitectónicos: Bounded Contexts, Aggregate Roots, Value Objects, Entidades, Repositorios, Factories
React: HOCs, Render Props, Composition, VDOM Reconciliation, Fiber Architecture
Monorepo: Workspace Dependencies, Affected Commands, Project Graph, Dependency Graph
NX: Computation Caching, Affected Testing, Task Runners, Project Constraints
Hexagonal: Puertos, Adaptadores primarios/secundarios, Use Cases, Application Services
PWA: App Shell Model, Workbox, Cache Strategies, IndexedDB, Background Sync

Solicitudes Específicas

Identificar los posibles cuellos de botella en rendimiento
Detectar potenciales problemas de mantenibilidad
Sugerir mejoras en la organización de código según principios DDD
Evaluar si la implementación hexagonal es correcta y pura
Analizar si las librerías compartidas (como ui-utils) siguen principios SOLID

## Este análisis servirá como base para nuestro trabajo futuro de desarrollo, refactorización y expansión del proyecto.

---
